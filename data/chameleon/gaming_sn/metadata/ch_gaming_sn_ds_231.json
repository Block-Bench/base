{
  "id": "ch_gaming_sn_ds_231",
  "contract_file": "contracts/ch_gaming_sn_ds_231.sol",
  "subset": "chameleon_gaming",
  "ground_truth": {
    "is_vulnerable": true,
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "vulnerable_location": {
      "contract_name": "VulnContract",
      "function_name": "multiple",
      "line_numbers": []
    },
    "root_cause": "The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.",
    "attack_vector": "The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.",
    "impact": "Severity: critical",
    "correct_fix": "Avoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }"
  },
  "provenance": {
    "source": "other",
    "original_id": "defivulnlabs_readonlyreentrancy",
    "url": null,
    "date_discovered": null,
    "date_added": "2025-12-16",
    "added_by": "benchmark_team"
  },
  "code_metadata": {
    "solidity_version": "0.8.18",
    "num_lines": 138,
    "num_contracts": 4,
    "contract_names": [
      "VulnContract",
      "ExploitContract",
      "ExploitTest",
      "hack"
    ],
    "num_functions": 11,
    "has_imports": true,
    "imports": [],
    "has_inheritance": true,
    "inherits_from": [],
    "has_modifiers": false,
    "has_events": false,
    "has_assembly": false,
    "compilation_verified": false,
    "compiler_version_used": null
  },
  "tags": [
    "defivulnlabs",
    "tier_4_expert",
    "solidity"
  ],
  "notes": null,
  "difficulty_fields": {
    "difficulty_tier": 4,
    "difficulty_tier_name": "multi_contract",
    "complexity_analysis": {
      "complexity_factors": [],
      "detection_hints": "The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.",
      "detection_challenges": null,
      "estimated_human_time_minutes": null
    },
    "canonical_example": false
  },
  "evaluation_support": {
    "annotated_contract": "labelled_data/difficulty_stratified/contracts/ds_231.sol",
    "detailed_metadata": "labelled_data/difficulty_stratified/metadata/ds_231.json",
    "original_id": "defivulnlabs_readonlyreentrancy"
  },
  "original_contract_file": "base/contracts/ds_231.sol",
  "sanitized_from": "ds_231",
  "transformation": {
    "strategy": "chameleon",
    "theme": "gaming",
    "source": "sanitized",
    "seed": 3440646750,
    "coverage": {
      "total_identifiers": 74,
      "transformed": 41,
      "untransformed": 33,
      "skipped_reserved": 34,
      "skipped_interface": 0,
      "coverage_percent": 55.41,
      "untransformed_details": [
        {
          "name": "SPDX",
          "reason": "no synonym found"
        },
        {
          "name": "License",
          "reason": "no synonym found"
        },
        {
          "name": "Identifier",
          "reason": "no synonym found"
        },
        {
          "name": "MIT",
          "reason": "no synonym found"
        },
        {
          "name": "forge",
          "reason": "no synonym found"
        },
        {
          "name": "std",
          "reason": "no synonym found"
        },
        {
          "name": "Test",
          "reason": "no synonym found"
        },
        {
          "name": "sol",
          "reason": "no synonym found"
        },
        {
          "name": "ICurve",
          "reason": "no synonym found"
        },
        {
          "name": "amounts",
          "reason": "no synonym found"
        },
        {
          "name": "STETH_POOL",
          "reason": "no synonym found"
        },
        {
          "name": "steCRV",
          "reason": "no synonym found"
        },
        {
          "name": "rewards",
          "reason": "no synonym found"
        },
        {
          "name": "the",
          "reason": "no synonym found"
        },
        {
          "name": "based",
          "reason": "no synonym found"
        },
        {
          "name": "IERC20",
          "reason": "no synonym found"
        },
        {
          "name": "rewarding",
          "reason": "no synonym found"
        },
        {
          "name": "Omitting",
          "reason": "no synonym found"
        },
        {
          "name": "_target",
          "reason": "no synonym found"
        },
        {
          "name": "into",
          "reason": "no synonym found"
        },
        {
          "name": "console",
          "reason": "no synonym found"
        },
        {
          "name": "after",
          "reason": "no synonym found"
        },
        {
          "name": "Curve",
          "reason": "no synonym found"
        },
        {
          "name": "before",
          "reason": "no synonym found"
        },
        {
          "name": "invokes",
          "reason": "no synonym found"
        },
        {
          "name": "recieve",
          "reason": "no synonym found"
        },
        {
          "name": "called",
          "reason": "no synonym found"
        },
        {
          "name": "when",
          "reason": "no synonym found"
        },
        {
          "name": "during",
          "reason": "no synonym found"
        },
        {
          "name": "createSelectFork",
          "reason": "no synonym found"
        },
        {
          "name": "mainnet",
          "reason": "no synonym found"
        },
        {
          "name": "testExecution",
          "reason": "no synonym found"
        },
        {
          "name": "eth",
          "reason": "no synonym found"
        }
      ],
      "meets_threshold": false
    },
    "rename_map": {
      "get_virtual_price": "obtain_virtual_value",
      "add_liquidity": "append_flow",
      "min_mint_amount": "minimum_craft_count",
      "remove_liquidity": "eliminate_flow",
      "min_amounts": "floor_amounts",
      "remove_liquidity_one_coin": "delete_flow_one_coin",
      "min_amount": "floor_sum",
      "LP_TOKEN": "lp_coin",
      "Token": "Medal",
      "CoreContract": "CorePact",
      "users": "heroes",
      "stake": "lockEnergy",
      "getReward": "acquireBounty",
      "current": "present",
      "price": "value",
      "pool": "lootPool",
      "token": "crystal",
      "amount": "sum",
      "sender": "initiator",
      "unstake": "withdrawStake",
      "tokens": "coins",
      "reward": "payout",
      "OperatorContract": "GameoperatorPact",
      "lpToken": "lpCoin",
      "target": "aim",
      "Stake": "PledgeStrength",
      "stakeTokens": "pledgeCrystals",
      "value": "worth",
      "log": "record",
      "staking": "powerStaking",
      "performReadOnlyCallback": "performReadOnlyReply",
      "Add": "Attach",
      "liquidity": "flow",
      "Log": "Record",
      "Remove": "Eliminate",
      "from": "origin",
      "callback": "response",
      "complete": "missionAccomplished",
      "OperatorTest": "QuestrunnerTest",
      "execute": "completeQuest",
      "setUp": "groupUp"
    }
  }
}