{
  "id": "ch_medical_sn_ds_088",
  "contract_file": "contracts/ch_medical_sn_ds_088.sol",
  "subset": "chameleon_medical",
  "ground_truth": {
    "is_vulnerable": true,
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "vulnerable_location": {
      "contract_name": "ContractTest",
      "function_name": "multiple",
      "line_numbers": []
    },
    "root_cause": "Using abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.",
    "attack_vector": "Using abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.",
    "impact": "Severity: medium",
    "correct_fix": "use of abi.encode() instead of abi.encodePacked()"
  },
  "provenance": {
    "source": "other",
    "original_id": "defivulnlabs_hash-collisions",
    "url": null,
    "date_discovered": null,
    "date_added": "2025-12-16",
    "added_by": "benchmark_team"
  },
  "code_metadata": {
    "solidity_version": "^0.8.15",
    "num_lines": 57,
    "num_contracts": 2,
    "contract_names": [
      "ContractTest",
      "HashCollisionBug"
    ],
    "num_functions": 4,
    "has_imports": true,
    "imports": [],
    "has_inheritance": true,
    "inherits_from": [],
    "has_modifiers": false,
    "has_events": true,
    "has_assembly": false,
    "compilation_verified": false,
    "compiler_version_used": null
  },
  "tags": [
    "defivulnlabs",
    "tier_2_medium",
    "solidity"
  ],
  "notes": null,
  "difficulty_fields": {
    "difficulty_tier": 2,
    "difficulty_tier_name": "clear_audit",
    "complexity_analysis": {
      "complexity_factors": [],
      "detection_hints": "Using abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.",
      "detection_challenges": null,
      "estimated_human_time_minutes": null
    },
    "canonical_example": false
  },
  "evaluation_support": {
    "annotated_contract": "labelled_data/difficulty_stratified/contracts/ds_088.sol",
    "detailed_metadata": "labelled_data/difficulty_stratified/metadata/ds_088.json",
    "original_id": "defivulnlabs_hash-collisions"
  },
  "original_subset": "difficulty_stratified",
  "original_contract_file": "base/contracts/ds_088.sol",
  "sanitized_from": "ds_088",
  "transformation": {
    "strategy": "chameleon",
    "theme": "medical",
    "source": "sanitized",
    "seed": 91262813,
    "coverage": {
      "total_identifiers": 39,
      "transformed": 15,
      "untransformed": 24,
      "skipped_reserved": 27,
      "skipped_interface": 0,
      "coverage_percent": 38.46,
      "untransformed_details": [
        {
          "name": "SPDX",
          "reason": "no synonym found"
        },
        {
          "name": "License",
          "reason": "no synonym found"
        },
        {
          "name": "Identifier",
          "reason": "no synonym found"
        },
        {
          "name": "MIT",
          "reason": "no synonym found"
        },
        {
          "name": "forge",
          "reason": "no synonym found"
        },
        {
          "name": "std",
          "reason": "no synonym found"
        },
        {
          "name": "Test",
          "reason": "no synonym found"
        },
        {
          "name": "sol",
          "reason": "no synonym found"
        },
        {
          "name": "testHash_collisions",
          "reason": "no synonym found"
        },
        {
          "name": "AAA",
          "reason": "no synonym found"
        },
        {
          "name": "BBB",
          "reason": "no synonym found"
        },
        {
          "name": "ABBB",
          "reason": "no synonym found"
        },
        {
          "name": "collision",
          "reason": "no synonym found"
        },
        {
          "name": "detected",
          "reason": "no synonym found"
        },
        {
          "name": "_string1",
          "reason": "no synonym found"
        },
        {
          "name": "_string2",
          "reason": "no synonym found"
        },
        {
          "name": "must",
          "reason": "no synonym found"
        },
        {
          "name": "greater",
          "reason": "no synonym found"
        },
        {
          "name": "than",
          "reason": "no synonym found"
        },
        {
          "name": "zero",
          "reason": "no synonym found"
        },
        {
          "name": "AAABBB",
          "reason": "no synonym found"
        },
        {
          "name": "the",
          "reason": "no synonym found"
        },
        {
          "name": "already",
          "reason": "no synonym found"
        },
        {
          "name": "exists",
          "reason": "no synonym found"
        }
      ],
      "meets_threshold": false
    },
    "rename_map": {
      "ContractTest": "PolicyTest",
      "HashCollision": "SignatureCollision",
      "HashCollisionContract": "SignatureCollisionAgreement",
      "setUp": "groupUp",
      "log_named_bytes32": "record_named_bytes32",
      "Hash": "Signature",
      "createHash": "createChecksum",
      "deposit": "fundAccount",
      "value": "evaluation",
      "expectRevert": "expectUndo",
      "balances": "patientAccounts",
      "Deposit": "SubmitPayment",
      "amount": "units",
      "hash": "checksum",
      "Check": "Inspect"
    }
  }
}