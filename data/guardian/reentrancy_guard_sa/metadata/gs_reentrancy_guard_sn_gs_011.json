{
  "id": "gs_reentrancy_guard_sn_gs_011",
  "contract_file": "contracts/gs_reentrancy_guard_sn_gs_011.sol",
  "subset": "guardianshield",
  "ground_truth": {
    "is_vulnerable": false,
    "original_vulnerable": true,
    "vulnerability_type": "flash_loan",
    "neutralized_by": "reentrancy_guard",
    "neutralization_reason": "Mutex lock prevents recursive calls during execution"
  },
  "provenance": {
    "source": "spearbit",
    "original_id": "gs_spearbit_aragon-lock-to-vote_H01",
    "url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
    "date_discovered": "2025-09-11",
    "date_added": "2025-12-16",
    "added_by": "benchmark_team"
  },
  "code_metadata": {
    "solidity_version": "^0.8.0",
    "num_lines": 50,
    "num_contracts": 1,
    "contract_names": [],
    "num_functions": 0,
    "has_imports": false,
    "imports": [],
    "has_inheritance": false,
    "inherits_from": [],
    "has_modifiers": false,
    "has_events": false,
    "has_assembly": false,
    "compilation_verified": false,
    "compiler_version_used": null
  },
  "tags": [
    "flash_loan",
    "spearbit",
    "gold_standard",
    "audit_finding"
  ],
  "notes": "The MinVotingPowerCondition.isGranted() function at line 45 checks 'token.balanceOf(_who) + lockManager.getLockedBalance(_who)'. Since token.balanceOf() can be temporarily inflated via flashloans, an attacker can bypass the minimum voting power requirement without actually having tokens locked. Combined with EarlyExecution mode, this allows creating and executing malicious proposals in a single transaction.",
  "gold_standard_fields": {
    "source_report": "Aragon DAO Gov Plugin Security Review",
    "source_finding_id": "H-01",
    "finding_title": "MinVotingPowerCondition logic can be bypassed via flashloans",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "has_context": true,
    "call_flow": "Attacker.flashloan() -> MinVotingPowerCondition.isGranted() checks token.balanceOf(_who) + lockManager.getLockedBalance(_who) -> returns true -> LockToVotePlugin.createProposal() succeeds -> repay flashloan"
  },
  "evaluation_support": {
    "annotated_contract": "labelled_data/gold_standard/contracts/gs_011.sol",
    "detailed_metadata": "labelled_data/gold_standard/metadata/gs_011.json",
    "original_finding_title": "MinVotingPowerCondition logic can be bypassed via flashloans"
  },
  "original_subset": "gold_standard",
  "original_contract_file": "base/contracts/gs_011.sol",
  "sanitized_from": "gs_011",
  "derived_from": "sn_gs_011",
  "transformation": {
    "strategy": "guardian_shield",
    "protection_type": "reentrancy_guard",
    "injection_details": {
      "import_added": true,
      "inheritance_added": true,
      "functions_protected": [],
      "protection_type": "reentrancy_guard"
    }
  }
}