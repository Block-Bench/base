{
  "id": "gs_reentrancy_guard_sn_gs_021",
  "contract_file": "contracts/gs_reentrancy_guard_sn_gs_021.sol",
  "subset": "guardianshield",
  "ground_truth": {
    "is_vulnerable": false,
    "original_vulnerable": true,
    "vulnerability_type": "signature_replay",
    "neutralized_by": "reentrancy_guard",
    "neutralization_reason": "Mutex lock prevents recursive calls during execution"
  },
  "provenance": {
    "source": "spearbit",
    "original_id": "gs_spearbit_kyber-hook_M01",
    "url": "https://github.com/spearbit/portfolio/tree/master/pdfs",
    "date_discovered": "2025-10-01",
    "date_added": "2025-12-16",
    "added_by": "benchmark_team"
  },
  "code_metadata": {
    "solidity_version": "^0.8.0",
    "num_lines": 177,
    "num_contracts": 1,
    "contract_names": [],
    "num_functions": 0,
    "has_imports": false,
    "imports": [],
    "has_inheritance": false,
    "inherits_from": [],
    "has_modifiers": false,
    "has_events": false,
    "has_assembly": false,
    "compilation_verified": false,
    "compiler_version_used": null
  },
  "tags": [
    "signature_replay",
    "spearbit",
    "gold_standard",
    "audit_finding"
  ],
  "notes": "The vulnerability is in the digest creation at lines 118-129. The keccak256 hash does not include chainId or any EIP712 domain separator. Since sender is the router contract (same on multiple chains), key is the PoolKey (can be identical across chains), and all other parameters are user-provided, an attacker can replay the exact same signature on a different chain where the same hook/pool configuration exists.",
  "gold_standard_fields": {
    "source_report": "Uniswap Foundation: Kyber Hook Security Review",
    "source_finding_id": "M-01",
    "finding_title": "Signed swap digest lacks a domain separator",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "has_context": true,
    "call_flow": "Router.swap() -> PoolManager.swap() -> UniswapV4KEMHook.beforeSwap(sender=router, key, params, hookData) -> HookDataDecoder.decodeAllHookData(hookData) extracts signature params -> keccak256(abi.encode(sender, key, zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, expiryTime)) creates digest WITHOUT chainId -> SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature) validates -> Same signature valid on any chain with matching parameters"
  },
  "evaluation_support": {
    "annotated_contract": "labelled_data/gold_standard/contracts/gs_021.sol",
    "detailed_metadata": "labelled_data/gold_standard/metadata/gs_021.json",
    "original_finding_title": "Signed swap digest lacks a domain separator"
  },
  "original_subset": "gold_standard",
  "original_contract_file": "base/contracts/gs_021.sol",
  "sanitized_from": "gs_021",
  "derived_from": "sn_gs_021",
  "transformation": {
    "strategy": "guardian_shield",
    "protection_type": "reentrancy_guard",
    "injection_details": {
      "import_added": true,
      "inheritance_added": true,
      "functions_protected": [
        "claimEgTokens"
      ],
      "protection_type": "reentrancy_guard"
    }
  }
}